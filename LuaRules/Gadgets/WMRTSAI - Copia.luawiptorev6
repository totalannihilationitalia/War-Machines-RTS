--------------------------------------------------------------------------------
-- War Machines RTS - AI Gadget (v0.6 - Correzioni Multiple)
-- Nome AI: WMRTSAI
--------------------------------------------------------------------------------

function gadget:GetInfo()
  return {
    name      = "WMRTSAI", -- Nome usato per assegnare l'IA ai team!
    desc      = "AI con gestione fazioni, tiers, tipi mappa e config per livello tech.",
    author    = "Il Tuo Nome", -- Cambia questo!
    date      = "Data Corrente", -- Cambia questo!
    license   = "La Tua Licenza", -- Cambia questo!
    layer     = 90, -- Layer alto per eseguire dopo altri gadget (come Mexspot Fetcher)
    enabled   = true
  }
end

-- Variabili globali del gadget
local gameStarted = false
local teamData = {} -- Stato per ogni team AI
local WMRTSAI_Debug_Mode = 1 -- Iniziamo con debug attivo

--------------------------------------------------------------------------------
-- SYNCED CODE - Logica di gioco principale
--------------------------------------------------------------------------------
if (gadgetHandler:IsSyncedCode()) then

  -- Speedups e locali (CMD non serve più qui se usiamo Command.* o -ID)
  local Spring = Spring
  local Game = Game
  -- local CMD = Command -- Rimosso, usiamo Command.* o -ID
  local UnitDefs = UnitDefs
  local UnitDefNames = UnitDefNames

  local LOG_SECTION = "WMRTSAI"

  -- Funzione helper per il logging debug
  local function Log(teamID, message)
    if WMRTSAI_Debug_Mode > 0 then
      local teamPrefix = teamID and ("Team[" .. teamID .. "] ") or (LOG_SECTION .. ": ")
      Spring.Echo(teamPrefix .. message)
    end
  end

  -- === 1. DEFINIZIONE FAZIONI E UNITÀ PER TIER ===
  -- !! IMPORTANTE: Compila con NOMI ESATTI, moveType e role corretti !!
  local factionUnits = {
      ICU = {
          commander = "icucom",
          T1 = {
              extractor =   { name = "icumetex", moveType="BUILDING", role="Extractor_T1"},
              powerPlant =  { name = "armsolar", moveType="BUILDING", role="Power_T1"},
              factory =     { name = "armlab", moveType = "BUILDING", role="Factory_Land_T1"},
              constructor = { name = "icuck", moveType = "LAND", role="Constructor_T1" },
              attackers = { { name = "icupatroller", moveType = "LAND", role="Basic_T1" }, },
              defenses = { { name = "iculighlturr", moveType = "BUILDING", role="Light_T1" }, }
          },
          T2 = {
              extractor =   { name = "armamex", moveType="BUILDING", role="Extractor_T2"},
              powerPlant =  { name = "armfus", moveType="BUILDING", role="Power_T2"},
              factory =     { name = "armalab", moveType = "BUILDING", role="Factory_Land_T2" },
              constructor = { name = "armack", moveType = "LAND", role="Constructor_T2" },
              attackers = { { name = "armfboy", moveType = "LAND", role="Heavy_T2" }, },
              defenses = { { name = "armhlt", moveType = "BUILDING", role="Heavy_T2" } }
          },
          T3 = {
              factory =     { name = "armshltx", moveType = "BUILDING", role="Factory_Land_T3" },
              -- constructor = { ... },
              attackers = { { name = "armshock", moveType = "LAND", role="Experimental_T3" }, },
              defenses = { { name = "armanni", moveType = "BUILDING", role="Experimental_T3" } }
          },
          _unitDefIDs = {}
      },
      NFA = { -- !! COMPILA !!
          commander = "nfacom",
          T1 = { extractor = { name = "nfa_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="nfa_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="nfa_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="nfa_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="nfa_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="nfa_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "nfa_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="nfa_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="nfa_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="nfa_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="nfa_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="nfa_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="nfa_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="nfa_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="nfa_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="nfa_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      },
       AND = { -- !! COMPILA !!
          commander = "andcom",
          T1 = { extractor = { name = "and_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="and_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="and_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="and_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="and_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="and_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "and_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="and_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="and_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="and_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="and_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="and_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="and_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="and_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="and_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="and_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      },
      EUF = { -- !! COMPILA !!
          commander = "eufcd",
          T1 = { extractor = { name = "euf_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="euf_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="euf_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="euf_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="euf_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="euf_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "euf_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="euf_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="euf_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="euf_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="euf_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="euf_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="euf_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="euf_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="euf_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="euf_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      }
      -- Non serve sezione common se tutto è per fazione/tier
  }

  -- Mappa Comandante -> Fazione
  local commanderFactionMap = {
      icucom = "ICU",
      nfacom = "NFA",
      andcom = "AND",
      eufcd  = "EUF"
  }

  -- Funzione ricorsiva per popolare gli UnitDefID e altri dati
  local function PopulateUnitDefIDs(dataTable, idTable)
      for key, value in pairs(dataTable) do
          if type(value) == "table" then
              if value.name and value.moveType then -- Definizione di unità singola
                  local unitDef = UnitDefNames[value.name]
                  if unitDef then
                      idTable[key] = {}
                      for k,v in pairs(value) do idTable[key][k]=v end
                      idTable[key].id = unitDef.id
                  else
                      Log(nil, "ERROR: Unit definition name '" .. value.name .. "' not found for key '" .. key .. "'!")
                      idTable[key] = nil
                  end
              elseif key == "attackers" or key == "defenses" then -- Lista di unità
                  idTable[key] = {}
                  for i, unitData in ipairs(value) do
                      if unitData.name and unitData.moveType then
                          local unitDef = UnitDefNames[unitData.name]
                          if unitDef then
                              local newItem = {}
                              for k,v in pairs(unitData) do newItem[k]=v end
                              newItem.id = unitDef.id
                              table.insert(idTable[key], newItem)
                          else
                              Log(nil, "ERROR: Unit definition name '" .. unitData.name .. "' not found in list '" .. key .. "'!")
                          end
                      end
                  end
              elseif key ~= "_unitDefIDs" then -- Sotto-tabella (T1, T2, T3)
                  if not idTable[key] then idTable[key] = {} end
                  PopulateUnitDefIDs(value, idTable[key])
              end
          end
      end
  end

  -- === 2. DEFINIZIONE CATEGORIE MAPPE ===
  local mapCategories = {
      ["zoty outpost"] = "LAND",
      ["altra_mappa_terra"] = "LAND",
      ["mappa_isole_1"] = "NAVAL_ISLANDS",
      ["arcadia bay"] = "NAVAL_ISLANDS",
      ["spazio_profondo_x"] = "SPACE",
      ["oceano_infinito"] = "NAVAL_PURE",
      -- ... aggiungi tutte le tue mappe ...
  }
  local currentMapCategory = "LAND" -- Default

  -- === 4. CONFIGURAZIONE AI PER TECH LEVEL ===
  local aiConfig = {
      [0] = {
          economyTargets = {
              { role = "T1_Extractor", min = 1, max = 2 },
              { role = "T1_PowerPlant", min = 1, max = 2 },
          },
          factoryTargets = { minTotal = 1, maxTotal = 1, targetTier = 1 },
          productionList = { },
          attackGroup = { min = 5, max = 8, target = "PATROL_NEARBY" }
      },
      [1] = {
          economyTargets = {
              { role = "T1_Extractor", min = 2, max = 3 },
              { role = "T1_PowerPlant", min = 2, max = 3 },
              -- { role = "T2_Extractor", min = 1, max = 1 },
              -- { role = "T2_PowerPlant", min = 1, max = 2 },
          },
          factoryTargets = { minTotal = 2, maxTotal = 3, targetTier = 1 },
          productionList = {
              { role = "T1_Constructor", priority = 100, max = 3 },
              { role = "T1_Attacker_Basic", priority = 80, max = 0 },
          },
          attackGroup = { min = 8, max = 12, target = "ATTACK_ENEMY_EXPANSION" }
      },
      [2] = {
          economyTargets = {
              { role = "T1_Extractor", min = 6, max = 8 },
              { role = "T1_PowerPlant", min = 8, max = 12 },
              { role = "T2_Extractor", min = 3, max = 5 },
              { role = "T2_PowerPlant", min = 4, max = 6 },
          },
          factoryTargets = { minTotal = 3, maxTotal = 5, targetTier = 2 },
          productionList = {
               { role = "T2_Constructor", priority = 100, max = 2 },
               { role = "T2_Attacker_Heavy", priority = 80, max = 0 },
               { role = "T1_Attacker_Basic", priority = 60, max = 0 },
          },
          attackGroup = { min = 10, max = 15, target = "ATTACK_ENEMY_BASE" }
      },
      [3] = {
          economyTargets = {
              { role = "T2_Extractor", min = 5, max = 8 },
              { role = "T2_PowerPlant", min = 6, max = 10 },
              -- { role = "T3_Extractor", min = 2, max = 4 },
              -- { role = "T3_PowerPlant", min = 3, max = 5 },
          },
          factoryTargets = { minTotal=4, maxTotal=7, targetTier=3 },
          productionList = {
             -- { role = "T3_Constructor", priority = 100, max = 1 },
             { role = "T3_Attacker_Experimental", priority = 90, max = 3 },
             { role = "T2_Attacker_Heavy", priority = 70, max = 0 },
          },
          attackGroup = { min = 12, max = 20, target = "ATTACK_ENEMY_BASE_PRIORITY" }
      }
  }

  -- === Funzioni Helper ===

  -- Helper: GetUnitDataByRole - Versione che gestisce eco tiered
  function GetUnitDataByRole(faction, tier, role)
      local factionData = factionUnits[faction]
      if not factionData then return nil end
      local fDefs = factionData._unitDefIDs
      if not fDefs then return nil end

      local roleTier = tonumber(role:match("^T(%d+)")) or 0
      if roleTier == 0 then return nil end

      local tierKey = "T" .. roleTier
      local tDefs = fDefs[tierKey]
      if not tDefs then return nil end

      if role == tierKey .. "_Constructor" then return tDefs.constructor
      elseif role == tierKey .. "_Factory" then return tDefs.factory
      elseif role == tierKey .. "_Extractor" then return tDefs.extractor
      elseif role == tierKey .. "_PowerPlant" then return tDefs.powerPlant
      elseif role:find(tierKey .. "_Attacker") then
          if not tDefs.attackers or #tDefs.attackers == 0 then return nil end
          if role == tierKey .. "_Attacker_Basic" then return tDefs.attackers[1]
          elseif role == tierKey .. "_Attacker_Heavy" then return tDefs.attackers[1]
          elseif role == tierKey .. "_Attacker_Support" then return #tDefs.attackers >= 2 and tDefs.attackers[2] or nil
          elseif role == tierKey .. "_Attacker_Experimental" then return tDefs.attackers[1]
          else return tDefs.attackers[1] end
      elseif role:find(tierKey .. "_Defense") then
           if not tDefs.defenses or #tDefs.defenses == 0 then return nil end
           if role == tierKey .. "_Defense_Light" then return tDefs.defenses[1]
           elseif role == tierKey .. "_Defense_Heavy" then return #tDefs.defenses >= 2 and tDefs.defenses[2] or nil
           else return tDefs.defenses[1] end
      end

      -- Log(faction, "Warning: Role '"..role.."' could not be mapped.")
      return nil
  end

   -- Trova posizione Metallo - Aggiornato per leggere direttamente da GameRules (Fallback Definitivo per v100)
  function FindBestMetalSpotForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then Log(teamData.teamID, "FindBestMetalSpot: Builder position not found."); return nil end

      -- === LEGGI DIRETTAMENTE DALLE GAMERULES ===
      local mexCount = Spring.GetGameRulesParam("mex_count")
      -- ========================================

      local bestSpot = nil
      local minDistSq = math.huge
      local mexDefData = GetUnitDataByRole(teamData.faction, 1, "T1_Extractor")
      if not mexDefData then Log(teamData.teamID,"FindBestMetalSpot: Cannot find T1_Extractor definition!"); return nil end
      local mexDefID = mexDefData.id

      -- Itera usando i dati letti dalle GameRules
      if mexCount and mexCount > 0 then
           Log(teamData.teamID, "FindBestMetalSpot: Found " .. mexCount .. " metal spots in GameRules.") -- Debug
          for i = 1, mexCount do
               -- Leggi i dati per questo spot dalle GameRules
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotY = Spring.GetGameRulesParam("mex_y" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)

               -- Controlla se abbiamo ottenuto coordinate valide
               if spotX and spotY and spotZ then
                   -- Controlla se è occupato
                   local unitsNear = Spring.GetUnitsInRectangle(spotX-10, spotZ-10, spotX+10, spotZ+10)
                   local occupied = false
                   if unitsNear then
                       for _, nearID in ipairs(unitsNear) do
                           local nearDef = UnitDefs[Spring.GetUnitDefID(nearID)]
                           if nearDef and nearDef.extractsMetal and nearDef.extractsMetal > 0 then occupied = true; break end
                       end
                   end

                   if not occupied then
                      -- Controlla costruibilità usando TestBuildOrder
                      local buildResult = Spring.TestBuildOrder(mexDefID, spotX, spotY, spotZ, 1)
                      if buildResult == 0 or buildResult == 2 then
                          local dx, dz = spotX - bx, spotZ - bz
                          local distSq = dx*dx + dz*dz
                          if distSq < minDistSq then
                              minDistSq = distSq
                              bestSpot = {x=spotX, y=spotY, z=spotZ}
                          end
                       else Log(teamData.teamID, "Spot "..i.." not buildable, code: "..buildResult) -- Debug Build Fail
                      end
                    else Log(teamData.teamID, "Spot "..i.." occupied.") -- Debug Occupied
                   end
               else
                   Log(teamData.teamID, "FindBestMetalSpot: Warning - Got nil coordinate reading GameRules for mex index " .. i)
               end -- fine if spotX/Y/Z
          end -- fine ciclo for i=1, mexCount
      else
          Log(teamData.teamID, "FindBestMetalSpot: Could not find 'mex_count' or it was 0 in GameRules.")
      end -- fine if mexCount

      if bestSpot then Log(teamData.teamID,"Found best metal spot at " .. string.format("%.0f,%.0f", bestSpot.x, bestSpot.z) .. " using GameRules")
      else Log(teamData.teamID,"FindBestMetalSpot: No suitable metal spot found after checking GameRules.") end
      return bestSpot
  end

  -- Trova posizione Energia - Aggiornato per EVITARE Punti Metallo
  function FindGoodEnergySpotForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then return nil end

      local powerDefData = GetUnitDataByRole(teamData.faction, 1, "T1_PowerPlant") -- Cerca T1 power
      if not powerDefData then Log(teamData.teamID,"FindGoodEnergySpot: Cannot find T1_PowerPlant definition!"); return nil end
      local powerDefID = powerDefData.id

      -- Ottieni la lista dei punti metallo per evitarli
      local metalSpots = {}
      local mexCount = Spring.GetGameRulesParam("mex_count")
      if mexCount and mexCount > 0 then
          for i = 1, mexCount do
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)
               if spotX and spotZ then -- Non ci serve y qui
                   table.insert(metalSpots, {x = spotX, z = spotZ})
               end
          end
      end
      -- Log(teamData.teamID, "FindGoodEnergySpot: Found " .. #metalSpots .. " metal spots to avoid.") -- Debug

      local minDistanceToMetalSpotSq = (Game.extractorRadius or 32) * (Game.extractorRadius or 32) * 2.25 -- Distanza minima al quadrato (es. 1.5x raggio estrattore)

      for attempt = 1, 30 do -- Aumenta i tentativi se necessario
          local angle = math.random() * 2 * math.pi
          local dist = 80 + math.random(150) -- Raggio di ricerca più ampio
          local testX, testZ = bx + math.cos(angle)*dist, bz + math.sin(angle)*dist
          local testY = Spring.GetGroundHeight(testX, testZ)

          if testY then
              -- 1. Controlla se è troppo vicino a un punto metallo
              local tooCloseToMetal = false
              for _, metalSpot in ipairs(metalSpots) do
                  local dx = testX - metalSpot.x
                  local dz = testZ - metalSpot.z
                  if (dx*dx + dz*dz) < minDistanceToMetalSpotSq then
                      tooCloseToMetal = true
                      -- Log(teamData.teamID, "FindGoodEnergySpot: Candidate ("..string.format("%.0f,%.0f",testX,testZ)..") too close to metal spot ("..string.format("%.0f,%.0f",metalSpot.x,metalSpot.z)..")") -- Debug
                      break -- È troppo vicino, scarta questa posizione
                  end
              end

              -- 2. Se NON è troppo vicino al metallo, controlla se è costruibile
              if not tooCloseToMetal then
                  local buildResult = Spring.TestBuildOrder(powerDefID, testX, testY, testZ, 1) -- Usa facing 1
                  if buildResult == 0 or buildResult == 2 then
                      -- Log(teamData.teamID,"FindGoodEnergySpot: Found good energy spot at " .. string.format("%.0f,%.0f", testX, testZ))
                      return { x=testX, y=testY, z=testZ }
                  -- else Log(teamData.teamID,"FindGoodEnergySpot: TestBuildOrder failed at ("..string.format("%.0f,%.0f",testX,testZ)..") code: "..buildResult) -- Debug
                  end
              end
          end
      end
      Log(teamData.teamID,"FindGoodEnergySpot: Could not find suitable (non-metal) spot near builder after " .. attempt .. " attempts.")
      return nil
  end

    -- Trova posizione Fabbrica - Aggiornato per EVITARE Punti Metallo
  function FindGoodFactoryPosForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then return nil end

      -- Determina il tier della fabbrica da costruire
      local targetTier = teamData.techLevel + 1
      if targetTier > 3 then targetTier = 3 end -- Non superare il T3 massimo
      local factoryDefData = GetUnitDataByRole(teamData.faction, targetTier, "T"..targetTier.."_Factory")
      if not factoryDefData then Log(teamData.teamID,"FindGoodFactoryPos: Cannot find Factory T"..targetTier.." definition!"); return nil end
      local factoryDefID = factoryDefData.id

      -- Ottieni la lista dei punti metallo per evitarli
      local metalSpots = {}
      local mexCount = Spring.GetGameRulesParam("mex_count")
      if mexCount and mexCount > 0 then
          for i = 1, mexCount do
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)
               if spotX and spotZ then
                   table.insert(metalSpots, {x = spotX, z = spotZ})
               end
          end
      end
      -- Log(teamData.teamID, "FindGoodFactoryPos: Found " .. #metalSpots .. " metal spots to avoid.") -- Debug

      -- Distanza minima al quadrato da un punto metallo (puoi aggiustare il moltiplicatore)
      local minDistanceToMetalSpotSq = (Game.extractorRadius or 32) * (Game.extractorRadius or 32) * 2.25

      for attempt = 1, 30 do -- Aumenta i tentativi se necessario
          local angle = math.random() * 2 * math.pi
          local dist = 150 + math.random(150) -- Raggio di ricerca per fabbriche
          local testX, testZ = bx + math.cos(angle)*dist, bz + math.sin(angle)*dist
          local testY = Spring.GetGroundHeight(testX, testZ)

          if testY then
              -- 1. Controlla se è troppo vicino a un punto metallo
              local tooCloseToMetal = false
              for _, metalSpot in ipairs(metalSpots) do
                  local dx = testX - metalSpot.x
                  local dz = testZ - metalSpot.z
                  if (dx*dx + dz*dz) < minDistanceToMetalSpotSq then
                      tooCloseToMetal = true
                      -- Log(teamData.teamID, "FindGoodFactoryPos: Candidate ("..string.format("%.0f,%.0f",testX,testZ)..") too close to metal spot.") -- Debug
                      break
                  end
              end

              -- 2. Se NON è troppo vicino al metallo, controlla se è costruibile
              if not tooCloseToMetal then
                  local buildResult = Spring.TestBuildOrder(factoryDefID, testX, testY, testZ, 1) -- Usa facing 1
                  if buildResult == 0 or buildResult == 2 then
                      -- Log(teamData.teamID,"FindGoodFactoryPos: Found good factory spot at " .. string.format("%.0f,%.0f", testX, testZ))
                      return { x=testX, y=testY, z=testZ }
                  -- else Log(teamData.teamID,"FindGoodFactoryPos: TestBuildOrder failed at ("..string.format("%.0f,%.0f",testX,testZ)..") code: "..buildResult) -- Debug
                  end
              end
          end
      end
      Log(teamData.teamID,"FindGoodFactoryPos: Could not find suitable (non-metal) spot near builder after " .. attempt .. " attempts.")
      return nil
  end

  -- Funzione per controllare un team e trovare comandante/fazione
  local function CheckTeamCommander(teamID)
      if not teamData[teamID] or teamData[teamID].faction then return end
      local teamUnits = Spring.GetTeamUnits(teamID)
      if not teamUnits then return end
      for _, unitID in ipairs(teamUnits) do
          local unitDefID = Spring.GetUnitDefID(unitID)
          if unitDefID then
              local unitDef = UnitDefs[unitDefID]
              if unitDef then
                  local commanderNameLower = unitDef.name:lower()
                  local faction = commanderFactionMap[commanderNameLower]
                  if faction then
                      local commanderName = unitDef.name:upper()
                      Log(teamID, "Found Commander: " .. commanderName .. " - Faction set to: " .. faction)
                      teamData[teamID].faction = faction
                      teamData[teamID].commanderInfo = { name = commanderName, id = unitID, defID = unitDefID }
                      local comMoveType = UnitDefs[unitDefID].movedata and UnitDefs[unitDefID].movedata.moveType or "UNKNOWN"
                      teamData[teamID].constructors[unitID] = { tier = 0, state = "idle", task = nil, moveType = comMoveType }
                      return
                  end
              end
          end
      end
      if not teamData[teamID].faction and Game.frame > 90 then
          Log(teamID, "WARNING: Could not find starting commander/faction unit after 3 seconds!")
          teamData[teamID].faction = "UNKNOWN"
      end
  end

  -- === 3. LOGICA AVANZAMENTO TECNOLOGICO ===
  local function ManageTechLevel(teamID, frame)
      local data = teamData[teamID]
      if not data or not data.faction or data.faction == "UNKNOWN" or data.techLevel == nil then return end
      local currentLevel = data.techLevel
      local res = data.resourceInfo
      local thresholds = {
          [1] = { metal = 400, energy = 400, prereq = function() return true end },
          [2] = { metal = 2000, energy = 4000, prereq = function() return data:HasFactoryOfTier(1) end },
          [3] = { metal = 8000, energy = 15000, prereq = function() return data:HasFactoryOfTier(2) end }
      }
      local nextLevel = currentLevel + 1
      if thresholds[nextLevel] and currentLevel < 3 then
          local target = thresholds[nextLevel]
          local prereqMet, _ = pcall(target.prereq)
          if prereqMet and (res.metal and res.energy and res.metal >= target.metal and res.energy >= target.energy) then
              data.techLevel = nextLevel
              Log(teamID, "Advanced to Tech Level " .. nextLevel .. "!")
              -- Resetta obiettivi economici quando si sale di livello per ricalcolarli
              data.economyObjectives = {}
              Log(teamID,"Economy objectives reset for new tech level.")
          end
      end
  end

  -- Helper per fabbriche
  function TeamHasFactoryOfTier(teamData, tier)
      local faction = teamData.faction
      if not faction or faction == "UNKNOWN" then return false end
      local targetFactoryData = GetUnitDataByRole(faction, tier, "T"..tier.."_Factory")
      if not targetFactoryData then return false end
      local factories = Spring.GetTeamUnitsByDefs(teamData.teamID, targetFactoryData.id)
      return (factories and #factories > 0)
  end

  -- Funzioni di Gestione Principali
  local function UpdateResourceInfo(teamID, frame)
      local data = teamData[teamID]
      if not data then return end
      if frame - (data.resourceInfo.lastUpdateFrame or -100) > 30 then
          data.resourceInfo.metal, data.resourceInfo.energy = Spring.GetTeamResources(teamID, "metal", "energy")
          local metIncomeOk, metIncome = pcall(Spring.GetTeamResourceIncome, teamID, "metal")
          local metUsageOk, metUsage = pcall(Spring.GetTeamResourceUsage, teamID, "metal")
          local engIncomeOk, engIncome = pcall(Spring.GetTeamResourceIncome, teamID, "energy")
          local engUsageOk, engUsage = pcall(Spring.GetTeamResourceUsage, teamID, "energy")
          data.resourceInfo.metalIncome = (metIncomeOk and metIncome) or 0
          data.resourceInfo.metalUsage = (metUsageOk and metUsage) or 0
          data.resourceInfo.energyIncome = (engIncomeOk and engIncome) or 0
          data.resourceInfo.energyUsage = (engUsageOk and engUsage) or 0
          data.resourceInfo.lastUpdateFrame = frame
      end
  end

  local function ManageEconomy(teamID, frame)
      local data = teamData[teamID]
      if not data or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config or not config.economyTargets then return end

      local res = data.resourceInfo
      local currentEnergyIncome = res.energyIncome or 0
      local currentEnergyUsage = res.energyUsage or 0
      local energyBalance = currentEnergyIncome - currentEnergyUsage
      local desiredEnergySurplus = 15 -- Potresti abbassare leggermente questa, es. 10 o 5
      local prioritizeEnergy = (energyBalance < desiredEnergySurplus)

      local orderGivenThisFrame = false -- Flag per dare solo un ordine per ciclo

      -- 1. Controlla PRIMA se dobbiamo costruire ENERGIA (se prioritaria o no)
      local powerTargetConfig = nil
      local targetPowerRole = (data.techLevel >= 2 and GetUnitDataByRole(data.faction, 2, "T2_PowerPlant") and "T2_PowerPlant") or "T1_PowerPlant" -- Cerca T2 se possibile, altrimenti T1

      for _, target in ipairs(config.economyTargets) do
          if target.role == targetPowerRole then
              powerTargetConfig = target; break
          end
      end

      if powerTargetConfig then
          local roleTier = tonumber(targetPowerRole:match("^T(%d+)")) or 1
          local unitData = GetUnitDataByRole(data.faction, roleTier, targetPowerRole)
          if unitData then
              local unitDefID = unitData.id; local unitDef = UnitDefs[unitDefID]
              if unitDef then
                  -- Determina l'obiettivo numerico random per le centrali
                  if not data.economyObjectives[targetPowerRole] then
                      data.economyObjectives[targetPowerRole] = { targetCount = math.random(powerTargetConfig.min, powerTargetConfig.max), reached = false }
                      Log(teamID, "New Economy Objective for " .. targetPowerRole .. ": Build " .. data.economyObjectives[targetPowerRole].targetCount)
                  end
                  local currentObjective = data.economyObjectives[targetPowerRole]
                  local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)

                  if currentCount < currentObjective.targetCount then
                      if data:CanAfford(unitDefID, frame) then
                          -- Se l'energia è prioritaria OPPURE se semplicemente ne servono di più (sotto obiettivo)
                          if prioritizeEnergy or (not currentObjective.reached) then
                              local builderTier = math.max(0, roleTier - 1)
                              local builderID = data:FindIdleConstructor(builderTier)
                              if builderID then
                                  local buildPos = data:FindGoodEnergySpot(builderID)
                                  if buildPos then
                                      Log(teamID, ">>>>>> Ordering T"..builderTier.." builder "..builderID.." to build "..targetPowerRole.." #"..(currentCount+1).."/"..currentObjective.targetCount.. (prioritizeEnergy and " (PRIORITY)" or ""))
                                      Spring.GiveOrderToUnit(builderID, -unitDefID, { buildPos.x, buildPos.y, buildPos.z }, {})
                                      if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                                      orderGivenThisFrame = true -- Segna che abbiamo dato un ordine
                                      -- NON USCIRE SUBITO, potremmo voler costruire metallo se non era priorità energia
                                  end
                              end
                          end
                      elseif currentCount >= currentObjective.targetCount and not currentObjective.reached then
                           -- Log(teamID, "Economy Objective for " .. targetPowerRole .. " reached.")
                           currentObjective.reached = true
                      end
                  elseif not currentObjective.reached then -- Marcala come raggiunta se >= target
                      -- Log(teamID, "Economy Objective for " .. targetPowerRole .. " already met or exceeded.")
                      currentObjective.reached = true
                  end
              end
          end
      end

      -- 2. Se NON abbiamo dato un ordine per l'energia O l'energia non era prioritaria, controlla ALTRI obiettivi (Estrattori)
      if not orderGivenThisFrame then
          for i, targetConfig in ipairs(config.economyTargets) do
              -- Salta le centrali, le abbiamo già considerate
              if not targetConfig.role:find("PowerPlant") then
                  local role = targetConfig.role
                  local minCount = targetConfig.min; local maxCount = targetConfig.max

                  if not data.economyObjectives[role] then
                      local targetNum = math.random(minCount, maxCount)
                      data.economyObjectives[role] = { targetCount = targetNum, reached = false }
                      Log(teamID, "New Economy Objective for " .. role .. ": Build " .. targetNum)
                  end
                  local currentObjective = data.economyObjectives[role]

                  if not currentObjective.reached then
                      local roleTier = tonumber(role:match("^T(%d+)")) or 1
                      local unitData = GetUnitDataByRole(data.faction, roleTier, role)
                      if unitData then
                          local unitDefID = unitData.id; local unitDef = UnitDefs[unitDefID]
                          if unitDef then
                              local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)
                              if currentCount < currentObjective.targetCount then
                                  if data:CanAfford(unitDefID, frame) then
                                      local builderTier = math.max(0, roleTier - 1)
                                      local builderID = data:FindIdleConstructor(builderTier)
                                      if builderID then
                                          local buildPos = nil
                                          if role:find("Extractor") then buildPos = data:FindBestMetalSpot(builderID) end
                                          if buildPos then
                                              Log(teamID, ">>>>>> Ordering builder "..builderID.." to build "..role.." #"..(currentCount+1).."/"..currentObjective.targetCount)
                                              Spring.GiveOrderToUnit(builderID, -unitDefID, { buildPos.x, buildPos.y, buildPos.z }, {})
                                              if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                                              orderGivenThisFrame = true -- Abbiamo dato un ordine
                                              -- Esci dal ciclo interno DOPO aver dato un ordine per altri edifici
                                              break
                                          end
                                      end
                                  end
                              elseif currentCount >= currentObjective.targetCount then
                                  -- Log(teamID, "Economy Objective for " .. role .. " reached.")
                                  currentObjective.reached = true
                              end
                          end
                      end
                  end
              end -- fine if not PowerPlant
          end -- fine for altri obiettivi
      end -- fine if not orderGivenThisFrame
  end -- Fine ManageEconomy

  -- ManageProduction con correzione ordine fabbrica
  local function ManageProduction(teamID, frame)
      local data = teamData[teamID]
      if not data or not data.faction or data.faction == "UNKNOWN" or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config then return end

      local faction = data.faction
      local techLevel = data.techLevel
      local allowedMoveTypes = {}
      if currentMapCategory == "LAND" then allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true, BUILDING = true }
      elseif currentMapCategory == "NAVAL_ISLANDS" then allowedMoveTypes = { NAVAL = true, AIR = true, BUILDING = true }
      elseif currentMapCategory == "SPACE" then allowedMoveTypes = { AIR = true, SPACE = true, BUILDING = true }
      elseif currentMapCategory == "NAVAL_PURE" then allowedMoveTypes = { NAVAL = true, BUILDING = true }
      end

      -- 1. Costruire Fabbriche?
      if config.factoryTargets then
          local totalFactories = 0
          for tier=1, data.techLevel + 1 do
              local facData = GetUnitDataByRole(faction, tier, "T"..tier.."_Factory")
              if facData then totalFactories = totalFactories + #Spring.GetTeamUnitsByDefs(teamID, facData.id) end
          end

          if totalFactories < config.factoryTargets.minTotal then
              local targetTier = config.factoryTargets.targetTier
              local factoryData = GetUnitDataByRole(faction, targetTier, "T"..targetTier.."_Factory")
              if factoryData and allowedMoveTypes[factoryData.moveType] then
                   if data:CanAfford(factoryData.id, frame) then
                       local builderID = data:FindIdleConstructor(targetTier - 1)
                       if builderID then
                           local buildPos = data:FindGoodFactoryPos(builderID)
                           if buildPos then
                               Log(teamID, "Ordering T"..(targetTier-1).." builder " .. builderID .. " to build T"..targetTier.." factory ("..factoryData.name..") at " .. string.format("%.0f,%.0f", buildPos.x, buildPos.z))
                               Spring.GiveOrderToUnit(builderID, -factoryData.id, { buildPos.x, buildPos.y, buildPos.z }, {})
                               if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                               return
                           end
                       end
                   end
              end
          end
      end -- Fine costruzione fabbriche

      -- 2. Produrre Unità dalle Fabbriche Esistenti
      if config.productionList then
          local sortedProdList = {}
          for _, item in ipairs(config.productionList) do table.insert(sortedProdList, item) end
          table.sort(sortedProdList, function(a,b) return a.priority > b.priority end)

          for factoryTier = 1, data.techLevel do
              local factoryData = GetUnitDataByRole(faction, factoryTier, "T"..factoryTier.."_Factory")
              if factoryData then
                  local factories = Spring.GetTeamUnitsByDefs(teamID, factoryData.id)
                  if factories then
                      for _, factoryID in ipairs(factories) do
                          local orderGivenToThisFactory = false
                          local queue = Spring.GetFactoryCommands(factoryID)
                          if not queue or #queue < 3 then
                              for _, prodItem in ipairs(sortedProdList) do
                                  local unitTier = tonumber(prodItem.role:match("T(%d+)")) or 0
                                  if unitTier <= factoryTier then
                                      local unitData = GetUnitDataByRole(faction, unitTier, prodItem.role)
                                      if unitData and allowedMoveTypes[unitData.moveType] then
                                          local unitDefID = unitData.id
                                          local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)
                                          local maxCount = prodItem.max
                                          local buildThis = false
                                          if prodItem.role:find("Constructor") then
                                               if data:NeedsConstructor(unitTier) then buildThis = true end
                                          elseif maxCount == 0 or currentCount < maxCount then
                                               buildThis = true
                                          end
                                          if buildThis and data:CanAfford(unitDefID, frame) then
                                              Log(teamID, "Ordering T"..factoryTier.." factory " .. factoryID .. " to build "..prodItem.role.." (DefID "..unitDefID..")")
                                              Spring.GiveOrderToUnit(factoryID, -unitDefID, {}, {})
                                              orderGivenToThisFactory = true
                                              break
                                          end
                                      end
                                  end
                              end
                          end
                      end
                  end
              end
          end
      end
  end -- Fine ManageProduction


   function GeneratePatrolPoints(teamID, data)
      if #data.patrolPoints > 0 and not data.regeneratePatrolPoints then
          Log(teamID, "GeneratePatrolPoints: Points already exist and no regeneration forced. Count: " .. #data.patrolPoints)
          return
      end

      Log(teamID, "GeneratePatrolPoints: STARTING generation...")
      data.patrolPoints = {};
      local mapW, mapH = Game.mapSizeX, Game.mapSizeZ
      Log(teamID, "GeneratePatrolPoints: Map Dimensions W="..mapW..", H="..mapH) -- LOG MAP SIZE
      local startX, startY, startZ = Spring.GetTeamStartPosition(teamID)

      if not startX then
          Log(teamID, "GeneratePatrolPoints: ERROR - Cannot get team start position!")
          return
      end
      Log(teamID, "GeneratePatrolPoints: StartPos = " .. string.format("%.0f,%.0f", startX, startZ))

      local tempPoints = {}
      -- ... (logica per aggiungere punti a tempPoints) ...
      -- Assicurati che i log per ogni tipo di punto (base, enemy, resource, center) mostrino se vengono aggiunti a tempPoints
	  
	        -- === INIZIO LOGICA AGGIUNTA PER POPOLARE tempPoints ===

      -- 1. Punti attorno alla propria base per un pattugliamento iniziale/difensivo
      local basePatrolRadius = 300 -- Distanza dalla base per i punti di pattuglia
      table.insert(tempPoints, { x = startX + basePatrolRadius, z = startZ, type = "HOME_PATROL_E" })
      table.insert(tempPoints, { x = startX - basePatrolRadius, z = startZ, type = "HOME_PATROL_W" })
      table.insert(tempPoints, { x = startX, z = startZ + basePatrolRadius, type = "HOME_PATROL_S" })
      table.insert(tempPoints, { x = startX, z = startZ - basePatrolRadius, type = "HOME_PATROL_N" })
      Log(teamID, "GeneratePatrolPoints: Added 4 home patrol points around start position.")

      -- 2. Punto al centro della mappa (se la mappa non è troppo piccola)
      if mapW > 1000 and mapH > 1000 then -- Evita su mappe piccolissime
          table.insert(tempPoints, { x = mapW / 2, z = mapH / 2, type = "MAP_CENTER" })
          Log(teamID, "GeneratePatrolPoints: Added map center point.")
      end

      -- 3. Punti verso le posizioni di partenza nemiche (se esistono nemici)
      local allTeams = Spring.GetTeamList()
      local enemyTeamsFound = {} -- Tabella per conservare gli ID dei team nemici effettivi

      if allTeams then
          for _, otherTeamID in ipairs(allTeams) do
              if otherTeamID ~= teamID then -- Non considerare il proprio team
                  -- Per la v100, dobbiamo usare Spring.AreTeamsAllied
                  -- Spring.AreTeamsAllied(teamID1, teamID2) restituisce true se sono alleati, false altrimenti
                  if not Spring.AreTeamsAllied(teamID, otherTeamID) then
                      table.insert(enemyTeamsFound, otherTeamID)
                  end
              end
          end
      end

            -- All'interno di GeneratePatrolPoints, dopo aver trovato enemyTeamsFound

      if #enemyTeamsFound > 0 then
          Log(teamID, "GeneratePatrolPoints: Found " .. #enemyTeamsFound .. " enemy teams.")
          for i, enemyTeamID in ipairs(enemyTeamsFound) do
              local ex, _, ez = Spring.GetTeamStartPosition(enemyTeamID)
              if ex and ez then
                  -- 1. PUNTO A METÀ STRADA (già presente)
                  local midX = (startX + ex) / 2
                  local midZ = (startZ + ez) / 2
                  table.insert(tempPoints, { x = midX, z = midZ, type = "ENEMY_APPROACH_" .. enemyTeamID })
                  Log(teamID, "GeneratePatrolPoints: Added enemy approach point towards team " .. enemyTeamID .. " at " .. string.format("%.0f,%.0f", midX, midZ))

                  -- 2. NUOVO: PUNTO DI PATTUGLIA SUL PERIMETRO DELLA BASE NEMICA
                  -- Vogliamo un punto che sia vicino alla base nemica, ma non direttamente sopra,
                  -- e magari in una direzione "sicura" o strategica dalla nostra prospettiva.
                  -- Calcoliamo un vettore dalla nostra base a quella nemica
                  local vecToEnemyX = ex - startX
                  local vecToEnemyZ = ez - startZ
                  local distToEnemy = math.sqrt(vecToEnemyX*vecToEnemyX + vecToEnemyZ*vecToEnemyZ)

                  if distToEnemy > 0 then -- Evita divisione per zero se le basi sono sovrapposte (improbabile)
                      -- Normalizza il vettore
                      local normVecX = vecToEnemyX / distToEnemy
                      local normVecZ = vecToEnemyZ / distToEnemy

                      -- Distanza dal centro della base nemica per il punto di pattuglia perimetrale
                      local perimeterPatrolOffset = 400 -- Aggiustabile: abbastanza vicino per vedere, non troppo per morire subito
                      if perimeterPatrolOffset > distToEnemy * 0.4 then -- Non andare oltre il 40% della distanza totale
                          perimeterPatrolOffset = distToEnemy * 0.4
                      end


                      -- Calcola il punto sul perimetro: parti dalla base nemica e "torna indietro" un po' verso di noi,
                      -- oppure vai di lato. Per ora, torniamo indietro lungo la linea che ci congiunge.
                      local perimeterX = ex - normVecX * perimeterPatrolOffset
                      local perimeterZ = ez - normVecZ * perimeterPatrolOffset
                      
                      -- Potresti anche aggiungere una piccola deviazione laterale per non essere troppo prevedibile
                      -- local offsetX = normVecZ * math.random(-150, 150) -- Usa il vettore perpendicolare per lo spostamento laterale
                      -- local offsetZ = -normVecX * math.random(-150, 150)
                      -- perimeterX = perimeterX + offsetX
                      -- perimeterZ = perimeterZ + offsetZ


                      table.insert(tempPoints, { x = perimeterX, z = perimeterZ, type = "ENEMY_BASE_PERIMETER_" .. enemyTeamID })
                      Log(teamID, "GeneratePatrolPoints: Added enemy base perimeter point for team " .. enemyTeamID .. " at " .. string.format("%.0f,%.0f", perimeterX, perimeterZ))
                  end

              else
                  Log(teamID, "GeneratePatrolPoints: Could not get start position for enemy team " .. enemyTeamID)
              end

              if i >= 2 then -- Manteniamo il limite per non avere troppi punti per singolo nemico all'inizio
                  Log(teamID, "GeneratePatrolPoints: Limiting enemy-related points generation to first "..i.." enemies for now.")
                  break
              end
          end
      else
          Log(teamID, "GeneratePatrolPoints: No enemy teams found.")
      end

      -- 4. (Opzionale avanzato) Punti su metal spot importanti e non presi
      -- Questa è un po' più complessa perché richiede di controllare quali spot sono liberi
      -- e magari distanti dalla propria base. Per ora la omettiamo per semplicità.
      -- Esempio concettuale:
      -- local mexCount = Spring.GetGameRulesParam("mex_count")
      -- if mexCount and mexCount > 0 then
      --    local spotsChecked = 0
      --    for i = 1, mexCount do
      --        local spotX = Spring.GetGameRulesParam("mex_x" .. i)
      --        local spotZ = Spring.GetGameRulesParam("mex_z" .. i)
      --        if spotX and spotZ then
      --            -- Qui dovresti controllare se lo spot è libero e se è "interessante"
      --            -- (es. non troppo vicino alla tua base, non troppo vicino a uno già aggiunto)
      --            -- table.insert(tempPoints, { x = spotX, z = spotZ, type = "RESOURCE_SPOT_" .. i })
      --            -- spotsChecked = spotsChecked + 1
      --            -- if spotsChecked >= 3 then break end -- Limita il numero di spot aggiunti
      --        end
      --    end
      -- end
      -- Log(teamID, "GeneratePatrolPoints: Considered metal spots for patrol points.")

      -- === FINE LOGICA AGGIUNTA ===
	  

      Log(teamID, "GeneratePatrolPoints: BEFORE filtering - Total temp points: " .. #tempPoints)
      if #tempPoints == 0 then
          Log(teamID, "GeneratePatrolPoints: WARNING - No points added to tempPoints before filtering!")
      end

      local uniquePoints = {}
      local finalPatrolPoints = {}
      for i, p in ipairs(tempPoints) do -- Aggiunto indice 'i' per i log
          local key = string.format("%.0f,%.0f", p.x, p.z)
          Log(teamID, "GeneratePatrolPoints: Processing tempPoint "..i.." ("..p.type..") at "..key) -- LOG PROCESSING
          if not uniquePoints[key] then
             local clampedX = math.max(16, math.min(p.x, mapW - 16)) -- Aggiunto piccolo margine dai bordi
             local clampedZ = math.max(16, math.min(p.z, mapH - 16)) -- Aggiunto piccolo margine
             if clampedX ~= p.x or clampedZ ~= p.z then
                Log(teamID, "GeneratePatrolPoints: Point " .. p.type .. " ("..key..") was clamped from ("..string.format("%.0f,%.0f",p.x,p.z)..") to ("..string.format("%.0f,%.0f",clampedX,clampedZ)..")")
             end
             p.x = clampedX
             p.z = clampedZ
             p.y = Spring.GetGroundHeight(p.x,p.z)
             if p.y == nil then -- Punto fuori mappa o su acqua non navigabile?
                Log(teamID, "GeneratePatrolPoints: Point " .. p.type .. " ("..key..") has nil height after clamping, SKIPPING.")
             else
                Log(teamID, "GeneratePatrolPoints: Adding final point "..p.type.." at "..string.format("%.0f,%.0f,%.0f",p.x,p.y,p.z))
                table.insert(finalPatrolPoints, p)
                uniquePoints[key] = true
             end
          else
              Log(teamID, "GeneratePatrolPoints: Point "..p.type.." ("..key..") was duplicate, SKIPPED.")
          end
      end
      data.patrolPoints = finalPatrolPoints
      Log(teamID, "GeneratePatrolPoints: AFTER filtering - Final unique patrol points: " .. #data.patrolPoints)

      -- ... (resto della funzione con fallback e log finale) ...
      if #data.patrolPoints == 0 then
          Log(teamID, "GeneratePatrolPoints: WARNING - No valid patrol points generated after filtering!")
          -- ... (logica fallback) ...
      end
      data.nextPatrolPointIndex = 1; data.regeneratePatrolPoints = false;
      Log(teamID, "GeneratePatrolPoints: FINISHED. Final count: " .. #data.patrolPoints .. ", Next Index: " .. data.nextPatrolPointIndex)
  end


  -- Funzione per creare un nuovo gruppo di combattimento (versione con analisi capacità)
  local function CreateNewCombatGroup(teamID, data, unitIDs, frame)
      local newGroupID = data.nextGroupID
      data.nextGroupID = data.nextGroupID + 1

      local newGroup = {
          id = newGroupID,
          units = {},
          state = "idle",
          targetPoint = nil,
          currentPatrolIndex = nil,
          lastOrderFrame = frame,
          
          -- NUOVI CAMPI PER CAPACITÀ DEL GRUPPO
          groupMoveType = "UNKNOWN", -- "LAND", "AIR", "NAVAL", "MIXED"
          canAttackLand = false,
          canAttackAir = false,
          canAttackNaval = false,
          isHomogeneous = true -- Tutte le unità hanno lo stesso moveType?
      }

      local moveTypesInGroup = {}
      local firstMoveType = nil

      for _, unitIDinGroup in ipairs(unitIDs) do
          if data.combatUnits[unitIDinGroup] then
              table.insert(newGroup.units, unitIDinGroup)
              data.combatUnits[unitIDinGroup].state = "assigned_to_group"
              data.combatUnits[unitIDinGroup].groupID = newGroupID
              
              -- Analizza capacità unità
              local unitDefID = Spring.GetUnitDefID(unitIDinGroup)
              if unitDefID then
                  local uDef = UnitDefs[unitDefID]
                  if uDef then
                      -- Move Type
                      local currentUnitMoveType = uDef.movedata and uDef.movedata.moveType or "UNKNOWN"
                      if not firstMoveType then firstMoveType = currentUnitMoveType end
                      if firstMoveType ~= currentUnitMoveType then newGroup.isHomogeneous = false end
                      moveTypesInGroup[currentUnitMoveType] = true
                      
                      -- Capacità di Attacco (basato su UnitDef, non su armi specifiche per ora per semplicità)
                      -- Questo è un placeholder, l'analisi delle armi sarebbe più precisa
                      if uDef.canAttack then -- Flag generico
                          -- Se è un'unità terrestre, probabilmente può attaccare terra
                          if currentUnitMoveType == "LAND" or currentUnitMoveType == "BUILDING" then newGroup.canAttackLand = true end
                          -- Se è aerea, spesso può attaccare terra e/o aria
                          if currentUnitMoveType == "AIR" then newGroup.canAttackLand = true; newGroup.canAttackAir = true end
                          -- Se è navale, spesso può attaccare navale e/o terra (e a volte aria)
                          if currentUnitMoveType == "NAVAL" then newGroup.canAttackNaval = true; newGroup.canAttackLand = true end
                          -- Questo è MOLTO semplificato. L'analisi delle armi con ud.weapons[j].weaponDef.targetable è necessaria per precisione.
                      end
                      -- Per ora, un'euristica: se può muoversi su un terreno, può attaccare quel terreno.
                      if currentUnitMoveType == "LAND" then newGroup.canAttackLand = true end
                      if currentUnitMoveType == "AIR" then newGroup.canAttackAir = true end -- Molte unità aeree sono caccia
                      if currentUnitMoveType == "NAVAL" then newGroup.canAttackNaval = true end
                  end
              end
          else
              Log(teamID, "CreateNewCombatGroup: Warning - Unit " .. unitIDinGroup .. " not found in combatUnits while forming group " .. newGroupID)
          end
      end

      -- Determina il groupMoveType aggregato
      local numMoveTypes = 0; for _ in pairs(moveTypesInGroup) do numMoveTypes = numMoveTypes + 1 end
      if numMoveTypes == 1 then
          newGroup.groupMoveType = firstMoveType
      elseif numMoveTypes > 1 then
          newGroup.groupMoveType = "MIXED"
          newGroup.isHomogeneous = false -- Assicura sia false
      end
      -- Se non ci sono unità (improbabile se si arriva qui), rimane UNKNOWN

      if #newGroup.units > 0 then
         data.combatGroups[newGroupID] = newGroup
         Log(teamID, "Created new combat group " .. newGroupID .. " with " .. #newGroup.units .. " units. MoveType: "..newGroup.groupMoveType ..
                     " L/A/N: " ..tostring(newGroup.canAttackLand).."/"..tostring(newGroup.canAttackAir).."/"..tostring(newGroup.canAttackNaval))
      else
         Log(teamID, "CreateNewCombatGroup: Attempted to create an empty group (ID " .. newGroupID .. "), skipping.")
         data.nextGroupID = data.nextGroupID - 1
      end
  end



  -- Funzione per assegnare un compito a un gruppo (Pattugliamento con un po' più di logica)
  local function AssignTaskToGroup(teamID, data, groupID, frame)
      local groupData = data.combatGroups[groupID]
      if not groupData or #groupData.units == 0 then
          Log(teamID, "AssignTaskToGroup: Group " .. groupID .. " is empty or nil, removing.")
          data.combatGroups[groupID] = nil
          return
      end

      if #data.patrolPoints == 0 then
          Log(teamID, "Group " .. groupID .. ": No patrol points defined. Remaining idle.")
          groupData.state = "idle"
          return
      end

      local startX, _, startZ = Spring.GetTeamStartPosition(teamID)
      local patrolPointData = nil
      local assignedPatrolIndex = -1

      -- Tentativo 1: Trova un punto di pattuglia "lontano" e non attualmente bersagliato da altri gruppi attivi
      -- Ordiniamo i punti per distanza dalla base (decrescente) per favorire l'esplorazione
      local sortedPatrolPoints = {}
      for i, p in ipairs(data.patrolPoints) do
          if startX and p.x then -- Assicurati che le coordinate siano valide
            local dx, dz = p.x - startX, p.z - startZ
            table.insert(sortedPatrolPoints, { index = i, point = p, distSq = dx*dx + dz*dz })
          end
      end
      table.sort(sortedPatrolPoints, function(a,b) return a.distSq > b.distSq end) -- Più lontano prima

      local activePatrolIndices = {} -- Teniamo traccia dei punti già assegnati a gruppi attivi
      for otherGroupID, otherGroupData in pairs(data.combatGroups) do
          if otherGroupID ~= groupID and otherGroupData.currentPatrolIndex and
             (otherGroupData.state == "patrolling_area" or otherGroupData.state == "moving_to_patrol") then -- Aggiungi altri stati se necessario
              activePatrolIndices[otherGroupData.currentPatrolIndex] = true
          end
      end

      for _, sortedPInfo in ipairs(sortedPatrolPoints) do
          if not activePatrolIndices[sortedPInfo.index] then
              patrolPointData = sortedPInfo.point
              assignedPatrolIndex = sortedPInfo.index
              Log(teamID, "Group " .. groupID .. ": Assigning preferred distant/unassigned patrol point #" .. assignedPatrolIndex)
              break
          end
      end

      -- Tentativo 2: Se non abbiamo trovato un punto "preferito" (magari tutti i lontani sono occupati, o pochi punti)
      -- usiamo il vecchio sistema ciclico per assicurare che un compito venga comunque assegnato.
      if not patrolPointData then
          Log(teamID, "Group " .. groupID .. ": No preferred distant/unassigned point found, using next available.")
          local attempts = 0
          local maxAttempts = #data.patrolPoints
          local startIndex = data.nextPatrolPointIndex -- Usa l'indice successivo globale
          
          while attempts < maxAttempts do
              local currentIndex = ((startIndex -1 + attempts) % #data.patrolPoints) + 1 -- Cicla correttamente
              if not activePatrolIndices[currentIndex] or #data.patrolPoints <= 2 then -- Se ci sono pochi punti, permetti sovrapposizione
                  patrolPointData = data.patrolPoints[currentIndex]
                  assignedPatrolIndex = currentIndex
                  data.nextPatrolPointIndex = (currentIndex % #data.patrolPoints) + 1 -- Aggiorna l'indice globale per il prossimo gruppo
                  break
              end
              attempts = attempts + 1
          end
          -- Fallback definitivo se tutti i punti sono 'attivamente' pattugliati e ce ne sono molti
          if not patrolPointData then
              assignedPatrolIndex = data.nextPatrolPointIndex
              patrolPointData = data.patrolPoints[assignedPatrolIndex]
              data.nextPatrolPointIndex = (data.nextPatrolPointIndex % #data.patrolPoints) + 1
              Log(teamID, "Group " .. groupID .. ": Fallback - assigning patrol point #" .. assignedPatrolIndex .. " (next in global sequence)")
          end
      end
      
      if not patrolPointData or assignedPatrolIndex == -1 then
          -- Questo non dovrebbe succedere se #data.patrolPoints > 0, ma per sicurezza
          Log(teamID, "Group " .. groupID .. ": CRITICAL - Could not assign any patrol point. Idling.")
          groupData.state = "idle"
          return
      end

      Log(teamID, "Group " .. groupID .. " assigned to PATROL point #" .. assignedPatrolIndex .. " ("..(patrolPointData.type or "N/A")..") at " .. string.format("%.0f,%.0f", patrolPointData.x, patrolPointData.z))
      groupData.state = "patrolling_area" -- Potresti voler uno stato "moving_to_patrol" e poi cambiarlo una volta arrivati
      groupData.targetPoint = {patrolPointData.x, patrolPointData.y, patrolPointData.z}
      groupData.currentPatrolIndex = assignedPatrolIndex

      local CMD_PATROL_ID = 15 -- CMD.PATROL
      Spring.GiveOrderToUnitArray(groupData.units, CMD_PATROL_ID, groupData.targetPoint, {"SHIFT"}) -- SHIFT è importante per il comando PATROL
      
      for _, unitID in ipairs(groupData.units) do
          if data.combatUnits[unitID] then data.combatUnits[unitID].state = "patrolling" end -- Stato della singola unità
      end
      groupData.lastOrderFrame = frame
      -- Non aggiorniamo `data.nextPatrolPointIndex` qui se abbiamo scelto un punto specifico, 
      -- l'abbiamo già fatto nel blocco di fallback se necessario.
  end
  
  -- altra utility per debug unitsdef
  function PrintUnitDefViaMetaPairs(teamID, uDef, unitDefName)
    if not uDef then
        Log(teamID, "PrintUnitDefViaMetaPairs: uDef is nil for " .. unitDefName)
        return
    end
    Log(teamID, "Inspecting UnitDef fields via :pairs() for: " .. unitDefName .. " (Name in uDef: " .. tostring(uDef.name) .. ")")
    
    if uDef.pairs then -- Controlla se il metodo :pairs() esiste (dovrebbe secondo la doc)
        for keyName, keyValue in uDef:pairs() do
            -- Logghiamo solo tipi semplici per evitare di stampare tabelle intere (come 'weapons')
            if type(keyValue) == "number" or type(keyValue) == "string" or type(keyValue) == "boolean" then
                Log(teamID, "  Key: '" .. tostring(keyName) .. "', Value: [" .. tostring(keyValue) .. "], Type: " .. type(keyValue))
            elseif keyValue == nil then
                 Log(teamID, "  Key: '" .. tostring(keyName) .. "', Value: [nil], Type: nil")
            else
                Log(teamID, "  Key: '" .. tostring(keyName) .. "', Type: " .. type(keyValue) .. " (Table or Function - not printing value)")
            end
        end
    else
        Log(teamID, "PrintUnitDefViaMetaPairs: uDef.pairs method not found for " .. unitDefName .. ". Trying standard pairs.")
        -- Fallback a pairs standard, anche se potrebbe non mostrare tutto
        for keyName, keyValue in pairs(uDef) do
             if type(keyValue) == "number" or type(keyValue) == "string" or type(keyValue) == "boolean" then
                Log(teamID, "  (StdPairs) Key: '" .. tostring(keyName) .. "', Value: [" .. tostring(keyValue) .. "], Type: " .. type(keyValue))
            else
                Log(teamID, "  (StdPairs) Key: '" .. tostring(keyName) .. "', Type: " .. type(keyValue) .. " (Table or Function - not printing value)")
            end
        end
    end
    Log(teamID, "Finished inspecting UnitDef via :pairs() for " .. unitDefName)
end
  
  
--[[
-- utility per debug unitdef
function LogAllUnitDefFields(teamID, unitDefID, unitDefName)
    Log(teamID, "Inspecting ALL UnitDef fields for: " .. unitDefName .. " (ID: " .. unitDefID .. ")")
    local currentKey = nil -- Inizia con nil per ottenere la prima chiave
    local i = 0
    while true do
        currentKey = Spring.GetUnitDefNextKey(unitDefID, currentKey)
        if currentKey == nil then
            break -- Fine delle chiavi
        end
        local value = Spring.GetUnitDefValueByKey(unitDefID, currentKey)
        Log(teamID, "  Key: '" .. currentKey .. "', Value: [" .. tostring(value) .. "], Type: " .. type(value))
        i = i + 1
        if i > 200 then Log(teamID, "STOPPING KEY INSPECTION, too many keys"); break end -- Sicurezza
    end
    Log(teamID, "Finished inspecting keys.")
end
]]--


  function UpdateCombatGroupStates(teamID, frame, data)
      local groupIDsToIterate = {}; for id,_ in pairs(data.combatGroups) do table.insert(groupIDsToIterate, id) end
      
      for _, groupID in ipairs(groupIDsToIterate) do
          local groupData = data.combatGroups[groupID]
          if groupData then
              -- Rimuovi unità morte dal gruppo
              local aliveUnits = {}
              for _,unitID in ipairs(groupData.units) do
                  if Spring.ValidUnitID(unitID) and not Spring.GetUnitIsDead(unitID) then
                      table.insert(aliveUnits, unitID)
                  else
                      if data.combatUnits[unitID] then
                          data.combatUnits[unitID].groupID = nil
                          data.combatUnits[unitID].state = "idle" -- O "destroyed"
                      end
                  end
              end
              groupData.units = aliveUnits

              if #groupData.units == 0 then
                  Log(teamID, "Group " .. groupID .. " empty (all units destroyed or removed), removing group.")
                  data.combatGroups[groupID] = nil
                  -- continue -- Usa 'goto continue_loop' se preferisci, o semplicemente struttura con if/else
              else
                  -- === INIZIO NUOVA LOGICA DI REATTIVITÀ ===
                  local groupEngagedEnemy = false
                  if groupData.state == "patrolling_area" or groupData.state == "moving_to_patrol" then
                      local groupCenterX, groupCenterY, groupCenterZ = 0, 0, 0
                      local validUnitCount = 0
                      for _, unitID in ipairs(groupData.units) do
                          local ux, uy, uz = Spring.GetUnitPosition(unitID)
                          if ux then
                              groupCenterX = groupCenterX + ux
                              groupCenterY = groupCenterY + uy
                              groupCenterZ = groupCenterZ + uz
                              validUnitCount = validUnitCount + 1
                          end
                      end

                      if validUnitCount > 0 then
                          groupCenterX = groupCenterX / validUnitCount
                          groupCenterY = groupCenterY / validUnitCount
                          groupCenterZ = groupCenterZ / validUnitCount

                          -- Raggio di rilevamento nemici per il gruppo (aggiustabile)
                          local detectionRadius = 400 -- Aumenta se le tue unità hanno molta portata o velocità
							local allUnitsNearby = Spring.GetUnitsInSphere(groupCenterX, groupCenterY, groupCenterZ, detectionRadius)
							local enemiesNearby = {}
if allUnitsNearby then
    for _, unitIDinSphere in ipairs(allUnitsNearby) do
        local unitActualTeam = Spring.GetUnitTeam(unitIDinSphere)
        if unitActualTeam ~= teamID then -- Assicurati che non sia una mia unità
            if not Spring.AreTeamsAllied(teamID, unitActualTeam) then
                -- Se non sono alleati, è un nemico (o neutrale ostile)
                table.insert(enemiesNearby, unitIDinSphere)
            end
        end
    end
end


                          if enemiesNearby and #enemiesNearby > 0 then
                              Log(teamID, "Group " .. groupID .. " detected " .. #enemiesNearby .. " enemies nearby while patrolling! Engaging.")
                              groupData.state = "engaging_enemy"
                              groupData.lastEngageOrderFrame = frame -- Per evitare spam di ordini
                              -- Dai un ordine di attacco generico all'area o alla prima unità nemica
                              -- CMD.ATTACK è 10. Potrebbe essere più efficace dare un ordine di ATTACK_MOVE (CMD.MOVE con opzione ATTACK)
                              -- o attaccare specificamente la prima unità nemica.
                              -- Per semplicità, un ATTACK verso la posizione del primo nemico:
                              local firstEnemyID = enemiesNearby[1]
                              local ex, ey, ez = Spring.GetUnitPosition(firstEnemyID)
                              if ex then
                                  Spring.GiveOrderToUnitArray(groupData.units, 10, {ex,ey,ez}, {"SHIFT"}) -- CMD.ATTACK
                                  -- Aggiorna stato singole unità se vuoi
                                  for _, uID in ipairs(groupData.units) do if data.combatUnits[uID] then data.combatUnits[uID].state = "attacking" end end
                              end
                              groupEngagedEnemy = true
                          end
                      end
                  end
                  -- === FINE NUOVA LOGICA DI REATTIVITÀ ===

                  -- Se il gruppo non ha ingaggiato un nemico, procedi con la logica di completamento pattuglia
                  if not groupEngagedEnemy then
                      if groupData.state == "patrolling_area" then
                          local allIdleNearTarget = true
                          if not groupData.targetPoint then
                              allIdleNearTarget = false
                          else
                              local groupX, groupZ, unitCountInGroup = 0,0,0
                              local allCommandsDoneForGroup = true
                              for _,unitID in ipairs(groupData.units) do
                                  local ux,_,uz = Spring.GetUnitPosition(unitID)
                                  if ux then groupX = groupX+ux; groupZ = groupZ+uz; unitCountInGroup = unitCountInGroup+1 end
                                  local cmds = Spring.GetUnitCommands(unitID)
                                  -- Un gruppo in pattuglia (CMD.PATROL) ha sempre almeno 1 comando finché non viene interrotto
                                  -- Dobbiamo considerare se sono "vicini" al targetPoint e non hanno ordini *diversi* da CMD.PATROL
                                  if cmds and #cmds > 0 and cmds[1].id ~= 15 then -- Se ha un comando diverso da PATROL
                                     allCommandsDoneForGroup = false -- Non è "idle" nel senso di aver finito la pattuglia
                                  end
                                  -- Se vuoi un controllo più stretto sulla fine della pattuglia:
                                  -- if cmds and #cmds > 0 then allCommandsDoneForGroup = false; break end
                              end

                              if unitCountInGroup > 0 and allCommandsDoneForGroup then
                                  groupX = groupX / unitCountInGroup
                                  groupZ = groupZ / unitCountInGroup
                                  local dx = groupX - groupData.targetPoint[1]
                                  local dz = groupZ - groupData.targetPoint[3]
                                  local arrivalDistanceSq = 200*200 -- Raggio entro cui consideriamo arrivati (aggiustabile)
                                  if (dx*dx + dz*dz) > arrivalDistanceSq then
                                      allIdleNearTarget = false
                                  end
                              elseif unitCountInGroup == 0 or not allCommandsDoneForGroup then
                                  allIdleNearTarget = false
                              end
                          end

                          if allIdleNearTarget then
                              Log(teamID, "Group " .. groupID .. " completed patrol at point #" .. tostring(groupData.currentPatrolIndex) .. " or is sufficiently idle near target.")
                              groupData.state = "patrol_complete"
                              groupData.targetPoint = nil
                              groupData.currentPatrolIndex = nil
                              -- Potrebbe essere utile cancellare gli ordini esistenti per assicurarsi che siano pronti per un nuovo task
                              Spring.GiveOrderToUnitArray(groupData.units, CMD.STOP, {}, {})
                          end
                      elseif groupData.state == "engaging_enemy" then
                          -- Logica per quando un gruppo è in combattimento
                          -- Controlla se ci sono ancora nemici vicini. Se no, torna a "idle" o "patrol_complete"
                          -- Questo previene che rimangano bloccati in "engaging_enemy"
                          if frame - (groupData.lastEngageOrderFrame or 0) > 90 then -- Controlla ogni tot frame
                              local groupCenterX, groupCenterY, groupCenterZ, validUnitCount = 0,0,0,0
                              for _, unitID in ipairs(groupData.units) do
                                  local ux, uy, uz = Spring.GetUnitPosition(unitID)
                                  if ux then groupCenterX=groupCenterX+ux; groupCenterY=groupCenterY+uy; groupCenterZ=groupCenterZ+uz; validUnitCount=validUnitCount+1 end
                              end
                              if validUnitCount > 0 then
                                  groupCenterX = groupCenterX / validUnitCount; groupCenterY = groupCenterY / validUnitCount; groupCenterZ = groupCenterZ / validUnitCount;

								local allUnitsInEngageArea = Spring.GetUnitsInSphere(groupCenterX, groupCenterY, groupCenterZ, 450) -- Raggio leggermente più grande
								local enemiesNearby = {} -- Riusiamo la variabile enemiesNearby, o usane una nuova se preferisci
if allUnitsInEngageArea then
    for _, unitIDinSphere in ipairs(allUnitsInEngageArea) do
        local unitActualTeam = Spring.GetUnitTeam(unitIDinSphere)
        if unitActualTeam ~= teamID then -- Assicurati che non sia una mia unità
            if not Spring.AreTeamsAllied(teamID, unitActualTeam) then
                -- Se non sono alleati, è un nemico
                table.insert(enemiesNearby, unitIDinSphere)
            end
        end
    end
end


                                  if not enemiesNearby or #enemiesNearby == 0 then
                                      Log(teamID, "Group " .. groupID .. " no longer finds enemies in engagement area. Setting to patrol_complete.")
                                      groupData.state = "patrol_complete"
                                      Spring.GiveOrderToUnitArray(groupData.units, CMD.STOP, {}, {}) -- Ferma le unità
                                      -- Potrebbe essere utile inviarli a un punto di regroup vicino prima di assegnare un nuovo task
                                  else
                                      groupData.lastEngageOrderFrame = frame -- Resetta il timer se vede ancora nemici
                                  end
                              else -- Il gruppo è stato distrutto mentre era in engaging
                                  Log(teamID, "Group " .. groupID .. " seems to have no units left while engaging. Will be removed if truly empty.")
                              end
                          end
                      end
                  end -- fine 'if not groupEngagedEnemy'
              end -- fine 'if #groupData.units == 0 else'
          end -- fine 'if groupData'
          -- :continue_loop -- Se usi goto
      end -- fine ciclo for groupID
  end

  -- Placeholder per Funzioni Hotspot (da implementare in futuro)
  function UpdateHotspots(teamID, frame, data) end
  function DecayOldHotspots(teamID, frame, data) end
  function FindBestHotspotToAttack(teamID, data, groupData) return nil end
 
 
 
 
   -- Funzione per creare un nuovo gruppo di combattimento
  local function CreateNewCombatGroup(teamID, data, unitIDs, frame)
      local newGroupID = data.nextGroupID
      data.nextGroupID = data.nextGroupID + 1

      local newGroup = {
          id = newGroupID, -- ID del gruppo
          units = {},      -- Tabella per gli ID delle unità nel gruppo
          state = "idle",  -- Stato iniziale del gruppo (verrà cambiato da AssignTaskToGroup)
          targetPoint = nil, -- Coordinate {x,y,z} del target di movimento/pattuglia
          currentPatrolIndex = nil, -- Indice del punto di pattuglia attuale (se in pattuglia)
          lastOrderFrame = frame -- Frame dell'ultimo ordine dato a questo gruppo
          -- Aggiungi altri campi se necessario (es. targetUnitID, currentHotspotID)
      }

      for _, unitIDinGroup in ipairs(unitIDs) do
          if data.combatUnits[unitIDinGroup] then -- Assicura che l'unità esista ancora e sia una unità da combattimento
              table.insert(newGroup.units, unitIDinGroup)
              data.combatUnits[unitIDinGroup].state = "assigned_to_group" -- Aggiorna lo stato della singola unità
              data.combatUnits[unitIDinGroup].groupID = newGroupID        -- Assegna l'ID del gruppo all'unità
          else
              Log(teamID, "CreateNewCombatGroup: Warning - Unit " .. unitIDinGroup .. " not found in combatUnits while forming group " .. newGroupID)
          end
      end

      -- Aggiungi il gruppo solo se contiene effettivamente unità
      if #newGroup.units > 0 then
         data.combatGroups[newGroupID] = newGroup
         Log(teamID, "Created new combat group " .. newGroupID .. " with " .. #newGroup.units .. " units.")
      else
         Log(teamID, "CreateNewCombatGroup: Attempted to create an empty group (ID " .. newGroupID .. "), skipping.")
         data.nextGroupID = data.nextGroupID - 1 -- Rilascia l'ID del gruppo se non è stato usato
      end
  end
 
 
   -- === NUOVA FUNZIONE PER GESTIRE HOTSPOT ===
  -- Deve essere definita prima di essere usata da eventuali funzioni di rilevamento
  
  -- Funzione per creare o aggiornare un hotspot
  -- hx, hy, hz: coordinate dell'evento/nemico
  -- htype: stringa, es. "ENEMY_UNIT_SIGHTING", "ENEMY_BUILDING_UNDER_CONSTRUCTION", "AREA_UNDER_ATTACK"
  -- hstrength: numerico, quanto è "forte" questo avvistamento (es. numero di unità, o un valore fisso)
  -- hradius: numerico, raggio d'influenza dell'hotspot
  -- hCreatorUnitID: (opzionale) ID dell'unità AI che ha fatto l'avvistamento
  -- hEnemyUnitDefID: (opzionale) UnitDefID del nemico avvistato, per determinare il tipo
  -- Firma modificata
local function CreateOrUpdateHotspot(teamID, data, frameValue, hx, hy, hz, htype, hstrength, hradius, hCreatorUnitID, hEnemyUnitDefID)
    -- Rimuovi: local frame = Game.frame
    -- Log(teamID, "DEBUG CreateOrUpdateHotspot: Game.frame is " .. tostring(Game.frame) .. ", local frame value is " .. tostring(frame)) -- Questo log non serve più se frameValue è passato

    Log(teamID, "DEBUG CreateOrUpdateHotspot: Received frameValue: " .. tostring(frameValue)) -- NUOVO LOG per verificare

    if not hx or not hstrength or hstrength <= 0 then
        Log(teamID, "CreateOrUpdateHotspot: Invalid parameters (coords or strength missing/zero).")
        return nil
    end
    if frameValue == nil then -- Controllo aggiuntivo
        Log(teamID, "CreateOrUpdateHotspot: CRITICAL - frameValue is nil!")
        return nil
    end

    hradius = hradius or 350 
    local mergeDistanceSq = (hradius * 0.75) * (hradius * 0.75)

    local existingHotspotID = nil
      for id, spot in pairs(data.hotspots) do
          local dx, dz = spot.x - hx, spot.z - hz
          if (dx*dx + dz*dz) < mergeDistanceSq then
              -- Trovato un hotspot esistente abbastanza vicino, lo aggiorniamo
              existingHotspotID = id
              break
          end
      end

      local enemyMoveType = nil
      local canAttackLand, canAttackAir, canAttackNaval = false, false, false -- Capacità del *nemico*

      if hEnemyUnitDefID and UnitDefs[hEnemyUnitDefID] then
--          local enemyDef = UnitDefs[hEnemyUnitDefID]
-----------------------------
local enemyDef = UnitDefs[hEnemyUnitDefID]
enemyMoveType = "UNKNOWN" -- Default
--------------
if enemyDef then
        Log(teamID, "DEBUG CreateHotspot: For enemy " .. enemyDef.name)
        Log(teamID, "DEBUG CreateHotspot: Inspecting enemyDef.movementclass. Value: [" .. tostring(enemyDef.movementclass) .. "], Type: " .. type(enemyDef.movementclass) ) -- <<< NUOVO LOG DI ISPEZIONE

        if enemyDef.movedata and enemyDef.movedata.moveType then
            enemyMoveType = enemyDef.movedata.moveType
		-----------------------------
        Log(teamID, "DEBUG CreateHotspot: Found moveType in movedata: " .. enemyMoveType)
        elseif enemyDef.movementclass and type(enemyDef.movementclass) == "string" then -- Aggiunto controllo che sia una stringa
            Log(teamID, "DEBUG CreateHotspot: No movedata, trying movementclass: " .. enemyDef.movementclass)
            local mc = enemyDef.movementclass:lower() 
        if mc == "kbot2" or mc == "kbot" or mc == "tank" or mc == "ground" then -- Aggiungi altri movementclass terrestri
            enemyMoveType = "LAND"
        elseif mc == "hover" then -- Esempio per hover
            enemyMoveType = "LAND" -- O potresti trattarlo diversamente
        elseif mc == "ship" or mc == "boat" then
            enemyMoveType = "NAVAL"
        elseif mc == "airplane" or mc == "gunship" or mc == "vtol" then --VTOL potrebbe essere ambiguo
            enemyMoveType = "AIR"
        end
        Log(teamID, "DEBUG CreateHotspot: Mapped movementclass to moveType: " .. enemyMoveType)
    else
                    Log(teamID, "DEBUG CreateHotspot: No movedata or valid movementclass string found for enemy " .. enemyDef.name)
		
    end
--end

		  ----------------- INIZIO DEBUG
		  if enemyDef then
    Log(teamID, "DEBUG CreateHotspot: For enemy " .. enemyDef.name .. ", enemyDef.movedata is: " .. tostring(enemyDef.movedata))
    if enemyDef.movedata then
        Log(teamID, "DEBUG CreateHotspot: enemyDef.movedata.moveType is: " .. tostring(enemyDef.movedata.moveType))
    end
	end -- aggiunto
end
------------------------- FINE DEBUG
          enemyMoveType = enemyDef.movedata and enemyDef.movedata.moveType or "UNKNOWN"
		  Log(teamID, "DEBUG CreateHotspot: Enemy " .. enemyDef.name .. " has moveType: " .. enemyMoveType) -- NUOVO LOG
          -- Determina cosa può attaccare il nemico (per ora semplificato, non guardiamo le armi)
          -- Questo è più per sapere CHE TIPO di nemico è, non cosa può fare
if enemyMoveType == "LAND" then canAttackLand = true
elseif enemyMoveType == "AIR" then canAttackAir = true
elseif enemyMoveType == "NAVAL" then canAttackNaval = true
end
      end


    if existingHotspotID then
        local spot = data.hotspots[existingHotspotID]
        spot.lastSeenFrame = frameValue -- Usa frameValue
        spot.strength = math.max(spot.strength, hstrength) 
        spot.x = (spot.x * spot.strength + hx * hstrength) / (spot.strength + hstrength)
        spot.y = (spot.y * spot.strength + hy * hstrength) / (spot.strength + hstrength)
        spot.z = (spot.z * spot.strength + hz * hstrength) / (spot.strength + hstrength)
        if hCreatorUnitID then spot.lastCreatorUnitID = hCreatorUnitID end

          -- Aggiorna i tipi di nemici presenti
          if canAttackLand then spot.hasLandEnemies = true end
          if canAttackAir then spot.hasAirEnemies = true end
          if canAttackNaval then spot.hasNavalEnemies = true end
          if enemyMoveType then -- Aggiorna il tipo dominante se necessario
              if not spot.dominantEnemyMoveType or spot.dominantEnemyMoveType ~= enemyMoveType then
                  if spot.hasLandEnemies and (spot.hasAirEnemies or spot.hasNavalEnemies) then spot.dominantEnemyMoveType = "MIXED"
                  elseif (spot.hasLandEnemies or spot.hasAirEnemies) and spot.hasNavalEnemies then spot.dominantEnemyMoveType = "MIXED"
                  else spot.dominantEnemyMoveType = enemyMoveType end
              end
          end
		  
		  ----------------------
       Log(teamID, "Updated existing hotspot " .. existingHotspotID .. " at ~" .. string.format("%.0f,%.0f", spot.x, spot.z) .. " (Str: " .. spot.strength .. ") LastSeen: " .. spot.lastSeenFrame)
        return existingHotspotID
    else
        local newID = data.nextHotspotID
        data.nextHotspotID = data.nextHotspotID + 1
        
        local newSpot = {
            id = newID,
            x = hx, y = hy, z = hz,
            type = htype or "ENEMY_CONTACT",
            strength = hstrength,
            radius = hradius,
            lastSeenFrame = frameValue, -- Usa frameValue
            creationFrame = frameValue, -- Usa frameValue
            creatorUnitID = hCreatorUnitID,      
              hasLandEnemies = canAttackLand,
              hasAirEnemies = canAttackAir,
              hasNavalEnemies = canAttackNaval,
              dominantEnemyMoveType = enemyMoveType or "UNKNOWN"
          }
          if newSpot.hasLandEnemies and (newSpot.hasAirEnemies or newSpot.hasNavalEnemies) then newSpot.dominantEnemyMoveType = "MIXED"
          elseif (newSpot.hasLandEnemies or newSpot.hasAirEnemies) and newSpot.hasNavalEnemies then newSpot.dominantEnemyMoveType = "MIXED"
          end
---------------------------
        data.hotspots[newID] = newSpot
        Log(teamID, "Created new hotspot " .. newID .. " type '"..newSpot.type.."' at " .. string.format("%.0f,%.0f", hx, hz) .. " (Str: " .. hstrength .. ", EnemyMoveType: "..(newSpot.dominantEnemyMoveType or "N/A")..") LastSeen: " .. newSpot.lastSeenFrame .. " Created: " .. newSpot.creationFrame)
        return newID
    end
end
 
   -- Funzione per far decadere e rimuovere vecchi hotspot
  local function DecayHotspots(teamID, data, frame)
      local decayTime = Game.gameSpeed * 45 -- Es. 45 secondi a velocità normale (gameSpeed è solitamente 30)
                                          -- Aggiusta questo valore!
      local removedCount = 0
      local idsToRemove = {} -- Raccogli gli ID da rimuovere per evitare problemi di modifica tabella durante l'iterazione

      for id, spot in pairs(data.hotspots) do
	   -- === NUOVO BLOCCO DEBUG ===
          if spot == nil then
              Log(teamID, "DEBUG: DecayHotspots - Found a nil spot with id: " .. tostring(id) .. " - SKIPPING")
          elseif type(spot) ~= "table" then
              Log(teamID, "DEBUG: DecayHotspots - Spot with id: " .. tostring(id) .. " is not a table, it is a " .. type(spot) .. " - SKIPPING")
          elseif spot.lastSeenFrame == nil then
              Log(teamID, "DEBUG: DecayHotspots - Spot id: " .. tostring(id) .. " has spot.lastSeenFrame == nil. Spot data: ")
              -- Logga i campi dell'hotspot per capire cosa potrebbe essere successo
              for k, v in pairs(spot) do
                  Log(teamID, "    " .. tostring(k) .. " = " .. tostring(v))
              end
              -- Non aggiungere a idsToRemove qui, altrimenti non vediamo se altri hotspot hanno lo stesso problema
          elseif type(spot.lastSeenFrame) ~= "number" then
               Log(teamID, "DEBUG: DecayHotspots - Spot id: " .. tostring(id) .. " has spot.lastSeenFrame of type " .. type(spot.lastSeenFrame) .. " instead of number. Value: " .. tostring(spot.lastSeenFrame))
          else
          -- === FINE NUOVO BLOCCO DEBUG ===
	  
          if frame - spot.lastSeenFrame > decayTime then
              table.insert(idsToRemove, id)
              removedCount = removedCount + 1
          end
		  end -- Fine del blocco else del debug
      end

      if removedCount > 0 then
          for _, idToRemove in ipairs(idsToRemove) do
              data.hotspots[idToRemove] = nil
          end
          Log(teamID, "DecayHotspots: Removed " .. removedCount .. " old hotspot(s).")
      end
  end
 
 
   -- === NUOVA FUNZIONE PER RILEVARE NEMICI E CREARE HOTSPOT ===
  -- Verrà chiamata periodicamente
     local function UpdateEnemyDetectionsAndHotspots(teamID, data, frame) -- 'frame' è già qui
      local unitsScannedThisFrame = 0
      local hotspotsCreatedOrUpdatedThisFrame = 0

      local combatUnitCount = 0
      for _ in pairs(data.combatUnits) 
	  do 
	  combatUnitCount = combatUnitCount + 1
	  Log(teamID, "DEBUG: UEDAH - Combat units count: " .. combatUnitCount)
	  break 
	  end
      if combatUnitCount == 0 then return end

      for unitID, unitData in pairs(data.combatUnits) do
          if Spring.ValidUnitID(unitID) and not Spring.GetUnitIsDead(unitID) then
		  Log(teamID, "DEBUG: UEDAH - Attempting to scan from unit " .. unitID) -- Esempio di log nel posto giusto
              local uDefID = Spring.GetUnitDefID(unitID)
              local uDef = UnitDefs[uDefID]

              if uDef then -- Solo se uDef è valido
			  
			  ---------------------------------- inizio per debug
			  if not data.debug_uDefLogged_icupatroller then -- Rinominato per chiarezza
    if uDef.name == "icupatroller" then -- Assicurati che "icupatroller" sia il case-sensitive name corretto dell'unità
        Log(teamID, "DEBUG: UnitDef fields for " .. uDef.name .. ":")
--		LogAllUnitDefFields(teamID, uDefID, uDef.name) ----- debug
		data.debug_uDefLogged_icupatroller_deep = true --- debugg
        for k,v in pairs(uDef) do
            if type(v) == "number" or type(v) == "string" or type(v) == "boolean" then
                Log(teamID, "  " .. tostring(k) .. " = " .. tostring(v))
            end
        end
        data.debug_uDefLogged_icupatroller = true -- Usa un nome specifico per l'unità
    end
end
----------------------- fine per debug
			  
			  
			  Log(teamID, "DEBUG: UEDAH - Unit " .. unitID .. " Def: " .. uDef.name .. " LOS: " .. tostring(uDef.losRadius))
                  local ux, uy, uz = Spring.GetUnitPosition(unitID)
                  if ux then -- Solo se l'unità ha una posizione
						
                --      local scanRadius = uDef.losRadius or 450
				--	 local scanRadius = uDef.sightDistance or 450 -- NUOVA RIGA, PROVA QUESTA 
				
				local scanRadius = uDef.sightdistance or 450 -- <<< USA QUESTA (tutto minuscolo)
					  if scanRadius <= 0 then scanRadius = 450 end
				
                      
--						Log(teamID, "DEBUG: UEDAH - Unit " .. unitID .. " Pos: " .. ux .. "," .. uy .. "," .. uz .. " ScanRadius: " .. scanRadius)
						Log(teamID, "DEBUG: UEDAH - Unit " .. unitID .. " (" .. uDef.name .. ") uDef.sightdistance: " .. tostring(uDef.sightdistance) .. ", Actual ScanRadius: " .. scanRadius)
                      local allUnitsNearby = Spring.GetUnitsInSphere(ux, uy, uz, scanRadius)
                      local enemiesFoundInScan = {}
                      if allUnitsNearby then
					  Log(teamID, "DEBUG: UEDAH - Unit " .. unitID .. " found " .. #allUnitsNearby .. " total units in sphere.")
                          for _, otherUnitID in ipairs(allUnitsNearby) do
                              local otherUnitTeam = Spring.GetUnitTeam(otherUnitID)
                              if otherUnitTeam ~= teamID and not Spring.AreTeamsAllied(teamID, otherUnitTeam) then
                                  table.insert(enemiesFoundInScan, otherUnitID)
                              end
                          end
					else
					Log(teamID, "DEBUG: UEDAH - Unit " .. unitID .. " GetUnitsInSphere returned nil.")
                      end

                      if #enemiesFoundInScan > 0 then
					  Log(teamID, "DEBUG: UEDAH - Unit " .. unitID .. " filtered " .. #enemiesFoundInScan .. " enemy units.")
                          local firstEnemyID = enemiesFoundInScan[1]
                          local ex, ey, ez = Spring.GetUnitPosition(firstEnemyID)
                          local enemyDefID = Spring.GetUnitDefID(firstEnemyID)
-------------------------
    if ex then 
        local hotspotType = "ENEMY_UNIT_SIGHTING"
        local hotspotStrength = #enemiesFoundInScan 
        local hotspotRadius = 250 + (#enemiesFoundInScan * 10)
                                
        -- Chiamata modificata
        local createdHotspotID = CreateOrUpdateHotspot(teamID, data, frame, -- Passa frame qui
                                                      ex, ey, ez,
                                                      hotspotType, hotspotStrength, hotspotRadius,
                                                      unitID, enemyDefID)
        if createdHotspotID then
            hotspotsCreatedOrUpdatedThisFrame = hotspotsCreatedOrUpdatedThisFrame + 1
        end
    end
                      end
                      unitsScannedThisFrame = unitsScannedThisFrame + 1
                      if unitsScannedThisFrame >= 15 and frame % 3 ~= 0 then
                          -- Log(teamID,"UpdateEnemyDetections: Scan limit per frame reached ("..unitsScannedThisFrame..")")
                          -- break -- Attenzione: 'break' qui uscirebbe dal ciclo 'for unitID, unitData...'
                                  -- Se vuoi solo limitare, dovrai gestirlo diversamente o accettare che lo scan
                                  -- possa essere più lungo in alcuni frame.
                                  -- Per ora, commentiamo il break per evitare confusione finché non decidiamo una strategia di limitazione migliore.
                      end
                  end -- if ux then
              end -- if uDef then
          end -- if Spring.ValidUnitID...
      end -- fine for unitID, unitData

      if hotspotsCreatedOrUpdatedThisFrame > 0 then
         Log(teamID, "UpdateEnemyDetections: Created/Updated " .. hotspotsCreatedOrUpdatedThisFrame .. " hotspot(s) this frame. Scanned " .. unitsScannedThisFrame .. " units.")
      end
  end
 
 
 
 
 
 
local function ManageMilitary(teamID, frame)
      local data = teamData[teamID]
      if not data or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config then return end -- Modificato per controllare solo config, non config.attackGroup


      -- 0. Fai decadere vecchi hotspot (se non lo fai già in GameFrame)
      -- DecayHotspots(teamID, data, frame) -- Se lo chiami qui invece che in GameFrame

      -- 1. Rileva nemici e aggiorna/crea hotspot
      if frame % 31 == (teamID * 2) % 31 then -- Chiama non troppo frequentemente, es. ogni secondo
		  Log(teamID, "DEBUG: Calling UpdateEnemyDetectionsAndHotspots")
          UpdateEnemyDetectionsAndHotspots(teamID, data, frame)
		  
      end


      -- A. Aggiorna stato gruppi
      UpdateCombatGroupStates(teamID, frame, data)
      -- UpdateHotspots(teamID, frame, data) -- Ancora non usato
      -- DecayOldHotspots(teamID, frame, data) -- Ancora non usato

      -- B. Forma nuovi gruppi con unità idle
      local allowedMoveTypes = {}
      if currentMapCategory == "LAND" then allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true }
      elseif currentMapCategory == "NAVAL_ISLANDS" then allowedMoveTypes = { NAVAL = true, AIR = true }
      elseif currentMapCategory == "SPACE" then allowedMoveTypes = { AIR = true, SPACE = true }
      elseif currentMapCategory == "NAVAL_PURE" then allowedMoveTypes = { NAVAL = true }
      end

      local idleUnitsForNewGroup = {}
      local currentIdleCount = 0
      for unitID, unitData in pairs(data.combatUnits) do
          if Spring.ValidUnitID(unitID) and not unitData.groupID and unitData.state == "idle" and allowedMoveTypes[unitData.moveType] then
              local cmds = Spring.GetUnitCommands(unitID)
              if not cmds or #cmds == 0 then
                  table.insert(idleUnitsForNewGroup, unitID)
                  currentIdleCount = currentIdleCount + 1
              end
          end
      end

      if currentIdleCount >= config.attackGroup.min then
          Log(teamID,"ManageMilitary: Have "..currentIdleCount.." idle units. Min for group is "..config.attackGroup.min..". Forming new group.")
          local groupSize = math.min(currentIdleCount, config.attackGroup.max)
          local newGroupUnits = {}
          for i = 1, groupSize do
              table.insert(newGroupUnits, table.remove(idleUnitsForNewGroup, 1))
          end
          CreateNewCombatGroup(teamID, data, newGroupUnits, frame)
          -- return -- Rimosso per permettere l'assegnazione compito nello stesso frame
      end

      -- C. Assegna compiti ai gruppi IDLE o che hanno finito il compito precedente
      for groupID, groupData in pairs(data.combatGroups) do
          if groupData.state == "idle" or groupData.state == "patrol_complete" then
              Log(teamID, "ManageMilitary: Group " .. groupID .. " is "..groupData.state..". Assigning new task.")
              AssignTaskToGroup(teamID, data, groupID, frame)
              -- Se vuoi processare un solo gruppo per ciclo, aggiungi un break o un return qui
              -- if groupData.state ~= "idle" and groupData.state ~= "patrol_complete" then break end
          end
      end
  end
  
  
  
 
 
 
 

  -- Helper: Trova costruttore idle di tier minimo
  function FindIdleConstructorForTeam(teamData, minTier)
      minTier = minTier or 0
      local foundBuilderID = nil
      for builderID, builderData in pairs(teamData.constructors) do
          if Spring.ValidUnitID(builderID) and builderData.tier >= minTier then
              local commands = Spring.GetUnitCommands(builderID)
              if (not commands or #commands == 0) then
                  foundBuilderID = builderID
                  break
              end
          end
      end
      return foundBuilderID
  end

  -- Helper: Controlla se servono costruttori T[N]
  function TeamNeedsConstructor(teamData, tier)
      local count = 0
      for unitID, builderData in pairs(teamData.constructors) do
          if Spring.ValidUnitID(unitID) and builderData.tier == tier then
              count = count + 1
          end
      end
      local limit = (tier == 0) and 1 or 2
      return count < limit
  end

  -- Helper: Controlla se l'AI può permettersi un'unità (v8 - Bypass T1 Eco Deficit a T0)
  function CanAffordUnit(teamData, unitDefID, frame)
      if not unitDefID then return false end
      local uDef = UnitDefs[unitDefID]
      if not uDef then return false end

      local costMetal = uDef.metalCost or 0
      local costEnergy = uDef.energyCost or 0
      local maintenanceEnergy = uDef.energyUpkeep or 0 -- == energyUse per molti edifici
      local makesEnergy = uDef.energyMake or 0

      local res = teamData.resourceInfo

      if type(res.metal) ~= "number" or type(res.energy) ~= "number" then return false end

      local buffer = 50
      local hasStorage = (res.metal >= costMetal + buffer and
                          res.energy >= costEnergy + buffer)

      if not hasStorage then
          -- Log(teamData.teamID,"Cannot afford "..uDef.humanName..": Storage Low")
          return false
      end

      -- === Bypass per T1 Eco a Tech Level 0 ===
      local isT1EcoBuilding = false
      local t1ExtractorData = GetUnitDataByRole(teamData.faction, 1, "T1_Extractor")
      local t1PowerData = GetUnitDataByRole(teamData.faction, 1, "T1_PowerPlant")
      if (t1ExtractorData and unitDefID == t1ExtractorData.id) or (t1PowerData and unitDefID == t1PowerData.id) then
          isT1EcoBuilding = true
      end

      if teamData.techLevel == 0 and isT1EcoBuilding then
          -- Log(teamData.teamID,"CanAffordUnit: Allowing T1 Eco building at T0 based on storage only.")
          return true -- Permetti costruzione T1 Eco a T0 se c'è storage
      end
      -- ========================================

      -- Per T1+ O unità non-T1-Eco, applica controllo bilancio energetico
      if teamData.techLevel >= 1 or not isT1EcoBuilding then
          local currentEnergyIncome = res.energyIncome or 0
          local currentEnergyUsage = res.energyUsage or 0
          local futureEnergyBalance = currentEnergyIncome - currentEnergyUsage - maintenanceEnergy

          if futureEnergyBalance < 0 then
              if makesEnergy > 0 then -- Ok per centrali
              else
                  local isSurplusNow = currentEnergyIncome > currentEnergyUsage
                  -- Riduciamo la soglia storage richiesta per procedere in deficit
                  local hasEnoughStorageForDeficit = res.energy > costEnergy * 1.5 -- Usa 1.5x invece di 5x

                  if not (isSurplusNow or hasEnoughStorageForDeficit) then
                     -- Log(teamData.teamID,"Cannot afford "..uDef.humanName..": Would cause UNMANAGEABLE energy deficit")
                     return false
                  -- else
                     -- Log(teamData.teamID,"Warning: Building "..uDef.humanName.." might cause manageable energy deficit, proceeding")
                  end
              end
          end
      end

      return true
  end

  --------------------------------------------------------------------------------
  -- GADGET EVENT HANDLERS (SYNCED)
  --------------------------------------------------------------------------------

  function gadget:Initialize()
      Log(nil, gadget:GetInfo().name .. " Initializing...")
      for faction, data in pairs(factionUnits) do
          if faction ~= "common" and faction ~= "_commonUnitDefIDs" and faction ~= "_unitDefIDs" then
              Log(nil, "Populating UnitDefIDs for faction: " .. faction)
              factionUnits[faction]._unitDefIDs = {}
              PopulateUnitDefIDs(data, factionUnits[faction]._unitDefIDs)
          end
      end
      Log(nil, "UnitDefID population complete.")
  end

  function gadget:GameStart()
      Log(nil, gadget:GetInfo().name .. " Game Starting...")
      local mapNameRaw = Game.mapName
      local mapNameLower = mapNameRaw:lower()
      Log(nil, "Detected Map: '" .. mapNameRaw .. "' (Checking as: '" .. mapNameLower .. "')")
      if mapCategories[mapNameLower] then
          currentMapCategory = mapCategories[mapNameLower]
          Log(nil, "Map Category Assigned: '" .. currentMapCategory .. "' (Found in mapCategories table)")
      else
          Log(nil, "Map Category Assigned: '" .. currentMapCategory .. "' (Map not found in list, using default)")
      end
      local teams = Spring.GetTeamList()
      for _, teamID in ipairs(teams) do
          if Spring.GetTeamLuaAI(teamID) == gadget:GetInfo().name then
              Log(teamID, "Team detected for AI control.")
              local startX, startY, startZ = Spring.GetTeamStartPosition(teamID)
              teamData[teamID] = {
			      debug_uDefLogged_icupatroller_deep = false,  ---------- per debug
			      debug_uDefLogged_icupatroller = false,  ---------------------- per DEBUG
                  teamID = teamID, initialized = true, faction = nil, techLevel = 0,
                  commanderInfo = nil, startPos = { x = startX, y = startY, z = startZ },
                  constructors = {}, factories = {}, combatUnits = {}, buildings = {}, missions = {},
                  resourceInfo = { lastUpdateFrame = -100 },
                  economyObjectives = {}, -- Aggiunto per obiettivi random
                  -- === NUOVE CHIAVI PER GRUPPI E PATTUGLIAMENTO ===
                  combatGroups = {},
                  patrolPoints = {},
                  nextPatrolPointIndex = 1,
                  nextGroupID = 1,
                  regeneratePatrolPoints = true, -- Forza la generazione al primo avvio
                  -- === NUOVE CHIAVI PER HOTSPOT ===
                  hotspots = {},          -- Tabella per gli hotspot (ID hotspot -> dati hotspot)
                  nextHotspotID = 1,    -- Contatore per ID hotspot unici
                  -- ===============================				  
                  hotspots = {}, -- Prepariamo già la tabella per il futuro
                  -- ===============================================				  
                  HasFactoryOfTier = TeamHasFactoryOfTier,
                  FindIdleConstructor = FindIdleConstructorForTeam,
                  NeedsConstructor = TeamNeedsConstructor,
                  FindGoodFactoryPos = FindGoodFactoryPosForTeam,
                  CanAfford = CanAffordUnit,
                  FindBestMetalSpot = FindBestMetalSpotForTeam,
                  FindGoodEnergySpot = FindGoodEnergySpotForTeam,
                  NeedsBasicEconomy = function(self)
                        local mexCount=0; local powCount=0
                        local mexData = GetUnitDataByRole(self.faction, 1, "T1_Extractor")
                        local powData = GetUnitDataByRole(self.faction, 1, "T1_PowerPlant")
                        if mexData then mexCount = #Spring.GetTeamUnitsByDefs(self.teamID, mexData.id) end
                        if powData then powCount = #Spring.GetTeamUnitsByDefs(self.teamID, powData.id) end
                        local cfg = aiConfig[self.techLevel]
                        local needsMex = false; local needsPow = false
                        if cfg and cfg.economyTargets then
                           for _,t in ipairs(cfg.economyTargets) do
                              if t.role == "T1_Extractor" then needsMex = (mexCount < t.min); break end
                           end
                           for _,t in ipairs(cfg.economyTargets) do
                              if t.role == "T1_PowerPlant" then needsPow = (powCount < t.min); break end
                           end
                        end
                        return needsMex or needsPow
                  end,
              }
              CheckTeamCommander(teamID)
			  GeneratePatrolPoints(teamID, teamData[teamID]) -- <<< CHIAMATA QUI
          end
      end
      gameStarted = true
      Log(nil, gadget:GetInfo().name .. " Game Started. Final Map Category: " .. currentMapCategory)
  end

  function gadget:GameFrame(frame)
    if not gameStarted then return end
    for teamID, data in pairs(teamData) do
      if data.initialized and data.faction and data.faction ~= "UNKNOWN" then
        if frame % 150 == (teamID * 15) % 150 then
            Log(teamID, "Current State - TechLevel: " .. data.techLevel .. " | Map: " .. currentMapCategory)
        end
        UpdateResourceInfo(teamID, frame)
        if frame % 45 == (teamID * 3) % 45 then ManageTechLevel(teamID, frame) end
        if frame % 61 == (teamID * 5) % 61 then ManageEconomy(teamID, frame) end
        if frame % 91 == (teamID * 7) % 91 then ManageProduction(teamID, frame) end
		-- Dentro gadget:GameFrame, nel ciclo for teamID, data in pairs(teamData) do
		if frame % 151 == (teamID * 11) % 151 then -- Ogni ~5 secondi (151 è un primo per desincronizzare)
			DecayHotspots(teamID, data, frame)
		end
        if frame % 121 == (teamID * 9) % 121 then ManageMilitary(teamID, frame) end
      elseif data.initialized and not data.faction then
          if frame % 30 == 5 then CheckTeamCommander(teamID) end
      end
    end
  end

  function gadget:UnitFinished(unitID, unitDefID, unitTeam)
    if teamData[unitTeam] then
      local data = teamData[unitTeam]
      if not data.faction then return end
      local unitDef = UnitDefs[unitDefID]
      local faction = data.faction
      local foundType = nil; local unitData = nil;
      for tier = 1, 3 do
          local tierKey = "T"..tier
          local tierDefs = factionUnits[faction]._unitDefIDs[tierKey]
          if tierDefs then
              if tierDefs.constructor and unitDefID == tierDefs.constructor.id then unitData=tierDefs.constructor;data.constructors[unitID] = { tier = tier, state = "idle", task = nil, moveType=unitData.moveType }; foundType = "Con "..tierKey; break end
              if tierDefs.factory and unitDefID == tierDefs.factory.id then unitData=tierDefs.factory;data.factories[unitID] = { tier = tier, producing = nil, moveType=unitData.moveType }; foundType = "Fac "..tierKey; break end
              if tierDefs.extractor and unitDefID == tierDefs.extractor.id then unitData=tierDefs.extractor;data.buildings[unitID] = { tier = tier, type = "extractor", moveType=unitData.moveType }; foundType = "Ext "..tierKey; break end
              if tierDefs.powerPlant and unitDefID == tierDefs.powerPlant.id then unitData=tierDefs.powerPlant;data.buildings[unitID] = { tier = tier, type = "power", moveType=unitData.moveType }; foundType = "Pow "..tierKey; break end
              if tierDefs.attackers then for _, d in ipairs(tierDefs.attackers) do if unitDefID == d.id then unitData=d; data.combatUnits[unitID] = { tier = tier, type = "attacker", group = nil, state = "idle", moveType=unitData.moveType }; foundType = "Atk "..tierKey; break end end; if foundType then break end end
              if tierDefs.defenses then for _, d in ipairs(tierDefs.defenses) do if unitDefID == d.id then unitData=d; data.buildings[unitID] = { tier = tier, type = "defense", moveType=unitData.moveType }; foundType = "Def "..tierKey; break end end; if foundType then break end end
          end
      end
      if foundType then Log(unitTeam, "UnitFinished: " .. unitID .. " (" .. (unitDef and unitDef.humanName or "N/A") .. ") - Categorized as: " .. foundType .." (MoveType: ".. (unitData and unitData.moveType or 'N/A') .. ")")
      else Log(unitTeam, "UnitFinished: " .. unitID .. " (" .. (unitDef and unitDef.humanName or "N/A") .. ") - Not categorized.") end
    end
  end

  function gadget:UnitDestroyed(unitID, unitDefID, unitTeam, ...) -- Aggiunto ... per argomenti extra
      if teamData[unitTeam] then
          local data = teamData[unitTeam]
          local uDef = UnitDefs[unitDefID]
          -- Log(unitTeam, "UnitDestroyed: " .. unitID .. " ("..(uDef and uDef.humanName or "Unknown")..")")

          if data.constructors[unitID] then data.constructors[unitID] = nil
          elseif data.factories[unitID] then data.factories[unitID] = nil
          elseif data.combatUnits[unitID] then
              -- Se era in un gruppo, verrà rimosso da UpdateCombatGroupStates.
              -- Qui semplicemente lo togliamo dalla lista generale.
              data.combatUnits[unitID] = nil
          elseif data.buildings[unitID] then data.buildings[unitID] = nil
          end

          -- Rimuovi unità dai gruppi se distrutta (UpdateCombatGroupStates lo fa già,
          -- ma una doppia verifica non fa male o si può fare qui se preferisci)
          -- for groupID, groupData in pairs(data.combatGroups or {}) do
          --     local newUnitsInGroup = {}
          --     local unitWasInThisGroup = false
          --     for _, idInGroup in ipairs(groupData.units) do
          --         if idInGroup ~= unitID then
          --             table.insert(newUnitsInGroup, idInGroup)
          --         else
          --             unitWasInThisGroup = true
          --         end
          --     end
          --     if unitWasInThisGroup then
          --         groupData.units = newUnitsInGroup
          --         Log(unitTeam, "Removed unit "..unitID.." from group "..groupID.." upon destruction.")
          --         if #groupData.units == 0 then
          --             Log(unitTeam, "Group "..groupID.." became empty after unit destruction, removing group.")
          --             data.combatGroups[groupID] = nil
          --         end
          --     end
          -- end
      end
  end

  function gadget:Shutdown()
    Log(nil, gadget:GetInfo().name .. " Shutting down.")
  end

end -- SYNCED CODE END


-- UNSYNCED CODE (Debug Visivo e Comando Console)
if (not gadgetHandler:IsSyncedCode()) then
    local function DrawFactionAndTech(teamID, data)
      local x, y, z = Spring.GetTeamStartPosition(teamID)
      if x and data.faction then
         gl.Text(data.faction .. " (T" .. data.techLevel .. ")", x, y+60, 15, "co")
      end
    end

    function gadget:DrawWorld()
      if SYNCED and SYNCED.WMRTSAI_Debug_Mode and SYNCED.WMRTSAI_Debug_Mode > 0 and type(SYNCED.teamData) == "table" then
        for teamID, data in pairs(SYNCED.teamData) do
           if data and data.initialized then
              DrawFactionAndTech(teamID, data)
           end
        end
        gl.Color(1,1,1,1)
      end
    end

    function gadget:DrawScreen(vsx, vsy)
       if SYNCED and SYNCED.WMRTSAI_Debug_Mode and SYNCED.WMRTSAI_Debug_Mode > 0 and SYNCED.currentMapCategory then
          gl.Text("Map Category: " .. SYNCED.currentMapCategory, vsx * 0.5, vsy - 30, 15, "co")
       end
    end

    local function ToggleDebug(cmd, line, words, player)
      local currentMode = 0
      if SYNCED and SYNCED.WMRTSAI_Debug_Mode then currentMode = SYNCED.WMRTSAI_Debug_Mode end
      local newMode = (currentMode == 0) and 1 or 0
      Spring.SendLuaRulesMsg("WMRTSAI_SetDebug " .. newMode)
      Spring.Echo("WMRTSAI Debug Mode set to: " .. newMode .. " (Command sent)")
      return true
    end

    function gadget:Initialize()
       gadgetHandler:AddChatAction("wmrtsai_debug", ToggleDebug, "Toggle WMRTSAI debug messages/drawing")
    end

    function gadget:RecvLuaMsg(msg, playerID)
      if msg:find("^WMRTSAI_SetDebug") then
          local _, levelStr = msg:match("([^ ]+)%s+(.*)")
          local level = tonumber(levelStr)
          if level ~= nil then
              if SYNCED then SYNCED.WMRTSAI_Debug_Mode = level end
          end
          return true
      end
      return false
    end
end -- FINE UNSYNCED