--[[
Questa versione di military (16) non legge ancora le variabili globali
	if (not GG.AI_RaggioDifesa) then GG.AI_RaggioDifesa = {} end 	-- raggio di difesa della base del team
	if (not GG.AI_StatoGuerra) then GG.AI_StatoGuerra = {} end		-- stato di guerra del team
	if (not GG.AI_BasePos) then GG.AI_BasePos = {} end				-- posizione della base del team
inviate dal gadget “wmrts_AI_constructionManagement”
e pertanto il sistema invia continuamente le unità alll’attacco a prescindere dallo stato della guerra.
Il sistema V16 è funzionante ed è stato siglato “checkpoint”. Molix
]]--


function gadget:GetInfo()
	return {
		name      = "WMRTS Squad Commander AI",
		desc      = "AI V0.3 for War Machnines RTS",
		author    = "molix",
		date      = "2025",
		license   = "GPL",
		layer     = 100,
		enabled   = true
	}
end

-- 08/01/2025 = creata l'AI WMRTS_AI per missioni (base per l'AI skirmish)
-- 09/01/2025 = implementato il comando attack al gruppo di bombardieri. Prima l'AI gestiva solamente il comando FIGHT ma i bombardieri non bombardano automaticamente, bisogna indicargli il punto da bombardare con il comando Attack.
-- 09/01/2025 = esternizzata la tabella/db delle unità in WMRTS_AI_mission_db.lua
-- 11/01/2025 = sistemato bug tabelle NIL quando una fabbrica viene distrutta/rimossa
-- 12/01/2025 = agguiunti i livelli di difficoltà della AI. Per ora scattano dopo x minuti di tempo. Predisposto per una logica migliore di avanzamento (ad esempio quando ci sarà il controllo dei costruttori e l'avanzamento è dato da quanti estrattori e/o centrali solari l'AI ha costruito)
-- 14/01/2025 = le AI sono ora indipendenti (mentre prima il livello delle AI era unico per tutti i teams
-- 14/01/2025 = Aggiungo la gestione " ignore = true" nel database, da applicare ai costruttori, gestiti da altri gadget. In questo gadget i costruttori devono essere ignorati (cioè non devono essere inseriti in gruppi e mandati all'attacco), devono essere considerati invece solo come bersagli da attaccare ("ground" o relativi)
-- 29/01/2025 = Ora l'avanzamento di livello viene gestito dal gadget construcionManagement
-- 09/02/2025 = Aggiunta priorità nella categoria di attacco (per bombardieri & Co) e aggiunta categoria defence e strategicdefence
-- 20/02/2026 = Ho aggiunto la categoria (type) strategicshield in quanto prima gli shield erano inclusi in "strategicbuilding". In questo modo i cannoni a lungo raggio gestiti dalla AI del gadget "wmrts_AI_longWeaponManagement.lua" non prendono di mira gli shield (antiplasma) che prima erano categorizzati come "strategicbuilding". Il codice in questo gadget viene modificato in modo che, se prima, la categoria "X" attaccava solo "strategicbuilding", ora deve attaccare anche la type scorporata "strategicbuilding"

-- to do LIST ################################
-- 1) implementare i SUB


if (not gadgetHandler:IsSyncedCode()) then
	return false
end

--------------------------------------------------------------------------------
-- 1) DATABASE UNITÀ -- caricato dal file WMRTS_AI_mission_db.lua
--------------------------------------------------------------------------------
-- Qui puoi aggiungere campi extra in futuro (es. priority, armor_type, ecc.)
-- La tipologia di ogni singola unità è necessaria affinchè la AI gestisca le squadre/gruppi (punto 2) contro le singole unità.
-- Ad esempio le tipologie di unità "ground" definite nel database verranno bersagliate dai gruppi tipo "ground" e "air_toground" definiti nel punto 2. 
-- Questa logica di "chi attacca cosa" è definita poi nel punto "4) LOGICA DI TARGETING BASATA SU DATABASE"
-- definizione delle tipologie "type":
--			type = ground 				-> unità mobile di terra (veicoli e Kbot)
--			type = air 					-> unità mobile aerea
--			type = hovercraft 			-> unità mobile di terra che può andare sul mare
--			type = naval 				-> unità mobile navale (di superficie, no SUB)
--			type = building 			-> unità fissa di superficie su terra (di difesa/produzione/energia)
--			type = navalbuilding 		-> unità fissa di superficie su mare (di difesa/produzione/energia)
--			type = defence 				-> unità fissa di difesa T1-2 + ( Es torrette di difesa importanti, antiaerea ecc )
--			type = strategicbuilding 	-> unità fissa di superficie strategica ( Es factory 3 livello, silos, antipalline, ecc )
--			type = strategicdefence 	-> unità fissa di difesa strategica ( Es bertha, corbuzz, toaster, ecc )
--			type = strategicshield		-> unità fissa shield (es. plasma repulsor) 
--			tutte le unità che non sono identificate in questo database, prenderanno valore type = unknown , vedere poi la logica di targetin come gestirle

local dbPath = "LuaRules/Configs/WMRTS_AI_mission_db.lua"
local UNIT_DB = VFS.Include(dbPath)

-- Debug in caso di mancanza del database
if not UNIT_DB then
    Spring.Echo("WMRTS_militMngm_AI: WARNING -> WM AI units database not found in: " .. dbPath)
    UNIT_DB = {}
end

--------------------------------------------------------------------------------
-- 2a) CONFIGURAZIONE SQUADRE / GRUPPI (LISTE DI COSTRUZIONE) e tipologia
--------------------------------------------------------------------------------

-- Il nome dello "squad_template" identifica solamente il nome del gruppo da creare. Es. ["ICU_armlab_light_patrol_1"], verrà poi impiegato nel punto 2b per dire alla fabbrica: costruisci le unità di questo gruppo e forma il gruppo
-- units = l'elenco delle unità (solo militari) che comporranno il gruppo (ad esempio il gruppo "ICU_armlab_light_patrol_1". Le unità di costruzione (dichiarate nel database) non verranno gestite nel gruppo ma verranno ignorate per essere gestite da altri gadget
-- type = tipologia di squadra, la tipologia verrà impiegata nella logica di targeting (punto 4) per dire quali unità devono attaccare. In generale descrizioni a seguito:
-- 					type = "ground" 				-> manda all'attacco verso la prima unità, trovata in base all'ID, che corrisponda a "ground", "building", "strategicbuilding", "strategicdefence", "unknown" e "defence" se y di quest'ultima > -1 (vedere punto 4). Ideale per le truppe di terra o gli aerei.
-- 					type = "ground_hovercraft" 		-> manda all'attacco verso la prima unità, trovata in base all'ID, che corrisponda a "ground", "building", "strategicbuilding", "strategicdefence", "unknown", "defence" e "hover" a prescindere dalla y di quest'ultima (rispetto al gruppo "ground". Ideale per gli hovecraft e per gli aerei
--					type = "air_toair" 				-> tutti gli aerei destinati ad attaccare solo aerei
--					type = "air_toground" 			-> tutti gli aerei destinati ad attaccare tutte le unità mobili di terra (ground, hovercraft e naval). Attenzione: non sono presenti "building", "strategicbuilding", "strategicdefence", "defence". In questa categoria non mettere bombardieri in quanto sorvolerebbero solamente la zona per poi "sedersi". Per loro ci vuole una logica di attacco diretto sull'unità, per questo usare i gruppi specifici per bombardieri
--					type = "air_bomber" 			-> specifico per tutti gli aerei da bombardamento. In questo gruppo possono essere inclusi anche gli aerei di attacco a terra (tipo armfig e bombardieri). Hanno una logica con priorità sui target e manda le unità all'attacco direttamente sull'unità di tipo (in ordine di priorità): "building", "defence", "strategicbuilding", "strategicdefence", "ground")
--					type = "air_bomber_strategic" 	-> specifico per tutti gli aerei da bombardamento. In questo gruppo possono essere inclusi anche gli aerei di attacco a terra (tipo armfig e bombardieri). Hanno una logica con priorità sui target e manda le unità all'attacco direttamente sull'unità di tipo (in ordine di priorità):"strategicbuilding", "strategicdefence", "building", "defence" e "ground"

local SQUAD_TEMPLATES = {

-- divido qui sotto i template di costruzione in funzione del livello, solo per maggior chiarezza. Quando il livello sale, vado a cambiare i templates di costruzione in 2b)

-------------------------------------------------------------------------------
--  Set di gruppi per l'AI - le ho divise per livello per una maggiore visibilità, ma sono soltanto nomi di gruppi e nessuno vieta che al livello 3 si posssa produrre il gruppo "ICU_armlab_light_patrol_1" del livello 0. Basta elencare i gruppi che si voglio creare, in base al livello, nel paragrafo 2b
-------------------------------------------------------------------------------

---------------
-- ICU gruppi creati per il lvl 0÷4 -------- 
---------------
-- armlab
	["ICU_armlab_light_patrol_1"] = {
		units = { "icupatroller", "icupatroller", "icurock", "icurock" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armlab_light_patrol_2"] = {
		units = { "icuwar", "icupatroller", "icurock", "icurock" },				
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armvp	
	["ICU_armvp_light_patrol_1"] = {
		units = { "armfav", "icuflash", "icuflash", "icuflash" }, 
		type = "ground"
	},
	["ICU_armvp_light_patrol_2"] = {
		units = { "armsam", "armsam", "armstump", "armpincer", "armpincer","tawf013" }, 
		type = "ground"
	},	
-- armap	
	["ICU_armap_air_raid_1"] = { 			
		units = { "armkam", "armfig", "armfig", "armkam", "armkam" },
		type = "air_toground"
	},
	["ICU_armap_antiair_raid_1"] = { 
		units = { "armfig", "armfig", "armfig" },
		type = "air_toair"
	},
	["ICU_armap_air_bomber_1"] = { 
		units = { "armthund", "armthund", "armthund", "armthund", "armthund" }, 	-- gruppo da 5 bombardieri
		type = "air_bomber"
	},	
--	["naval_fleet"] = {
--		units = { "corbats", "corbats", "corbats" },
--		type = "naval"
--	}
-- armalab
	["ICU_armalab_light_patrol_1"] = {
		units = { "armfast", "armfast", "armfast" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armalab_light_patrol_2"] = {
		units = { "armfast", "armfast", "armzeus" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armavp
	["ICU_armavp_light_patrol_1"] = {
		units = { "armmart", "armmart", "armlatnk" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armavp_light_patrol_2"] = {
		units = { "armlatnk", "armlatnk"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armaap
	["ICU_armaap_light_patrol_1"] = {
		units = { "armhawk", "armhawk", "armhawk" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armaap_light_patrol_2"] = {
		units = { "armhawk", "armhawk"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
---------------
-- AND gruppi creati per il lvl 0÷4 -------- 
---------------
	["AND_andlab_light_patrol_1"] = {
		units = { "andscouter", "andscouter", "andscouter", "andscouter" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["AND_andlab_light_patrol_2"] = {
		units = { "andscouter", "anddauber", "anddauber", "andbrskr" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["AND_andalab_light_patrol_1"] = { 
		units = { "walker", "walker", "exxec", "andogre" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["AND_andalab_light_patrol_2"] = { 
		units = { "andogre", "interceptor", "walker", "exxec" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
	["AND_andhp_light_patrol_1"] = {
		units = { "andgaso", "andlipo", "andlipo", "andgaso" }, 
		type = "ground_hovercraft"
	},
	["AND_andhp_light_patrol_2"] = {
		units = { "andgaso", "andlipo", "andlipo", "andgaso","andmisa","andmisa" }, 
		type = "ground_hovercraft"
	},	
	["AND_andahp_light_patrol_1"] = {
		units = { "androck", "andtanko", "andtesla", "andnikola" }, 
		type = "ground_hovercraft"
	},	
	["AND_andahp_light_patrol_2"] = {
		units = { "andnikola", "andnikola", "androck", "androck", "andtanko" }, 
		type = "ground_hovercraft"
	},		
	["AND_andplatplat_air_raid_1"] = { 			
		units = { "andstr", "andfig", "andfig", "andstr", "andstr" },
		type = "air_toground"
	},
	["AND_andplat_antiair_raid_1"] = { 
		units = { "andfig", "andfig", "andfig" },
		type = "air_toair"
	},
	["AND_andplat_air_bomber_1"] = { 
		units = { "andbomb", "andbomb", "andbomb", "andbomb", "andbomb" }, 	-- gruppo da 5 bombardieri
		type = "air_bomber"
	},		
	["AND_andaplatplat_air_raid_1"] = { 			
		units = { "anddragon", "corhors", "corhors" },
		type = "air_toground"
	},
	["AND_andaplat_air_bomber_1"] = { 
		units = { "anddragon", "anddragon", "corhors", "corhors", "corhors" }, 	
		type = "air_bomber"
	},		
	["AND_andaplat_air_bomber_2"] = { 
		units = { "anddragon", "anddragon", "corhors", "corhors", "corhors" }, 	
		type = "air_bomber_strategic"
	},				

-------------------------------------------------------------------------------
-- Elenco di produzioni per l'AI al livello 5+ - le fabbriche avranno gruppi più numerosi e composti da unità più forti 
-------------------------------------------------------------------------------
	
---------------
-- ICU gruppi creati per il lvl 5+ -------- 
---------------
-- armlab
	["ICU_armlab_medium_patrol_1"] = {
		units = { "icuwar", "icuwar", "icuwar", "icurock", "icurock" , "icurock", "icuinv", "armjeth"  }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armlab_medium_patrol_2"] = {
		units = { "icuwar", "icuwar", "icurock", "icurock", "icurock", "icurock", "armjeth", "icuinv", "icuinv" },				
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armvp	
	["ICU_armvp_medium_patrol_1"] = {
		units = { "armsam", "armsam", "armsam", "tawf013", "armsam", "armstump", "armpincer", "armsam" }, 
		type = "ground"
	},
	["ICU_armvp_medium_patrol_2"] = {
		units = { "armsam", "armsam", "armsam", "tawf013", "armstump", "tawf013", "armstump", "armpincer", "armpincer", "armpincer" }, 
		type = "ground"
	},	
-- armap	
	["ICU_armap_air_mediumraid_1"] = { 			
		units = { "armkam", "armfig", "armfig", "armkam", "armkam", "armkam", "armkam", "armkam", "armkam", "armkam" },
		type = "air_toground"
	},
	["ICU_armap_antiair_mediumraid_1"] = { 
		units = { "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig" },
		type = "air_toair"
	},
	["ICU_armap_air_mediumbomber_1"] = { 
		units = { "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund" }, 	-- gruppo da 10 bombardieri
		type = "air_bomber"
	},	
	["ICU_armap_air_mediumstrategicbomber_1"] = { 
		units = { "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund" }, 	-- gruppo da 12 bombardieri
		type = "air_bomber_strategic"
	},				
--	["naval_fleet"] = {
--		units = { "corbats", "corbats", "corbats" },
--		type = "naval"
--	}
-- armalab
	["ICU_armalab_medium_patrol_1"] = {
		units = { "icufboy", "icufboy", "icufboy", "armaak", "icufboy", "icufboy", "armfido" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armalab_medium_patrol_2"] = {
		units = { "armsptk", "armsptk", "armsptk", "armsptk", "armsptk", "armaak", "armsptk", "armsptk" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armavp
	["ICU_armavp_medium_patrol_1"] = {
		units = { "armmart", "armmart", "armyork", "armmart", "armmart", "armmart", "armmart", "armmart", "armmart", "icubull", "icubull" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armavp_medium_patrol_2"] = {
		units = { "armlatnk", "armlatnk", "icubull", "icubull", "armmart", "armyork"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armavp_medium_patrol_3"] = {
		units = { "armlatnk", "armlatnk", "icubull", "icubull", "armmart", "armyork", "armmanni", "armcroc", "armcroc"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
-- armaap
	["ICU_armaap_medium_patrol_1"] = {
		units = { "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk" }, 
		type = "air_toair" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armaap_medium_patrol_2"] = {
		units = { "blade", "blade", "armbrawl", "armbrawl", "blade", "blade", "armbrawl", "armbrawl", "armbrawl", "armbrawl"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
	["ICU_armaap_air_bomber_1"] = { 
		units = { "armbrawl", "armbrawl", "armbrawl", "armbrawl", "armpnix", "armpnix", "armbrawl", "armbrawl", "armbrawl" }, 	
		type = "air_bomber"
	},		
	["ICU_armaap_air_bomber_2"] = { 
		units = { "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix" }, 	
		type = "air_bomber_strategic"
	},		
-- icugant
	["ICU_icugant_medium_patrol_1"] = {
		units = { "armshock", "armshock", "armtigre" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
	["ICU_icugant_medium_patrol_2"] = {
		units = { "armshock", "armshock" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},			
	["ICU_icugant_medium_patrol_3"] = {
		units = { "armtigre", "armtigre" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},			
-- armshltx
	["ICU_armshltx_medium_patrol_1"] = {
		units = { "icuraz", "icuraz", "icuraz" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armshltx_medium_patrol_2"] = {
		units = { "icuraz", "icuraz", "icuraz", "icuraz", "warhammer" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armshltx_medium_patrol_3"] = {
		units = { "icufurie" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armshltx_medium_patrol_4"] = {
		units = { "icufurie", "icuraz","icuraz" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},			
	["ICU_armshltx_medium_patrol_5"] = {
		units = { "warhammer", "warhammer", "icuraz","icuraz" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},				
---------------
-- AND gruppi creati per il lvl 5+ -------- 
---------------
-- ################################## da completare	
} -- end tabella squadre

--------------------------------------------------------------------------------
-- 2b) CONFIGURAZIONE FABBRICHE E BUILDLIST
--------------------------------------------------------------------------------
-- Funzione CONFIGURAZIONE FABBRICHE in base al teamLevels, selezionare gli squad_templates (le liste di costruzione)
-- ad ogni livello il numero di unità x squadra aumenta come aumenta la qualità delle unità prodotte
-- ogni livello è indipendente per ogni team
local teamLevels = {}       -- Tabella: [teamID] = livello attuale dell'AI per ogni singolo team (0, 1, 2...)
local teamConfigs = {}      -- Tabella: [teamID] = la FACTORY_CONFIG specifica per livello di ogni team

local FACTORY_CONFIG = {} 		-- all'inizio imposto la tabella vuota ################################  SOSTITUIRE???
-- local livello_AI = 0 			-- ##################### all'inizio imposto il livello della AI = 0 (livello iniziale #################
-- local lastLevel = -1 			-- ##################### Usiamo -1 così al primo frame carica il livello 0. Questa variabile serve come "antiripetizione" e verrà utilizzata per aumentare di livello l' AI una volta sola #####################

local function GetConfigPerLivello(livello) -- Questa funzione restituisce, per ciascun team, la tabella delle fabbriche in funzione del livello corrente del team
    if livello <= 4 then					
        return {
            -- ICU --
            ["armlab"] = { "ICU_armlab_light_patrol_1", "ICU_armlab_light_patrol_2" },
            ["armvp"] = { "ICU_armvp_light_patrol_1", "ICU_armvp_light_patrol_2" },
            ["armap"]  = { "ICU_armap_antiair_raid_1", "ICU_armap_air_raid_1","ICU_armap_air_bomber_1" },			
            ["armalab"] = { "ICU_armalab_light_patrol_1", "ICU_armalab_light_patrol_2" },							-- inseriti in caso di recessione della AI dal livello 4+ a 0
            ["armavp"] = { "ICU_armavp_light_patrol_1", "ICU_armavp_light_patrol_2" },			
            ["armaap"]  = { "ICU_armaap_light_patrol_1", "ICU_armaap_light_patrol_2"},			
            -- AND -- ################### CONCLUDERE
            ["andlab"] = { "AND_andlab_light_patrol_1", "AND_andlab_light_patrol_2" },
            ["andalab"] = { "AND_andalab_light_patrol_1", "AND_andalab_light_patrol_2" }, 
            ["andhp"] = { "AND_andhp_light_patrol_1", "AND_andhp_light_patrol_2" },
            ["andahp"] = { "AND_andahp_light_patrol_1", "AND_andahp_light_patrol_2" },        
            ["andplat"]  = { "AND_andplatplat_air_raid_1", "AND_andplat_antiair_raid_1","AND_andplat_air_bomber_1" },
            ["andaplat"]  = { "AND_andaplatplat_air_raid_1", "AND_andaplat_air_bomber_1","AND_andaplat_air_bomber_2" },
        }
    elseif livello > 4 then
        return {
            -- ICU --
            ["armlab"] = { "ICU_armlab_medium_patrol_1", "ICU_armlab_medium_patrol_2" },
            ["armvp"] = { "ICU_armvp_medium_patrol_1", "ICU_armvp_medium_patrol_2" },
            ["armap"]  = { "ICU_armap_air_mediumraid_1", "ICU_armap_antiair_mediumraid_1","ICU_armap_air_mediumbomber_1","ICU_armap_air_mediumstrategicbomber_1" },
            ["armalab"] = { "ICU_armalab_medium_patrol_1", "ICU_armalab_medium_patrol_2" },			
            ["armavp"] = { "ICU_armavp_medium_patrol_1", "ICU_armavp_medium_patrol_2", "ICU_armavp_medium_patrol_3" },
            ["armaap"]  = { "ICU_armaap_medium_patrol_1", "ICU_armaap_medium_patrol_2","ICU_armaap_air_bomber_1","ICU_armaap_air_bomber_2" },		
            ["icugant"] = { "ICU_icugant_medium_patrol_1", "ICU_icugant_medium_patrol_2", "ICU_icugant_medium_patrol_3" },		
            ["armshltx"] = { "ICU_armshltx_medium_patrol_1", "ICU_armshltx_medium_patrol_2", "ICU_armshltx_medium_patrol_3", "ICU_armshltx_medium_patrol_4", "ICU_armshltx_medium_patrol_5" },		
            -- AND -- ################### CONCLUDERE
            ["andlab"] = { "AND_andlab_light_patrol_1", "AND_andlab_light_patrol_2" },
            ["andhp"] = { "AND_andhp_light_patrol_1", "AND_andhp_light_patrol_2" },
            ["andplat"]  = { "AND_andplatplat_air_raid_1", "AND_andplat_antiair_raid_1","AND_andplat_air_bomber_1" },
        }
    end
    return {} -- default vuoto
end

local TARGET_AI_NAME = "WarMachinesRTSmissionAI" 
local SQUAD_TIMEOUT_SECONDS = 600 -- questo timeout definisce i secondi di attesa per la formazione del gruppo delle unità uscite dalla fabbrica. Oltre questo timeout il gruppo si completa cosi com'è e parte all'attacco o difesa 

--------------------------------------------------------------------------------
-- 3) VARIABILI
--------------------------------------------------------------------------------

local aiTeamIDs = {}      
local factories = {}      
local squads = {}         

--------------------------------------------------------------------------------
-- 4) LOGICA DI TARGETING BASATA SU DATABASE
--------------------------------------------------------------------------------

-- Funzione per ottenere la categoria dal NOSTRO database
local function GetUnitCategoryFromDB(unitID)
	local uDefID = Spring.GetUnitDefID(unitID)	-- definizione di Spring.GetUnitDefID(unitID)
	if not uDefID then return "unknown" end		-- se non esiste ID assegnato all'unità la funzione restituisce il valore "unknown"
	local unitName = UnitDefs[uDefID].name		-- altrimenti prosegui e assegna a unitrname il nome dell'unità
	
	if UNIT_DB[unitName] then					-- se nel database è presente la voce col il nome dell'unità (unitName)
		return UNIT_DB[unitName].type			-- restituisci type inerente al nome di quella unità
	end											
	return "unknown" 							-- altrimenti se niente di cui sopra è avvenuto, restituisci "unknown"
end

-- Funzione per trovare il bersaglio 
local function GetSmartEnemyTarget(myTeamID, squadType)
	local allUnits = Spring.GetAllUnits()
	local gaiaTeamID = Spring.GetGaiaTeamID()
	
	-- Variabili per la logica di priorità dei bombardieri 
	local bestTarget = nil
	local highestPriority = -1

	for i = 1, #allUnits do
		local uID = allUnits[i]
		local uTeam = Spring.GetUnitTeam(uID)
		
		if uTeam ~= gaiaTeamID and not Spring.AreTeamsAllied(myTeamID, uTeam) then
			local enemyCat = GetUnitCategoryFromDB(uID)
			local x, y, z = Spring.GetUnitPosition(uID)
			
			if x then
				-------------
				-- TERRA: -- il ciclo for scansiona per ID di unità. l'AI quindi sceglie la prima unità che trova e che corrisponde ad una delle seguenti categorie "enemyCat". Quindi senza priorità.
				-------------	
				if squadType == "ground" then -- solo truppe di terra vs terra
				-- "ground", "building", "strategicbuilding", "unknown" e "defence"
					if enemyCat == "ground" or enemyCat == "unknown" or enemyCat == "building" or enemyCat == "strategicbuilding" or enemyCat == "strategicdefence" or enemyCat == "defence" or enemyCat == "strategicshield" then 
						return {x=x, y=y, z=z}
					elseif enemyCat == "hover" and y >= -1 then	-- se gli hovercraft sono o sulla riva o sulla terraferma
						return {x=x, y=y, z=z}
					end

				elseif squadType == "ground_hovercraft" then -- solo truppe di mare e terra vs hovercraft 
					if enemyCat == "ground" or enemyCat == "unknown" or enemyCat == "building" or enemyCat == "strategicbuilding" or enemyCat == "strategicdefence"or enemyCat == "hover" or enemyCat == "defence" or enemyCat == "strategicshield" then  
						return {x=x, y=y, z=z}
					end
				-------------					
				-- NAVALI: Attaccano naval e hover (solo se sopra la superficie dell' acqua) ---- ################################### implementare
				-------------				
				elseif squadType == "naval" then
					if enemyCat == "naval" then
						return {x=x, y=y, z=z}
					elseif enemyCat == "hover" and y < -1 then -- minore di -1 (da -x a -1) rispetto al livello dell'acqua, si presume tutti gli hovercraft che sono in acqua  ###################### verificare se il parametro altezza è corretto per definire che l'hovercraft è in acqua
						return {x=x, y=y, z=z}
					end
				-------------
				-- AEREI: 
				-------------	
				elseif squadType == "air_toair" then
					if enemyCat == "air" then 
						return {x=x, y=y, z=z} 
					end
				elseif squadType == "air_toground" then
					if enemyCat == "ground" or enemyCat == "naval" or enemyCat == "hover" then
						return {x=x, y=y, z=z} 
					end				
				elseif squadType == "air_bomber" then 					--(su "airbomber" non usiamo "return" subito perché vogliamo scansionare tutto e dare ai bombardieri una priorità sulle categorie da attaccare e, se non esiste la prima (priorità più alta), vai sulla seconda e cosi via...
					local currentPriority = 0
					if enemyCat == "defence" then
						currentPriority = 6
					elseif enemyCat == "building" then
						currentPriority = 5
					elseif enemyCat == "strategicbuilding" then
						currentPriority = 4
					elseif enemyCat == "strategicdefence" then
						currentPriority = 3
					elseif enemyCat == "strategicshield" then
						currentPriority = 2						
					elseif enemyCat == "ground" then
						currentPriority = 1						
					end
						if currentPriority > highestPriority then
							highestPriority = currentPriority
							bestTarget = {x=x, y=y, z=z, id=uID}
							if highestPriority == 6 then break end -- Se trovo il top, interrompo il ciclo for
						end					
				elseif squadType == "air_bomber_strategic" then			--(su "air_bomber_strategic", non usiamo "return" subito perché vogliamo scansionare tutto e dare ai bombardieri una priorità sulle categorie da attaccare e, se non esiste la prima, vai sulla seconda e cosi via...
					local currentPriority = 0
					if enemyCat == "strategicbuilding" then
						currentPriority = 6
					elseif enemyCat == "strategicshield" then
						currentPriority = 5
					elseif enemyCat == "strategicdefence" then					
						currentPriority = 4						
					elseif enemyCat == "building" then
						currentPriority = 3
					elseif enemyCat == "defence" then
						currentPriority = 2
					elseif enemyCat == "ground" then
						currentPriority = 1		
					end
						if currentPriority > highestPriority then
							highestPriority = currentPriority
							bestTarget = {x=x, y=y, z=z, id=uID}
							if highestPriority == 6 then break end -- Se trovo il top, interrompo il ciclo for
						end
				end
			end
		end
	end
	
	-- Punto di uscita per chi usa la logica a priorità (Bombardieri)
	if bestTarget then
		return bestTarget
	end

	-- Fallback finale se non è stato trovato nulla
	return { x = Game.mapSizeX/2, y = 0, z = Game.mapSizeZ/2 }
end

--------------------------------------------------------------------------------
-- 5) GESTIONE ORDINI E GADGET CORE 
--------------------------------------------------------------------------------
local function GiveAttackOrder(unitID, targetData)
	if not targetData then 
		return 
	end
	Spring.GiveOrderToUnit(unitID, CMD.STOP, {}, {}) 					-- ######## valutare se mantenere questa linea per "pulire gli ordini precedenti" ################################
	if targetData.id and Spring.ValidUnitID(targetData.id) then			-- Se abbiamo un unitID valido...
		Spring.GiveOrderToUnit(unitID, CMD.ATTACK, {targetData.id}, {}) -- ... SPARTISCO L' ORDINE DI ATTACCO DIRETTO ALL'UNITÀ (Cruciale per i bombardieri)
	else																-- Se non abbiamo un unitID, usiamo le coordinate come ripiego (Area Attack)
		local tx = targetData.x + math.random(-250, 250)
		local tz = targetData.z + math.random(-250, 250)
		local ty = Spring.GetGroundHeight(tx, tz)		
		Spring.GiveOrderToUnit(unitID, CMD.FIGHT, {tx, ty, tz}, {})
	end
end

-- Questa funzione serve ad evitare che l'AI "rubi" o interferisca con unità non sue (ad esempio di altre AI), ci si assicura che le tabelle siano sempre pulite. In questo modo se spring dovesse riassegnare l'ID di una unità distrutta ad un altra squadra, il codice non lo utilizza come se fosse sua
function gadget:UnitDestroyed(unitID, unitDefID, unitTeam)
    -- 1. Se muore una fabbrica, cancellala subito dalle nostre liste
    if factories[unitID] then
        factories[unitID] = nil
    end

    -- 2. Se muore un'unità, rimuovila da qualsiasi squadra (squads) la stia usando
    for sID, sData in pairs(squads) do
        for i = #sData.units, 1, -1 do
            if sData.units[i] == unitID then
                table.remove(sData.units, i)
            end
        end
    end
end

-- Come UnitDestroyed ma in caso di "cambio di proprietà" (es. se un'unità viene catturata)
function gadget:UnitTaken(unitID, unitDefID, unitOldTeam, unitNewTeam)
    gadget:UnitDestroyed(unitID, unitDefID, unitOldTeam)
end

function gadget:Initialize()
	local teamList = Spring.GetTeamList()
	for _, teamID in ipairs(teamList) do
		local assignedAI = Spring.GetTeamLuaAI(teamID)
		if assignedAI and string.find(string.lower(assignedAI), string.lower(TARGET_AI_NAME)) then
			aiTeamIDs[teamID] = true
            teamLevels[teamID] = -1 						-- era 0, impostazione livello 0 per il team corrente (for... do...) 
            teamConfigs[teamID] = GetConfigPerLivello(0)	-- impostazione livello 0 per il team corrente (for... do...) 
		end
	end
end

-- Funzione per restituire true se l'unità è segnata come ignore nel DB WMRTS_AI_mission_db.lua (ignore = true). sono ignore = true tutte le unità che non devono essere gestite in questo gadget (come gruppi da mandare all'attacco)
local function IsUnitIgnored(unitID)
	local uDefID = Spring.GetUnitDefID(unitID)				-- definisci localmente uDefID
	if not uDefID then return false end						-- se uDefID non è presente restituisci false (usato per altre logiche)
	local unitName = UnitDefs[uDefID].name					-- altrimenti prosegui e definisci localmente unitName
	
	if UNIT_DB[unitName] and UNIT_DB[unitName].ignore then	-- se nel database è presente l'unità unitName, e la voce "ignore" di quella unità = true allora...
		return true											-- ...restituisci true (usato poi per altre logiche)
	end
	return false											-- ...altrimenti restituisci false (usato poi per altre logiche)
end

function gadget:UnitFinished(unitID, unitDefID, unitTeam)
		-- CONTROLLO SE IL TEAM NON è L'AI
    if not aiTeamIDs[unitTeam] then return end 				-- se il team non è AI non fare niente, esci
	    -- CONTROLLO IGNORE: Se l'unità deve essere ignorata, definita nel database (ignore = true) esci subito e non gestire l'unità
    if IsUnitIgnored(unitID) then							-- utilizza la funzione IsUnitIgnored per capire se l'unità in questione è impostata con " ignore = true" nel file "WMRTS_AI_mission_db.lua", e restituisci true o false. se true non fare niente
         Spring.Echo("WMRTS_militMngm_AI: Unità ignorata per design: " .. unitID)
        return 
    end
		-- Altrimenti (se ignore = false o non impostate) associa l'unità ad una squadra
    local unitName = UnitDefs[unitDefID].name
    local config = teamConfigs[unitTeam]     	-- Recupero la configurazione attuale di QUESTO team
    if config and config[unitName] then 		-- 2) Controllo se il nome dell'unità appena finita è presente nella lista fabbriche e se config è NIL (per sicurezza), non facciamo nulla
        factories[unitID] = { defName = unitName, squadID = nil, teamID = unitTeam }
        return
    end
	local bestFactoryID = nil
	local nearestDist = 3000					-- distanza per associare l'unità creata alla fabbrica più vicino entro il valore "nearest", se non è presente alcuna fabbrica, l'unità rimane orfana
	for fID, fData in pairs(factories) do
		if fData.teamID == unitTeam then
			local dist = Spring.GetUnitSeparation(unitID, fID)
			if dist and dist < nearestDist then
				if fData.squadID and squads[fData.squadID] then
					nearestDist = dist
					bestFactoryID = fID
				end
			end
		end
	end

	if bestFactoryID then
		local fData = factories[bestFactoryID]
		local sID = fData.squadID
		local squad = squads[sID]
		table.insert(squad.units, unitID)
		
		if squad.state == "gathering" then
			local fX, _, fZ = Spring.GetUnitPosition(bestFactoryID)
			Spring.GiveOrderToUnit(unitID, CMD.MOVE, {fX + math.random(-300,300), 0, fZ + math.random(300,500)}, {"shift"})
		elseif squad.state == "attacking_monitor" then
			GiveAttackOrder(unitID, squad.attackTarget)
		end
	end
end

function gadget:GameFrame(n)
    if (n % 30 ~= 0) then return end 

--[[
    -- VECCHIA GESTIONE "A TEMPO" SEMPLICE E TEMPORANEA DEL LIVELLO AI		-- un domani la gestione del livello sarà data esternizzata in un gadget esterno della AI (esempio in quello che gestirà le costruzioni)	
    for teamID, _ in pairs(aiTeamIDs) do									-- gestione livelli per ogni team

        local tempoPartita = Spring.GetGameSeconds()    					-- Calcolo del livello (basato sul tempo per test!! cambiare poi con logica di avanzamento quando saranno presenti ulteriori costruzioni)
        local nuovoLivello = 0
        if tempoPartita > 1080 then 										-- se sono passati x secondi, imposta il livello AI del team a 1
            nuovoLivello = 1
        end
        ------------------------------
		-- Aggiungere qui altri scaglioni di tempo 
		------------------------------
		  
        if teamLevels[teamID] ~= nuovoLivello then 		-- Se il livello del team è cambiato (o non è ancora inizializzato)
            teamLevels[teamID] = nuovoLivello
            teamConfigs[teamID] = GetConfigPerLivello(nuovoLivello)
            Spring.Echo("WMRTS AI: Team " .. teamID .. " passato al livello " .. nuovoLivello)
            
            -- rendo la variabile globale per passarla ad altri gadget della AI
            if not GG.WMRTS_Levels then GG.WMRTS_Levels = {} end
            GG.WMRTS_Levels[teamID] = nuovoLivello
        end
    end
]]--

	-- GESTIONE DEI LIVELLI (CARICO I LIVELLI DALLA VARIABILE GLOBALE GESTITA DA constructionManagement GADGET 
	for teamID, _ in pairs(aiTeamIDs) do
    local nuovoLivello = (GG.WMRTS_Levels and GG.WMRTS_Levels[teamID]) or 0		-- Leggo il valore globale (se non esiste ancora, considero livello 0)
        if teamLevels[teamID] ~= nuovoLivello then 								-- Se il livello del team è cambiato (o non è ancora inizializzato)
            teamLevels[teamID] = nuovoLivello
            teamConfigs[teamID] = GetConfigPerLivello(nuovoLivello)
            Spring.Echo("WMRTS_militMngm_AI:: Team " .. teamID .. " si è allineato al livello " .. nuovoLivello)
            
            -- non è piu necessario rendere la variabile globale per passarla ad altri gadget della AI in quanto ora la ricevo
--            if not GG.WMRTS_Levels then GG.WMRTS_Levels = {} end
--            GG.WMRTS_Levels[teamID] = nuovoLivello
        end
    end

    -- GESTIONE FABBRICHE
    for fID, fData in pairs(factories) do
        local qSize = Spring.GetCommandQueue(fID, 0)
        
        if qSize == nil then
            factories[fID] = nil 
        else		
            local isBuilding = Spring.GetUnitIsBuilding(fID)
            local isLocked = false
            
            if fData.squadID and squads[fData.squadID] then
                if (qSize > 0) or isBuilding or (squads[fData.squadID].state == "gathering") then
                    isLocked = true
                else
                    fData.squadID = nil
                end
            end

            if not isLocked and qSize == 0 and not isBuilding then
                -- RECUPERO LA CONFIGURAZIONE SPECIFICA DI QUEL TEAM
                local configDelTeam = teamConfigs[fData.teamID]
                if configDelTeam then
                    local options = configDelTeam[fData.defName]
                    if options then
                        local templateName = options[math.random(1, #options)]
                        local template = SQUAD_TEMPLATES[templateName]
                        if template then
                            -- ... (il resto della tua logica di creazione squadID rimane uguale)
                            local newSquadID = n .. "_" .. fID
                            squads[newSquadID] = {
                                units = {},
                                targetSize = #template.units,
                                state = "gathering",
                                startTime = Spring.GetGameSeconds(),
                                myTeam = fData.teamID,
                                attackTarget = nil,
                                type = template.type 
                            }
                            fData.squadID = newSquadID
                            for _, uName in ipairs(template.units) do
                                local uDef = UnitDefNames[uName]
                                if uDef then Spring.GiveOrderToUnit(fID, -uDef.id, {}, {}) end
                            end
                        end
                    end
                end
            end
        end
    end

	-- GESTIONE SQUADRE
	for sID, sData in pairs(squads) do
		if sData.state == "gathering" then
			if #sData.units >= sData.targetSize or (Spring.GetGameSeconds() - sData.startTime) > SQUAD_TIMEOUT_SECONDS then
				sData.state = "attacking_monitor"
				sData.attackTarget = GetSmartEnemyTarget(sData.myTeam, sData.type)
				for _, uID in ipairs(sData.units) do
					if Spring.ValidUnitID(uID) then GiveAttackOrder(uID, sData.attackTarget) end
				end
			end
			
		elseif sData.state == "attacking_monitor" then
			if n % 90 == 0 then
				local anyAlive = false
				local anyIdle = false
				for i = #sData.units, 1, -1 do
					local uID = sData.units[i]
					if Spring.ValidUnitID(uID) and not Spring.GetUnitIsDead(uID) then
						anyAlive = true
						if Spring.GetCommandQueue(uID, 0) == 0 then anyIdle = true end
					else
						table.remove(sData.units, i)
					end
				end
				
				if anyAlive and anyIdle then
					sData.attackTarget = GetSmartEnemyTarget(sData.myTeam, sData.type)
					for _, uID in ipairs(sData.units) do
						if Spring.GetCommandQueue(uID, 0) == 0 then
							GiveAttackOrder(uID, sData.attackTarget)
						end
					end
				end
				if not anyAlive then squads[sID] = nil end
			end
		end
	end
end