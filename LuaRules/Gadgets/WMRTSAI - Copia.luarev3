--------------------------------------------------------------------------------
-- War Machines RTS - AI Gadget (v0.6 - Correzioni Multiple)
-- Nome AI: WMRTSAI
--------------------------------------------------------------------------------

function gadget:GetInfo()
  return {
    name      = "WMRTSAI", -- Nome usato per assegnare l'IA ai team!
    desc      = "AI con gestione fazioni, tiers, tipi mappa e config per livello tech.",
    author    = "Il Tuo Nome", -- Cambia questo!
    date      = "Data Corrente", -- Cambia questo!
    license   = "La Tua Licenza", -- Cambia questo!
    layer     = 90, -- Layer alto per eseguire dopo altri gadget (come Mexspot Fetcher)
    enabled   = true
  }
end

-- Variabili globali del gadget
local gameStarted = false
local teamData = {} -- Stato per ogni team AI
local KPAI_Debug_Mode = 1 -- Iniziamo con debug attivo

--------------------------------------------------------------------------------
-- SYNCED CODE - Logica di gioco principale
--------------------------------------------------------------------------------
if (gadgetHandler:IsSyncedCode()) then

  -- Speedups e locali (CMD non serve più qui se usiamo Command.* o -ID)
  local Spring = Spring
  local Game = Game
  -- local CMD = Command -- Rimosso, usiamo Command.* o -ID
  local UnitDefs = UnitDefs
  local UnitDefNames = UnitDefNames

  local LOG_SECTION = "WMRTSAI"

  -- Funzione helper per il logging debug
  local function Log(teamID, message)
    if KPAI_Debug_Mode > 0 then
      local teamPrefix = teamID and ("Team[" .. teamID .. "] ") or (LOG_SECTION .. ": ")
      Spring.Echo(teamPrefix .. message)
    end
  end

  -- === 1. DEFINIZIONE FAZIONI E UNITÀ PER TIER ===
  -- !! IMPORTANTE: Compila con NOMI ESATTI, moveType e role corretti !!
  local factionUnits = {
      ICU = {
          commander = "icucom",
          T1 = {
              extractor =   { name = "icumetex", moveType="BUILDING", role="Extractor_T1"},
              powerPlant =  { name = "armsolar", moveType="BUILDING", role="Power_T1"},
              factory =     { name = "armlab", moveType = "BUILDING", role="Factory_Land_T1"},
              constructor = { name = "icuck", moveType = "LAND", role="Constructor_T1" },
              attackers = { { name = "icupatroller", moveType = "LAND", role="Basic_T1" }, },
              defenses = { { name = "iculighlturr", moveType = "BUILDING", role="Light_T1" }, }
          },
          T2 = {
              extractor =   { name = "armamex", moveType="BUILDING", role="Extractor_T2"},
              powerPlant =  { name = "armfus", moveType="BUILDING", role="Power_T2"},
              factory =     { name = "armalab", moveType = "BUILDING", role="Factory_Land_T2" },
              constructor = { name = "armack", moveType = "LAND", role="Constructor_T2" },
              attackers = { { name = "armfboy", moveType = "LAND", role="Heavy_T2" }, },
              defenses = { { name = "armhlt", moveType = "BUILDING", role="Heavy_T2" } }
          },
          T3 = {
              factory =     { name = "armshltx", moveType = "BUILDING", role="Factory_Land_T3" },
              -- constructor = { ... },
              attackers = { { name = "armshock", moveType = "LAND", role="Experimental_T3" }, },
              defenses = { { name = "armanni", moveType = "BUILDING", role="Experimental_T3" } }
          },
          _unitDefIDs = {}
      },
      NFA = { -- !! COMPILA !!
          commander = "nfacom",
          T1 = { extractor = { name = "nfa_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="nfa_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="nfa_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="nfa_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="nfa_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="nfa_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "nfa_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="nfa_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="nfa_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="nfa_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="nfa_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="nfa_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="nfa_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="nfa_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="nfa_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="nfa_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      },
       AND = { -- !! COMPILA !!
          commander = "andcom",
          T1 = { extractor = { name = "and_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="and_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="and_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="and_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="and_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="and_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "and_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="and_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="and_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="and_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="and_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="and_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="and_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="and_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="and_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="and_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      },
      EUF = { -- !! COMPILA !!
          commander = "eufcd",
          T1 = { extractor = { name = "euf_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="euf_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="euf_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="euf_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="euf_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="euf_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "euf_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="euf_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="euf_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="euf_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="euf_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="euf_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="euf_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="euf_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="euf_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="euf_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      }
      -- Non serve sezione common se tutto è per fazione/tier
  }

  -- Mappa Comandante -> Fazione
  local commanderFactionMap = {
      icucom = "ICU",
      nfacom = "NFA",
      andcom = "AND",
      eufcd  = "EUF"
  }

  -- Funzione ricorsiva per popolare gli UnitDefID e altri dati
  local function PopulateUnitDefIDs(dataTable, idTable)
      for key, value in pairs(dataTable) do
          if type(value) == "table" then
              if value.name and value.moveType then -- Definizione di unità singola
                  local unitDef = UnitDefNames[value.name]
                  if unitDef then
                      idTable[key] = {}
                      for k,v in pairs(value) do idTable[key][k]=v end
                      idTable[key].id = unitDef.id
                  else
                      Log(nil, "ERROR: Unit definition name '" .. value.name .. "' not found for key '" .. key .. "'!")
                      idTable[key] = nil
                  end
              elseif key == "attackers" or key == "defenses" then -- Lista di unità
                  idTable[key] = {}
                  for i, unitData in ipairs(value) do
                      if unitData.name and unitData.moveType then
                          local unitDef = UnitDefNames[unitData.name]
                          if unitDef then
                              local newItem = {}
                              for k,v in pairs(unitData) do newItem[k]=v end
                              newItem.id = unitDef.id
                              table.insert(idTable[key], newItem)
                          else
                              Log(nil, "ERROR: Unit definition name '" .. unitData.name .. "' not found in list '" .. key .. "'!")
                          end
                      end
                  end
              elseif key ~= "_unitDefIDs" then -- Sotto-tabella (T1, T2, T3)
                  if not idTable[key] then idTable[key] = {} end
                  PopulateUnitDefIDs(value, idTable[key])
              end
          end
      end
  end

  -- === 2. DEFINIZIONE CATEGORIE MAPPE ===
  local mapCategories = {
      ["zoty outpost"] = "LAND",
      ["altra_mappa_terra"] = "LAND",
      ["mappa_isole_1"] = "NAVAL_ISLANDS",
      ["arcadia bay"] = "NAVAL_ISLANDS",
      ["spazio_profondo_x"] = "SPACE",
      ["oceano_infinito"] = "NAVAL_PURE",
      -- ... aggiungi tutte le tue mappe ...
  }
  local currentMapCategory = "LAND" -- Default

  -- === 4. CONFIGURAZIONE AI PER TECH LEVEL ===
  local aiConfig = {
      [0] = {
          economyTargets = {
              { role = "T1_Extractor", min = 1, max = 2 },
              { role = "T1_PowerPlant", min = 1, max = 2 },
          },
          factoryTargets = { minTotal = 1, maxTotal = 1, targetTier = 1 },
          productionList = { },
          attackGroup = { min = 5, max = 8, target = "PATROL_NEARBY" }
      },
      [1] = {
          economyTargets = {
              { role = "T1_Extractor", min = 2, max = 3 },
              { role = "T1_PowerPlant", min = 2, max = 3 },
              -- { role = "T2_Extractor", min = 1, max = 1 },
              -- { role = "T2_PowerPlant", min = 1, max = 2 },
          },
          factoryTargets = { minTotal = 2, maxTotal = 3, targetTier = 1 },
          productionList = {
              { role = "T1_Constructor", priority = 100, max = 3 },
              { role = "T1_Attacker_Basic", priority = 80, max = 0 },
          },
          attackGroup = { min = 8, max = 12, target = "ATTACK_ENEMY_EXPANSION" }
      },
      [2] = {
          economyTargets = {
              { role = "T1_Extractor", min = 6, max = 8 },
              { role = "T1_PowerPlant", min = 8, max = 12 },
              { role = "T2_Extractor", min = 3, max = 5 },
              { role = "T2_PowerPlant", min = 4, max = 6 },
          },
          factoryTargets = { minTotal = 3, maxTotal = 5, targetTier = 2 },
          productionList = {
               { role = "T2_Constructor", priority = 100, max = 2 },
               { role = "T2_Attacker_Heavy", priority = 80, max = 0 },
               { role = "T1_Attacker_Basic", priority = 60, max = 0 },
          },
          attackGroup = { min = 10, max = 15, target = "ATTACK_ENEMY_BASE" }
      },
      [3] = {
          economyTargets = {
              { role = "T2_Extractor", min = 5, max = 8 },
              { role = "T2_PowerPlant", min = 6, max = 10 },
              -- { role = "T3_Extractor", min = 2, max = 4 },
              -- { role = "T3_PowerPlant", min = 3, max = 5 },
          },
          factoryTargets = { minTotal=4, maxTotal=7, targetTier=3 },
          productionList = {
             -- { role = "T3_Constructor", priority = 100, max = 1 },
             { role = "T3_Attacker_Experimental", priority = 90, max = 3 },
             { role = "T2_Attacker_Heavy", priority = 70, max = 0 },
          },
          attackGroup = { min = 12, max = 20, target = "ATTACK_ENEMY_BASE_PRIORITY" }
      }
  }

  -- === Funzioni Helper ===

  -- Helper: GetUnitDataByRole - Versione che gestisce eco tiered
  function GetUnitDataByRole(faction, tier, role)
      local factionData = factionUnits[faction]
      if not factionData then return nil end
      local fDefs = factionData._unitDefIDs
      if not fDefs then return nil end

      local roleTier = tonumber(role:match("^T(%d+)")) or 0
      if roleTier == 0 then return nil end

      local tierKey = "T" .. roleTier
      local tDefs = fDefs[tierKey]
      if not tDefs then return nil end

      if role == tierKey .. "_Constructor" then return tDefs.constructor
      elseif role == tierKey .. "_Factory" then return tDefs.factory
      elseif role == tierKey .. "_Extractor" then return tDefs.extractor
      elseif role == tierKey .. "_PowerPlant" then return tDefs.powerPlant
      elseif role:find(tierKey .. "_Attacker") then
          if not tDefs.attackers or #tDefs.attackers == 0 then return nil end
          if role == tierKey .. "_Attacker_Basic" then return tDefs.attackers[1]
          elseif role == tierKey .. "_Attacker_Heavy" then return tDefs.attackers[1]
          elseif role == tierKey .. "_Attacker_Support" then return #tDefs.attackers >= 2 and tDefs.attackers[2] or nil
          elseif role == tierKey .. "_Attacker_Experimental" then return tDefs.attackers[1]
          else return tDefs.attackers[1] end
      elseif role:find(tierKey .. "_Defense") then
           if not tDefs.defenses or #tDefs.defenses == 0 then return nil end
           if role == tierKey .. "_Defense_Light" then return tDefs.defenses[1]
           elseif role == tierKey .. "_Defense_Heavy" then return #tDefs.defenses >= 2 and tDefs.defenses[2] or nil
           else return tDefs.defenses[1] end
      end

      -- Log(faction, "Warning: Role '"..role.."' could not be mapped.")
      return nil
  end

   -- Trova posizione Metallo - Aggiornato per leggere direttamente da GameRules (Fallback Definitivo per v100)
  function FindBestMetalSpotForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then Log(teamData.teamID, "FindBestMetalSpot: Builder position not found."); return nil end

      -- === LEGGI DIRETTAMENTE DALLE GAMERULES ===
      local mexCount = Spring.GetGameRulesParam("mex_count")
      -- ========================================

      local bestSpot = nil
      local minDistSq = math.huge
      local mexDefData = GetUnitDataByRole(teamData.faction, 1, "T1_Extractor")
      if not mexDefData then Log(teamData.teamID,"FindBestMetalSpot: Cannot find T1_Extractor definition!"); return nil end
      local mexDefID = mexDefData.id

      -- Itera usando i dati letti dalle GameRules
      if mexCount and mexCount > 0 then
           Log(teamData.teamID, "FindBestMetalSpot: Found " .. mexCount .. " metal spots in GameRules.") -- Debug
          for i = 1, mexCount do
               -- Leggi i dati per questo spot dalle GameRules
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotY = Spring.GetGameRulesParam("mex_y" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)

               -- Controlla se abbiamo ottenuto coordinate valide
               if spotX and spotY and spotZ then
                   -- Controlla se è occupato
                   local unitsNear = Spring.GetUnitsInRectangle(spotX-10, spotZ-10, spotX+10, spotZ+10)
                   local occupied = false
                   if unitsNear then
                       for _, nearID in ipairs(unitsNear) do
                           local nearDef = UnitDefs[Spring.GetUnitDefID(nearID)]
                           if nearDef and nearDef.extractsMetal and nearDef.extractsMetal > 0 then occupied = true; break end
                       end
                   end

                   if not occupied then
                      -- Controlla costruibilità usando TestBuildOrder
                      local buildResult = Spring.TestBuildOrder(mexDefID, spotX, spotY, spotZ, 1)
                      if buildResult == 0 or buildResult == 2 then
                          local dx, dz = spotX - bx, spotZ - bz
                          local distSq = dx*dx + dz*dz
                          if distSq < minDistSq then
                              minDistSq = distSq
                              bestSpot = {x=spotX, y=spotY, z=spotZ}
                          end
                       else Log(teamData.teamID, "Spot "..i.." not buildable, code: "..buildResult) -- Debug Build Fail
                      end
                    else Log(teamData.teamID, "Spot "..i.." occupied.") -- Debug Occupied
                   end
               else
                   Log(teamData.teamID, "FindBestMetalSpot: Warning - Got nil coordinate reading GameRules for mex index " .. i)
               end -- fine if spotX/Y/Z
          end -- fine ciclo for i=1, mexCount
      else
          Log(teamData.teamID, "FindBestMetalSpot: Could not find 'mex_count' or it was 0 in GameRules.")
      end -- fine if mexCount

      if bestSpot then Log(teamData.teamID,"Found best metal spot at " .. string.format("%.0f,%.0f", bestSpot.x, bestSpot.z) .. " using GameRules")
      else Log(teamData.teamID,"FindBestMetalSpot: No suitable metal spot found after checking GameRules.") end
      return bestSpot
  end

  -- Trova posizione Energia - Usa TestBuildOrder
  function FindGoodEnergySpotForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then return nil end
      local powerDefData = GetUnitDataByRole(teamData.faction, 1, "T1_PowerPlant")
      if not powerDefData then Log(teamData.teamID,"FindGoodEnergySpot: Cannot find T1_PowerPlant definition!"); return nil end
      local powerDefID = powerDefData.id

      for i=1, 20 do
          local angle = math.random() * 2 * math.pi
          local dist = 80 + math.random(120)
          local testX, testZ = bx + math.cos(angle)*dist, bz + math.sin(angle)*dist
          local testY = Spring.GetGroundHeight(testX, testZ)
          if testY then
              local buildResult = Spring.TestBuildOrder(powerDefID, testX, testY, testZ, 1)
              if buildResult == 0 or buildResult == 2 then
                  -- Log(teamData.teamID,"Found good energy spot at ...")
                  return { x=testX, y=testY, z=testZ }
              end
          end
      end
      -- Log(teamData.teamID,"Could not find good energy spot near builder.")
      return nil
  end

  -- Trova posizione Fabbrica - Usa TestBuildOrder
  function FindGoodFactoryPosForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then return nil end
      local targetTier = teamData.techLevel + 1
      if targetTier > 3 then targetTier = 3 end
      local factoryDefData = GetUnitDataByRole(teamData.faction, targetTier, "T"..targetTier.."_Factory")
      if not factoryDefData then Log(teamData.teamID,"FindGoodFactoryPos: Cannot find Factory T"..targetTier.." definition!"); return nil end
      local factoryDefID = factoryDefData.id

      for i=1, 20 do
          local angle = math.random() * 2 * math.pi
          local dist = 150 + math.random(150)
          local testX, testZ = bx + math.cos(angle)*dist, bz + math.sin(angle)*dist
          local testY = Spring.GetGroundHeight(testX, testZ)
          if testY then
              local buildResult = Spring.TestBuildOrder(factoryDefID, testX, testY, testZ, 1)
              if buildResult == 0 or buildResult == 2 then
                  -- Log(teamData.teamID,"Found good factory spot at ...")
                  return { x=testX, y=testY, z=testZ }
              end
          end
      end
       -- Log(teamData.teamID,"Could not find good factory spot near builder.")
      return nil
  end

  -- Funzione per controllare un team e trovare comandante/fazione
  local function CheckTeamCommander(teamID)
      if not teamData[teamID] or teamData[teamID].faction then return end
      local teamUnits = Spring.GetTeamUnits(teamID)
      if not teamUnits then return end
      for _, unitID in ipairs(teamUnits) do
          local unitDefID = Spring.GetUnitDefID(unitID)
          if unitDefID then
              local unitDef = UnitDefs[unitDefID]
              if unitDef then
                  local commanderNameLower = unitDef.name:lower()
                  local faction = commanderFactionMap[commanderNameLower]
                  if faction then
                      local commanderName = unitDef.name:upper()
                      Log(teamID, "Found Commander: " .. commanderName .. " - Faction set to: " .. faction)
                      teamData[teamID].faction = faction
                      teamData[teamID].commanderInfo = { name = commanderName, id = unitID, defID = unitDefID }
                      local comMoveType = UnitDefs[unitDefID].movedata and UnitDefs[unitDefID].movedata.moveType or "UNKNOWN"
                      teamData[teamID].constructors[unitID] = { tier = 0, state = "idle", task = nil, moveType = comMoveType }
                      return
                  end
              end
          end
      end
      if not teamData[teamID].faction and Game.frame > 90 then
          Log(teamID, "WARNING: Could not find starting commander/faction unit after 3 seconds!")
          teamData[teamID].faction = "UNKNOWN"
      end
  end

  -- === 3. LOGICA AVANZAMENTO TECNOLOGICO ===
  local function ManageTechLevel(teamID, frame)
      local data = teamData[teamID]
      if not data or not data.faction or data.faction == "UNKNOWN" or data.techLevel == nil then return end
      local currentLevel = data.techLevel
      local res = data.resourceInfo
      local thresholds = {
          [1] = { metal = 400, energy = 400, prereq = function() return true end },
          [2] = { metal = 2000, energy = 4000, prereq = function() return data:HasFactoryOfTier(1) end },
          [3] = { metal = 8000, energy = 15000, prereq = function() return data:HasFactoryOfTier(2) end }
      }
      local nextLevel = currentLevel + 1
      if thresholds[nextLevel] and currentLevel < 3 then
          local target = thresholds[nextLevel]
          local prereqMet, _ = pcall(target.prereq)
          if prereqMet and (res.metal and res.energy and res.metal >= target.metal and res.energy >= target.energy) then
              data.techLevel = nextLevel
              Log(teamID, "Advanced to Tech Level " .. nextLevel .. "!")
              -- Resetta obiettivi economici quando si sale di livello per ricalcolarli
              data.economyObjectives = {}
              Log(teamID,"Economy objectives reset for new tech level.")
          end
      end
  end

  -- Helper per fabbriche
  function TeamHasFactoryOfTier(teamData, tier)
      local faction = teamData.faction
      if not faction or faction == "UNKNOWN" then return false end
      local targetFactoryData = GetUnitDataByRole(faction, tier, "T"..tier.."_Factory")
      if not targetFactoryData then return false end
      local factories = Spring.GetTeamUnitsByDefs(teamData.teamID, targetFactoryData.id)
      return (factories and #factories > 0)
  end

  -- Funzioni di Gestione Principali
  local function UpdateResourceInfo(teamID, frame)
      local data = teamData[teamID]
      if not data then return end
      if frame - (data.resourceInfo.lastUpdateFrame or -100) > 30 then
          data.resourceInfo.metal, data.resourceInfo.energy = Spring.GetTeamResources(teamID, "metal", "energy")
          local metIncomeOk, metIncome = pcall(Spring.GetTeamResourceIncome, teamID, "metal")
          local metUsageOk, metUsage = pcall(Spring.GetTeamResourceUsage, teamID, "metal")
          local engIncomeOk, engIncome = pcall(Spring.GetTeamResourceIncome, teamID, "energy")
          local engUsageOk, engUsage = pcall(Spring.GetTeamResourceUsage, teamID, "energy")
          data.resourceInfo.metalIncome = (metIncomeOk and metIncome) or 0
          data.resourceInfo.metalUsage = (metUsageOk and metUsage) or 0
          data.resourceInfo.energyIncome = (engIncomeOk and engIncome) or 0
          data.resourceInfo.energyUsage = (engUsageOk and engUsage) or 0
          data.resourceInfo.lastUpdateFrame = frame
      end
  end

  local function ManageEconomy(teamID, frame)
      local data = teamData[teamID]
      if not data or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config or not config.economyTargets then return end

      local res = data.resourceInfo
      local currentEnergyIncome = res.energyIncome or 0
      local currentEnergyUsage = res.energyUsage or 0
      local energyBalance = currentEnergyIncome - currentEnergyUsage
      local desiredEnergySurplus = 15 -- Potresti abbassare leggermente questa, es. 10 o 5
      local prioritizeEnergy = (energyBalance < desiredEnergySurplus)

      local orderGivenThisFrame = false -- Flag per dare solo un ordine per ciclo

      -- 1. Controlla PRIMA se dobbiamo costruire ENERGIA (se prioritaria o no)
      local powerTargetConfig = nil
      local targetPowerRole = (data.techLevel >= 2 and GetUnitDataByRole(data.faction, 2, "T2_PowerPlant") and "T2_PowerPlant") or "T1_PowerPlant" -- Cerca T2 se possibile, altrimenti T1

      for _, target in ipairs(config.economyTargets) do
          if target.role == targetPowerRole then
              powerTargetConfig = target; break
          end
      end

      if powerTargetConfig then
          local roleTier = tonumber(targetPowerRole:match("^T(%d+)")) or 1
          local unitData = GetUnitDataByRole(data.faction, roleTier, targetPowerRole)
          if unitData then
              local unitDefID = unitData.id; local unitDef = UnitDefs[unitDefID]
              if unitDef then
                  -- Determina l'obiettivo numerico random per le centrali
                  if not data.economyObjectives[targetPowerRole] then
                      data.economyObjectives[targetPowerRole] = { targetCount = math.random(powerTargetConfig.min, powerTargetConfig.max), reached = false }
                      Log(teamID, "New Economy Objective for " .. targetPowerRole .. ": Build " .. data.economyObjectives[targetPowerRole].targetCount)
                  end
                  local currentObjective = data.economyObjectives[targetPowerRole]
                  local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)

                  if currentCount < currentObjective.targetCount then
                      if data:CanAfford(unitDefID, frame) then
                          -- Se l'energia è prioritaria OPPURE se semplicemente ne servono di più (sotto obiettivo)
                          if prioritizeEnergy or (not currentObjective.reached) then
                              local builderTier = math.max(0, roleTier - 1)
                              local builderID = data:FindIdleConstructor(builderTier)
                              if builderID then
                                  local buildPos = data:FindGoodEnergySpot(builderID)
                                  if buildPos then
                                      Log(teamID, ">>>>>> Ordering T"..builderTier.." builder "..builderID.." to build "..targetPowerRole.." #"..(currentCount+1).."/"..currentObjective.targetCount.. (prioritizeEnergy and " (PRIORITY)" or ""))
                                      Spring.GiveOrderToUnit(builderID, -unitDefID, { buildPos.x, buildPos.y, buildPos.z }, {})
                                      if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                                      orderGivenThisFrame = true -- Segna che abbiamo dato un ordine
                                      -- NON USCIRE SUBITO, potremmo voler costruire metallo se non era priorità energia
                                  end
                              end
                          end
                      elseif currentCount >= currentObjective.targetCount and not currentObjective.reached then
                           -- Log(teamID, "Economy Objective for " .. targetPowerRole .. " reached.")
                           currentObjective.reached = true
                      end
                  elseif not currentObjective.reached then -- Marcala come raggiunta se >= target
                      -- Log(teamID, "Economy Objective for " .. targetPowerRole .. " already met or exceeded.")
                      currentObjective.reached = true
                  end
              end
          end
      end

      -- 2. Se NON abbiamo dato un ordine per l'energia O l'energia non era prioritaria, controlla ALTRI obiettivi (Estrattori)
      if not orderGivenThisFrame then
          for i, targetConfig in ipairs(config.economyTargets) do
              -- Salta le centrali, le abbiamo già considerate
              if not targetConfig.role:find("PowerPlant") then
                  local role = targetConfig.role
                  local minCount = targetConfig.min; local maxCount = targetConfig.max

                  if not data.economyObjectives[role] then
                      local targetNum = math.random(minCount, maxCount)
                      data.economyObjectives[role] = { targetCount = targetNum, reached = false }
                      Log(teamID, "New Economy Objective for " .. role .. ": Build " .. targetNum)
                  end
                  local currentObjective = data.economyObjectives[role]

                  if not currentObjective.reached then
                      local roleTier = tonumber(role:match("^T(%d+)")) or 1
                      local unitData = GetUnitDataByRole(data.faction, roleTier, role)
                      if unitData then
                          local unitDefID = unitData.id; local unitDef = UnitDefs[unitDefID]
                          if unitDef then
                              local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)
                              if currentCount < currentObjective.targetCount then
                                  if data:CanAfford(unitDefID, frame) then
                                      local builderTier = math.max(0, roleTier - 1)
                                      local builderID = data:FindIdleConstructor(builderTier)
                                      if builderID then
                                          local buildPos = nil
                                          if role:find("Extractor") then buildPos = data:FindBestMetalSpot(builderID) end
                                          if buildPos then
                                              Log(teamID, ">>>>>> Ordering builder "..builderID.." to build "..role.." #"..(currentCount+1).."/"..currentObjective.targetCount)
                                              Spring.GiveOrderToUnit(builderID, -unitDefID, { buildPos.x, buildPos.y, buildPos.z }, {})
                                              if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                                              orderGivenThisFrame = true -- Abbiamo dato un ordine
                                              -- Esci dal ciclo interno DOPO aver dato un ordine per altri edifici
                                              break
                                          end
                                      end
                                  end
                              elseif currentCount >= currentObjective.targetCount then
                                  -- Log(teamID, "Economy Objective for " .. role .. " reached.")
                                  currentObjective.reached = true
                              end
                          end
                      end
                  end
              end -- fine if not PowerPlant
          end -- fine for altri obiettivi
      end -- fine if not orderGivenThisFrame
  end -- Fine ManageEconomy

  -- ManageProduction con correzione ordine fabbrica
  local function ManageProduction(teamID, frame)
      local data = teamData[teamID]
      if not data or not data.faction or data.faction == "UNKNOWN" or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config then return end

      local faction = data.faction
      local techLevel = data.techLevel
      local allowedMoveTypes = {}
      if currentMapCategory == "LAND" then allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true, BUILDING = true }
      elseif currentMapCategory == "NAVAL_ISLANDS" then allowedMoveTypes = { NAVAL = true, AIR = true, BUILDING = true }
      elseif currentMapCategory == "SPACE" then allowedMoveTypes = { AIR = true, SPACE = true, BUILDING = true }
      elseif currentMapCategory == "NAVAL_PURE" then allowedMoveTypes = { NAVAL = true, BUILDING = true }
      end

      -- 1. Costruire Fabbriche?
      if config.factoryTargets then
          local totalFactories = 0
          for tier=1, data.techLevel + 1 do
              local facData = GetUnitDataByRole(faction, tier, "T"..tier.."_Factory")
              if facData then totalFactories = totalFactories + #Spring.GetTeamUnitsByDefs(teamID, facData.id) end
          end

          if totalFactories < config.factoryTargets.minTotal then
              local targetTier = config.factoryTargets.targetTier
              local factoryData = GetUnitDataByRole(faction, targetTier, "T"..targetTier.."_Factory")
              if factoryData and allowedMoveTypes[factoryData.moveType] then
                   if data:CanAfford(factoryData.id, frame) then
                       local builderID = data:FindIdleConstructor(targetTier - 1)
                       if builderID then
                           local buildPos = data:FindGoodFactoryPos(builderID)
                           if buildPos then
                               Log(teamID, "Ordering T"..(targetTier-1).." builder " .. builderID .. " to build T"..targetTier.." factory ("..factoryData.name..") at " .. string.format("%.0f,%.0f", buildPos.x, buildPos.z))
                               Spring.GiveOrderToUnit(builderID, -factoryData.id, { buildPos.x, buildPos.y, buildPos.z }, {})
                               if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                               return
                           end
                       end
                   end
              end
          end
      end -- Fine costruzione fabbriche

      -- 2. Produrre Unità dalle Fabbriche Esistenti
      if config.productionList then
          local sortedProdList = {}
          for _, item in ipairs(config.productionList) do table.insert(sortedProdList, item) end
          table.sort(sortedProdList, function(a,b) return a.priority > b.priority end)

          for factoryTier = 1, data.techLevel do
              local factoryData = GetUnitDataByRole(faction, factoryTier, "T"..factoryTier.."_Factory")
              if factoryData then
                  local factories = Spring.GetTeamUnitsByDefs(teamID, factoryData.id)
                  if factories then
                      for _, factoryID in ipairs(factories) do
                          local orderGivenToThisFactory = false
                          local queue = Spring.GetFactoryCommands(factoryID)
                          if not queue or #queue < 3 then
                              for _, prodItem in ipairs(sortedProdList) do
                                  local unitTier = tonumber(prodItem.role:match("T(%d+)")) or 0
                                  if unitTier <= factoryTier then
                                      local unitData = GetUnitDataByRole(faction, unitTier, prodItem.role)
                                      if unitData and allowedMoveTypes[unitData.moveType] then
                                          local unitDefID = unitData.id
                                          local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)
                                          local maxCount = prodItem.max
                                          local buildThis = false
                                          if prodItem.role:find("Constructor") then
                                               if data:NeedsConstructor(unitTier) then buildThis = true end
                                          elseif maxCount == 0 or currentCount < maxCount then
                                               buildThis = true
                                          end
                                          if buildThis and data:CanAfford(unitDefID, frame) then
                                              Log(teamID, "Ordering T"..factoryTier.." factory " .. factoryID .. " to build "..prodItem.role.." (DefID "..unitDefID..")")
                                              Spring.GiveOrderToUnit(factoryID, -unitDefID, {}, {})
                                              orderGivenToThisFactory = true
                                              break
                                          end
                                      end
                                  end
                              end
                          end
                      end
                  end
              end
          end
      end
  end -- Fine ManageProduction


 
 
 
    local function ManageMilitary(teamID, frame)
      local data = teamData[teamID]
      -- Controllo 1: Dati base OK?
      if not data or data.techLevel == nil then
          Log(teamID, "ManageMilitary: Skipping - No data or techLevel is nil") -- Log Debug Aggiunto
          return
      end

      -- === Log Debug TechLevel PRIMA di accedere a aiConfig ===
      Log(teamID,"ManageMilitary: Checking TechLevel = " .. tostring(data.techLevel) .. ", Type: " .. type(data.techLevel))
      -- ======================================================

      -- Controllo 2: config per questo techLevel esiste?
      local config = aiConfig[data.techLevel]
      if not config or not config.attackGroup then
          Log(teamID,"ManageMilitary: Skipping - No config or attackGroup found for T" .. tostring(data.techLevel)) -- Log Debug Aggiunto
          return
      end
      Log(teamID, "ManageMilitary: Config found for T" .. data.techLevel) -- Conferma che siamo passati

      local allowedMoveTypes = {}
      if currentMapCategory == "LAND" then allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true }
      elseif currentMapCategory == "NAVAL_ISLANDS" then allowedMoveTypes = { NAVAL = true, AIR = true }
      elseif currentMapCategory == "SPACE" then allowedMoveTypes = { AIR = true, SPACE = true }
      elseif currentMapCategory == "NAVAL_PURE" then allowedMoveTypes = { NAVAL = true }
      end

      local idleCombatUnits = {}
      local idleCount = 0
      for unitID, unitData in pairs(data.combatUnits) do
          if Spring.ValidUnitID(unitID) and unitData.state == "idle" and allowedMoveTypes[unitData.moveType] then
              local cmds = Spring.GetUnitCommands(unitID)
              if not cmds or #cmds == 0 then
                  table.insert(idleCombatUnits, unitID)
                  idleCount = idleCount + 1
              -- else Log(teamID,"Unit "..unitID.." has state idle but has commands?")
              end
          end
      end
      Log(teamID, "ManageMilitary: Found " .. idleCount .. " idle combat units suitable for map.") -- Debug: Quante ne conta?

      -- Controllo 5: Soglia minima raggiunta?
      if idleCount >= config.attackGroup.min then
          Log(teamID,"ManageMilitary: Idle count ("..idleCount..") >= min ("..config.attackGroup.min.."). Forming group.") -- Debug: Entra qui?
          local groupSize = math.min(idleCount, config.attackGroup.max)
          local attackGroup = {}
          for i = 1, groupSize do
              local unitID = table.remove(idleCombatUnits, 1) -- Prende e rimuove dalla lista idle
              table.insert(attackGroup, unitID)
              -- NON impostare lo stato qui, fallo solo se l'ordine viene dato con successo
              -- if data.combatUnits[unitID] then data.combatUnits[unitID].state = "attacking" end
          end

          -- === Log Debug PRIMA di accedere a config.attackGroup.target ===
          Log(teamID,"ManageMilitary DEBUG: Before accessing target - Type of config: "..type(config).." | config.attackGroup exists: "..tostring(config.attackGroup ~= nil))
          if type(config) == "table" and config.attackGroup then -- Aggiunto controllo tipo config
              Log(teamID,"ManageMilitary DEBUG: config.attackGroup.target value: "..tostring(config.attackGroup.target))
          end
          -- =============================================================

          -- Riga ~661 che POTREBBE causare l'errore se i controlli sopra fallissero
          local targetType = config.attackGroup.target or "ATTACK_ENEMY_BASE"

          -- Trova Nemico
          local enemyTeamID = nil
          local gaiaTeamID = Spring.GetGaiaTeamID()
          local allTeams = Spring.GetTeamList()
          local potentialEnemies = {}
          if allTeams then
              for _, otherTeamID in ipairs(allTeams) do
                  if otherTeamID ~= teamID and otherTeamID ~= gaiaTeamID and not Spring.AreTeamsAllied(teamID, otherTeamID) then
                      if Spring.GetTeamUnitCount(otherTeamID) > 0 then
                         table.insert(potentialEnemies, otherTeamID)
                      end
                  end
              end
          end
          if #potentialEnemies > 0 then enemyTeamID = potentialEnemies[math.random(#potentialEnemies)] end
          Log(teamID,"ManageMilitary DEBUG: Found enemy target: "..tostring(enemyTeamID)) -- Debug: Trova nemico?

          local targetPos = nil -- Resetta targetPos
          local orderIssued = false -- Flag per sapere se abbiamo dato un ordine

          -- Se abbiamo un nemico E il piano è attaccare...
          if enemyTeamID and
             (targetType == "ATTACK_ENEMY_BASE" or
              targetType == "ATTACK_ENEMY_EXPANSION" or
              targetType == "ATTACK_ENEMY_BASE_PRIORITY")
          then
              -- Log(teamID,"ManageMilitary DEBUG: Condition to ATTACK enemy met.") -- Debug: Entra qui?
              local tx, ty, tz = Spring.GetTeamStartPosition(enemyTeamID)
              if tx then
                  targetPos = { tx, ty, tz }
                  Log(teamID, "Sending group of " .. groupSize .. " to ATTACK ENEMY (" .. enemyTeamID .. ") BASE at " .. string.format("%.0f,%.0f",tx,tz) )
                  local commandToUse = CMD.ATTACK -- Prova questo
                  -- local CMD_ATTACK_ID = 20 -- Fallback
                  for i, unitID in ipairs(attackGroup) do
                      Spring.GiveOrderToUnit(unitID, commandToUse, targetPos, {})
                      if data.combatUnits[unitID] then data.combatUnits[unitID].state = "attacking" end -- Imposta stato DOPO ordine
                      -- ... (log comandi unità se necessario) ...
                  end
                  orderIssued = true -- Segna che l'ordine è stato dato
              else
                   Log(teamID, "Could not get start position for enemy team " .. enemyTeamID)
                   targetPos = nil -- Assicura che targetPos sia nil se non troviamo coordinate
              end
          -- Altrimenti, se il piano è pattugliare...
          elseif targetType == "PATROL_NEARBY" then
               -- Log(teamID,"ManageMilitary DEBUG: Condition to PATROL met.") -- Debug: Entra qui?
               local angle = math.random() * 2 * math.pi
               local dist = 1000 + math.random(500)
               targetPos = { data.startPos.x + math.cos(angle)*dist, data.startPos.y, data.startPos.z + math.sin(angle)*dist }
               Log(teamID, "Sending group of " .. groupSize .. " to PATROL NEARBY")
               local CMD_PATROL_ID = 15
               Spring.GiveOrderToUnitArray(attackGroup, CMD_PATROL_ID, targetPos, {"SHIFT"})
               -- Imposta stato a pattuglia (o attacking?) per le unità inviate
               for _, unitID in ipairs(attackGroup) do
                   if data.combatUnits[unitID] then data.combatUnits[unitID].state = "patrolling" end -- Stato nuovo?
               end
               orderIssued = true -- Segna che l'ordine è stato dato
          end

          -- Se non siamo riusciti a dare un ordine valido (o non c'era un piano/nemico)
          if not orderIssued then
              Log(teamID, "Could not find target or issue order for attack group, setting units back to idle.")
              -- Rimetti nello stato idle le unità che avevamo messo nel gruppo ma a cui non abbiamo dato ordini
              for _, unitID in ipairs(attackGroup) do
                  if data.combatUnits[unitID] then
                      data.combatUnits[unitID].state = "idle"
                  end
              end
          end
      else
          -- Log(teamID,"ManageMilitary: Idle count ("..idleCount..") < min ("..config.attackGroup.min..")") -- Debug: Non attacca per poche unità
      end
  end -- Fine ManageMilitary
  
  
  
  
 
 
 
 

  -- Helper: Trova costruttore idle di tier minimo
  function FindIdleConstructorForTeam(teamData, minTier)
      minTier = minTier or 0
      local foundBuilderID = nil
      for builderID, builderData in pairs(teamData.constructors) do
          if Spring.ValidUnitID(builderID) and builderData.tier >= minTier then
              local commands = Spring.GetUnitCommands(builderID)
              if (not commands or #commands == 0) then
                  foundBuilderID = builderID
                  break
              end
          end
      end
      return foundBuilderID
  end

  -- Helper: Controlla se servono costruttori T[N]
  function TeamNeedsConstructor(teamData, tier)
      local count = 0
      for unitID, builderData in pairs(teamData.constructors) do
          if Spring.ValidUnitID(unitID) and builderData.tier == tier then
              count = count + 1
          end
      end
      local limit = (tier == 0) and 1 or 2
      return count < limit
  end

  -- Helper: Controlla se l'AI può permettersi un'unità (v8 - Bypass T1 Eco Deficit a T0)
  function CanAffordUnit(teamData, unitDefID, frame)
      if not unitDefID then return false end
      local uDef = UnitDefs[unitDefID]
      if not uDef then return false end

      local costMetal = uDef.metalCost or 0
      local costEnergy = uDef.energyCost or 0
      local maintenanceEnergy = uDef.energyUpkeep or 0 -- == energyUse per molti edifici
      local makesEnergy = uDef.energyMake or 0

      local res = teamData.resourceInfo

      if type(res.metal) ~= "number" or type(res.energy) ~= "number" then return false end

      local buffer = 50
      local hasStorage = (res.metal >= costMetal + buffer and
                          res.energy >= costEnergy + buffer)

      if not hasStorage then
          -- Log(teamData.teamID,"Cannot afford "..uDef.humanName..": Storage Low")
          return false
      end

      -- === Bypass per T1 Eco a Tech Level 0 ===
      local isT1EcoBuilding = false
      local t1ExtractorData = GetUnitDataByRole(teamData.faction, 1, "T1_Extractor")
      local t1PowerData = GetUnitDataByRole(teamData.faction, 1, "T1_PowerPlant")
      if (t1ExtractorData and unitDefID == t1ExtractorData.id) or (t1PowerData and unitDefID == t1PowerData.id) then
          isT1EcoBuilding = true
      end

      if teamData.techLevel == 0 and isT1EcoBuilding then
          -- Log(teamData.teamID,"CanAffordUnit: Allowing T1 Eco building at T0 based on storage only.")
          return true -- Permetti costruzione T1 Eco a T0 se c'è storage
      end
      -- ========================================

      -- Per T1+ O unità non-T1-Eco, applica controllo bilancio energetico
      if teamData.techLevel >= 1 or not isT1EcoBuilding then
          local currentEnergyIncome = res.energyIncome or 0
          local currentEnergyUsage = res.energyUsage or 0
          local futureEnergyBalance = currentEnergyIncome - currentEnergyUsage - maintenanceEnergy

          if futureEnergyBalance < 0 then
              if makesEnergy > 0 then -- Ok per centrali
              else
                  local isSurplusNow = currentEnergyIncome > currentEnergyUsage
                  -- Riduciamo la soglia storage richiesta per procedere in deficit
                  local hasEnoughStorageForDeficit = res.energy > costEnergy * 1.5 -- Usa 1.5x invece di 5x

                  if not (isSurplusNow or hasEnoughStorageForDeficit) then
                     -- Log(teamData.teamID,"Cannot afford "..uDef.humanName..": Would cause UNMANAGEABLE energy deficit")
                     return false
                  -- else
                     -- Log(teamData.teamID,"Warning: Building "..uDef.humanName.." might cause manageable energy deficit, proceeding")
                  end
              end
          end
      end

      return true
  end

  --------------------------------------------------------------------------------
  -- GADGET EVENT HANDLERS (SYNCED)
  --------------------------------------------------------------------------------

  function gadget:Initialize()
      Log(nil, gadget:GetInfo().name .. " Initializing...")
      for faction, data in pairs(factionUnits) do
          if faction ~= "common" and faction ~= "_commonUnitDefIDs" and faction ~= "_unitDefIDs" then
              Log(nil, "Populating UnitDefIDs for faction: " .. faction)
              factionUnits[faction]._unitDefIDs = {}
              PopulateUnitDefIDs(data, factionUnits[faction]._unitDefIDs)
          end
      end
      Log(nil, "UnitDefID population complete.")
  end

  function gadget:GameStart()
      Log(nil, gadget:GetInfo().name .. " Game Starting...")
      local mapNameRaw = Game.mapName
      local mapNameLower = mapNameRaw:lower()
      Log(nil, "Detected Map: '" .. mapNameRaw .. "' (Checking as: '" .. mapNameLower .. "')")
      if mapCategories[mapNameLower] then
          currentMapCategory = mapCategories[mapNameLower]
          Log(nil, "Map Category Assigned: '" .. currentMapCategory .. "' (Found in mapCategories table)")
      else
          Log(nil, "Map Category Assigned: '" .. currentMapCategory .. "' (Map not found in list, using default)")
      end
      local teams = Spring.GetTeamList()
      for _, teamID in ipairs(teams) do
          if Spring.GetTeamLuaAI(teamID) == gadget:GetInfo().name then
              Log(teamID, "Team detected for AI control.")
              local startX, startY, startZ = Spring.GetTeamStartPosition(teamID)
              teamData[teamID] = {
                  teamID = teamID, initialized = true, faction = nil, techLevel = 0,
                  commanderInfo = nil, startPos = { x = startX, y = startY, z = startZ },
                  constructors = {}, factories = {}, combatUnits = {}, buildings = {}, missions = {},
                  resourceInfo = { lastUpdateFrame = -100 },
                  economyObjectives = {}, -- Aggiunto per obiettivi random
                  HasFactoryOfTier = TeamHasFactoryOfTier,
                  FindIdleConstructor = FindIdleConstructorForTeam,
                  NeedsConstructor = TeamNeedsConstructor,
                  FindGoodFactoryPos = FindGoodFactoryPosForTeam,
                  CanAfford = CanAffordUnit,
                  FindBestMetalSpot = FindBestMetalSpotForTeam,
                  FindGoodEnergySpot = FindGoodEnergySpotForTeam,
                  NeedsBasicEconomy = function(self)
                        local mexCount=0; local powCount=0
                        local mexData = GetUnitDataByRole(self.faction, 1, "T1_Extractor")
                        local powData = GetUnitDataByRole(self.faction, 1, "T1_PowerPlant")
                        if mexData then mexCount = #Spring.GetTeamUnitsByDefs(self.teamID, mexData.id) end
                        if powData then powCount = #Spring.GetTeamUnitsByDefs(self.teamID, powData.id) end
                        local cfg = aiConfig[self.techLevel]
                        local needsMex = false; local needsPow = false
                        if cfg and cfg.economyTargets then
                           for _,t in ipairs(cfg.economyTargets) do
                              if t.role == "T1_Extractor" then needsMex = (mexCount < t.min); break end
                           end
                           for _,t in ipairs(cfg.economyTargets) do
                              if t.role == "T1_PowerPlant" then needsPow = (powCount < t.min); break end
                           end
                        end
                        return needsMex or needsPow
                  end,
              }
              CheckTeamCommander(teamID)
          end
      end
      gameStarted = true
      Log(nil, gadget:GetInfo().name .. " Game Started. Final Map Category: " .. currentMapCategory)
  end

  function gadget:GameFrame(frame)
    if not gameStarted then return end
    for teamID, data in pairs(teamData) do
      if data.initialized and data.faction and data.faction ~= "UNKNOWN" then
        if frame % 150 == (teamID * 15) % 150 then
            Log(teamID, "Current State - TechLevel: " .. data.techLevel .. " | Map: " .. currentMapCategory)
        end
        UpdateResourceInfo(teamID, frame)
        if frame % 45 == (teamID * 3) % 45 then ManageTechLevel(teamID, frame) end
        if frame % 61 == (teamID * 5) % 61 then ManageEconomy(teamID, frame) end
        if frame % 91 == (teamID * 7) % 91 then ManageProduction(teamID, frame) end
        if frame % 121 == (teamID * 9) % 121 then ManageMilitary(teamID, frame) end
      elseif data.initialized and not data.faction then
          if frame % 30 == 5 then CheckTeamCommander(teamID) end
      end
    end
  end

  function gadget:UnitFinished(unitID, unitDefID, unitTeam)
    if teamData[unitTeam] then
      local data = teamData[unitTeam]
      if not data.faction then return end
      local unitDef = UnitDefs[unitDefID]
      local faction = data.faction
      local foundType = nil; local unitData = nil;
      for tier = 1, 3 do
          local tierKey = "T"..tier
          local tierDefs = factionUnits[faction]._unitDefIDs[tierKey]
          if tierDefs then
              if tierDefs.constructor and unitDefID == tierDefs.constructor.id then unitData=tierDefs.constructor;data.constructors[unitID] = { tier = tier, state = "idle", task = nil, moveType=unitData.moveType }; foundType = "Con "..tierKey; break end
              if tierDefs.factory and unitDefID == tierDefs.factory.id then unitData=tierDefs.factory;data.factories[unitID] = { tier = tier, producing = nil, moveType=unitData.moveType }; foundType = "Fac "..tierKey; break end
              if tierDefs.extractor and unitDefID == tierDefs.extractor.id then unitData=tierDefs.extractor;data.buildings[unitID] = { tier = tier, type = "extractor", moveType=unitData.moveType }; foundType = "Ext "..tierKey; break end
              if tierDefs.powerPlant and unitDefID == tierDefs.powerPlant.id then unitData=tierDefs.powerPlant;data.buildings[unitID] = { tier = tier, type = "power", moveType=unitData.moveType }; foundType = "Pow "..tierKey; break end
              if tierDefs.attackers then for _, d in ipairs(tierDefs.attackers) do if unitDefID == d.id then unitData=d; data.combatUnits[unitID] = { tier = tier, type = "attacker", group = nil, state = "idle", moveType=unitData.moveType }; foundType = "Atk "..tierKey; break end end; if foundType then break end end
              if tierDefs.defenses then for _, d in ipairs(tierDefs.defenses) do if unitDefID == d.id then unitData=d; data.buildings[unitID] = { tier = tier, type = "defense", moveType=unitData.moveType }; foundType = "Def "..tierKey; break end end; if foundType then break end end
          end
      end
      if foundType then Log(unitTeam, "UnitFinished: " .. unitID .. " (" .. (unitDef and unitDef.humanName or "N/A") .. ") - Categorized as: " .. foundType .." (MoveType: ".. (unitData and unitData.moveType or 'N/A') .. ")")
      else Log(unitTeam, "UnitFinished: " .. unitID .. " (" .. (unitDef and unitDef.humanName or "N/A") .. ") - Not categorized.") end
    end
  end

  function gadget:UnitDestroyed(unitID, unitDefID, unitTeam, ...)
      if teamData[unitTeam] then
          local data = teamData[unitTeam]
          if data.constructors[unitID] then data.constructors[unitID] = nil
          elseif data.factories[unitID] then data.factories[unitID] = nil
          elseif data.combatUnits[unitID] then data.combatUnits[unitID] = nil
          elseif data.buildings[unitID] then data.buildings[unitID] = nil
          end
          -- Rimuovi anche dagli obiettivi se necessario? (Non implementato)
      end
  end

  function gadget:Shutdown()
    Log(nil, gadget:GetInfo().name .. " Shutting down.")
  end

end -- SYNCED CODE END


-- UNSYNCED CODE (Debug Visivo e Comando Console)
if (not gadgetHandler:IsSyncedCode()) then
    local function DrawFactionAndTech(teamID, data)
      local x, y, z = Spring.GetTeamStartPosition(teamID)
      if x and data.faction then
         gl.Text(data.faction .. " (T" .. data.techLevel .. ")", x, y+60, 15, "co")
      end
    end

    function gadget:DrawWorld()
      if SYNCED and SYNCED.KPAI_Debug_Mode and SYNCED.KPAI_Debug_Mode > 0 and type(SYNCED.teamData) == "table" then
        for teamID, data in pairs(SYNCED.teamData) do
           if data and data.initialized then
              DrawFactionAndTech(teamID, data)
           end
        end
        gl.Color(1,1,1,1)
      end
    end

    function gadget:DrawScreen(vsx, vsy)
       if SYNCED and SYNCED.KPAI_Debug_Mode and SYNCED.KPAI_Debug_Mode > 0 and SYNCED.currentMapCategory then
          gl.Text("Map Category: " .. SYNCED.currentMapCategory, vsx * 0.5, vsy - 30, 15, "co")
       end
    end

    local function ToggleDebug(cmd, line, words, player)
      local currentMode = 0
      if SYNCED and SYNCED.KPAI_Debug_Mode then currentMode = SYNCED.KPAI_Debug_Mode end
      local newMode = (currentMode == 0) and 1 or 0
      Spring.SendLuaRulesMsg("WMRTSAI_SetDebug " .. newMode)
      Spring.Echo("WMRTSAI Debug Mode set to: " .. newMode .. " (Command sent)")
      return true
    end

    function gadget:Initialize()
       gadgetHandler:AddChatAction("wmrtsai_debug", ToggleDebug, "Toggle WMRTSAI debug messages/drawing")
    end

    function gadget:RecvLuaMsg(msg, playerID)
      if msg:find("^WMRTSAI_SetDebug") then
          local _, levelStr = msg:match("([^ ]+)%s+(.*)")
          local level = tonumber(levelStr)
          if level ~= nil then
              if SYNCED then SYNCED.KPAI_Debug_Mode = level end
          end
          return true
      end
      return false
    end
end -- FINE UNSYNCED