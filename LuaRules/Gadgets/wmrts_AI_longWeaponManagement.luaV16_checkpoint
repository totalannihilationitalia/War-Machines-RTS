--[[
Questa versione di military (16) non legge ancora le variabili globali
	if (not GG.AI_RaggioDifesa) then GG.AI_RaggioDifesa = {} end 	-- raggio di difesa della base del team
	if (not GG.AI_StatoGuerra) then GG.AI_StatoGuerra = {} end		-- stato di guerra del team
	if (not GG.AI_BasePos) then GG.AI_BasePos = {} end				-- posizione della base del team
inviate dal gadget “wmrts_AI_constructionManagement”
e pertanto il sistema invia continuamente le unità alll’attacco a prescindere dallo stato della guerra.
Il sistema V16 è funzionante ed è stato siglato “checkpoint”. Molix
]]--

function gadget:GetInfo()
	return {
		name      = "WMRTS Long Range Weapon Management",
		desc      = "Gestore Artiglierie e Silos Nucleari AI - War Machines RTS",
		author    = "molix & AI",
		date      = "2026",
		license   = "GPL",
		layer     = 110,
		enabled   = true
	}
end

if (not gadgetHandler:IsSyncedCode()) then return end

--------------------------------------------------------------------------------
-- CONFIGURAZIONE
--------------------------------------------------------------------------------

local dbPath = "LuaRules/Configs/WMRTS_AI_mission_db.lua"
local UNIT_DB = VFS.Include(dbPath)

local TARGET_AI_NAME = "WarMachinesRTSmissionAI" -- Filtro per attivare l'IA
local aiTeamIDs = {}
local lastNukeFrame = {} 

--------------------------------------------------------------------------------
-- FUNZIONI DI SUPPORTO
--------------------------------------------------------------------------------

local function GetTargetInRange(myTeamID, cx, cz, maxRange, minPriority)
	local allUnits = Spring.GetAllUnits()
	local gaiaTeamID = Spring.GetGaiaTeamID()
	
	local bestTarget = nil
	local highestPriorityFound = -1

	for i = 1, #allUnits do
		local uID = allUnits[i]
		local uTeam = Spring.GetUnitTeam(uID)
		
		if uTeam ~= gaiaTeamID and not Spring.AreTeamsAllied(myTeamID, uTeam) then
			local uDefID = Spring.GetUnitDefID(uID)
			local uName = UnitDefs[uDefID].name
			local dbEntry = UNIT_DB[uName]
			
			if dbEntry then
				local enemyCat = dbEntry.type or "unknown"
				local priority = 0
				if enemyCat == "strategicbuilding" then priority = 10				
				elseif enemyCat == "strategicdefence" then priority = 9
				elseif enemyCat == "building" then priority = 7
				elseif enemyCat == "defence" then priority = 5
				elseif enemyCat == "ground" then priority = 1 
				end

				if priority >= minPriority then
					local tx, ty, tz = Spring.GetUnitPosition(uID)
					if tx then
						local dx = cx - tx
						local dz = cz - tz
						local dist = math.sqrt(dx*dx + dz*dz)
						
						if dist <= maxRange then
							if priority > highestPriorityFound then
								highestPriorityFound = priority
								-- Restituiamo una tabella con tutti i dati necessari
								bestTarget = {x=tx, y=ty, z=tz, id=uID, prio=priority}
							end
						end
					end
				end
			end
		end
	end
	return bestTarget
end

--------------------------------------------------------------------------------
-- CORE LOGIC
--------------------------------------------------------------------------------

function gadget:GameFrame(n)
    if n < 300 then return end 
    if n % 150 ~= 0 then return end -- Esecuzione ogni 5 secondi

    -- 1. IDENTIFICAZIONE TEAM (Solo quelli controllati dalla tua IA)
    local teamList = Spring.GetTeamList()
    for _, teamID in ipairs(teamList) do
        local aiName = Spring.GetTeamLuaAI(teamID)
        if aiName and string.find(string.lower(aiName), string.lower(TARGET_AI_NAME)) then
            aiTeamIDs[teamID] = true
        end
    end

    for teamID, _ in pairs(aiTeamIDs) do
        local teamUnits = Spring.GetTeamUnits(teamID)
        
        for _, uID in ipairs(teamUnits) do
            local uDefID = Spring.GetUnitDefID(uID)
            local uName = UnitDefs[uDefID].name
            local dbEntry = UNIT_DB[uName]
            
            if dbEntry then
                -- Controllo se l'unità è completata
                local _, _, _, _, buildProgress = Spring.GetUnitHealth(uID)
                
                if buildProgress and buildProgress >= 1.0 then
                    local ux, uy, uz = Spring.GetUnitPosition(uID)

                    --------------------------------------------------------------------
                    -- 1) ARTIGLIERIA (isLRA)
                    --------------------------------------------------------------------
                    if dbEntry.isLRA then
                        -- Se non ha ordini in coda, cerca un bersaglio
                        local cmdQueue = Spring.GetCommandQueue(uID, 1)
                        if #cmdQueue == 0 then
                            -- Usiamo il range dal DB (obbligatorio per evitare errori)
                            local weaponRange = dbEntry.range or 6000
                            local target = GetTargetInRange(teamID, ux, uz, weaponRange, 1) 						-- priorità dei target da 1 in su ( che vuol dire in ordine da 10 a 1, definiti nella funzione GetTargetInRange)
                            
                            if target then
                                Spring.GiveOrderToUnit(uID, CMD.ATTACK, {target.x, target.y, target.z}, {}) 		-- Ordine alle coordinate, in questo modo l'AI colpisce anche senza radar ########## verificare se creare una tabella con le unità spottate (almeno una volta) e colpire solo quelle, anche fuori dai radar per rendere l'AI più "umana"
                            end
                        end
                    end           

					--------------------------------------------------------------------
					-- 2) GESTIONE ANTI-NUKE (isAMD)
					--------------------------------------------------------------------
					if dbEntry.isAMD then
						local numStockpiled, numScheduled = Spring.GetUnitStockpile(uID)
						if numStockpiled then
							if (numStockpiled + numScheduled) < 3 then
								Spring.GiveOrderToUnit(uID, CMD.STOCKPILE, {}, {}) 
							end
						end
					end -- fine isAMD

					--------------------------------------------------------------------
					-- 3) GESTIONE SILOS NUCLEARI (isSILO)
					--------------------------------------------------------------------
					if dbEntry.isSILO then
						local numStockpiled, numScheduled = Spring.GetUnitStockpile(uID)
						if numStockpiled then
							-- A) Produzione
							if (numStockpiled + numScheduled) < 2 then
								Spring.GiveOrderToUnit(uID, CMD.STOCKPILE, {}, {})
							end
							-- B) Lancio
							if numStockpiled > 0 then
								local lastLaunch = lastNukeFrame[uID] or 0
								if (n - lastLaunch) > 1200 then 
									local nukeRange = dbEntry.range or 50000
									local target = GetTargetInRange(teamID, ux, uz, nukeRange, 8)					-- priorità dei target da 8 in su ( che vuol dire in ordine da 10 a 8, definiti nella funzione GetTargetInRange)
									if target then
										Spring.GiveOrderToUnit(uID, CMD.ATTACK, {target.x, target.y, target.z}, {})	-- Ordine alle coordinate, in questo modo l'AI colpisce anche senza radar ########## verificare se creare una tabella con le unità spottate (almeno una volta) e colpire solo quelle, anche fuori dai radar per rendere l'AI più "umana"
										lastNukeFrame[uID] = n
										Spring.Echo("AI Mission AI: Silo Nucleare in fuoco!")
									end
								end
							end
						end
					end -- fine isSILO
				end -- fine del buildprogress >= 1.0
			end -- fine if dbEntry
		end -- fine loop teamUnits
	end -- fine loop aiTeamIDs
end -- fine funzione GameFrame