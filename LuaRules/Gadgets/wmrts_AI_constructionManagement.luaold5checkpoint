function gadget:GetInfo()
	return {
		name      = "WMRTS Construction Manager",
		desc      = "Gestore costruzioni V2.6 - War Machines RTS",
		author    = "molix & AI",
		date      = "2025",
		license   = "GPL",
		layer     = 90,
		enabled   = true
	}
end
-- 19/01/2026 = realizzato questo gadget, molix
-- 28/01/2026 = implementata la logica introducendo il RESET LIVELLO. In questo modo quando certe strutture scendono sotto il limite, l'AI resetta il livello e parte da capo con le costruzioni, per prevenire lo stallo economico/tecnologico

-- TO DO
-- implementare naval e sub
-- creare la categorizzazione land/air/sea per gli estrattori di metallo (logicamente land e air avranno lo stesso icumetex mentre sea avrà ad esempio undewatermetex). Vedere se fare lo stesso per le floating torrette T1 e T2 ed eventualmente le centrali energia.
-- creare funzione upgrade estrattori da T1 a T2
-- creare funzione comando ai costruttori (comandante, costruttori non comandante): Patrol/costruisci. La prima gira attorno alla base aiutando le costruizoni, la seconda per impegnare i costruttori a costruire

if (not gadgetHandler:IsSyncedCode()) then return end

--------------------------------------------------------------------------------
-- 1) DATABASE E CONFIGURAZIONE
--------------------------------------------------------------------------------

local MAP_PROFILES = {
    ["Default"]      = { land = true, air = true, sea = false },		-- configurazione di default per le mappe senza profili mappa
    ["Zoty Outpost"] = { land = true, air = true, sea = false },
}

-- categorizzazione delle unità
local CATEGORY_TO_UNIT = {
--	Puoi randomizzare le costruzioni scrivendo più unità per categoria es.: ["CAT_LASER_T1"] = { "armrl", "armllt", "armteeth" },
--  Se vuoi che un'unità sia costruita più spesso di un'altra, puoi ripetere il nome nella lista es.: ["CAT_MEX_T1"] = { "mex_normale", "mex_normale", "mex_corazzato" } Qui l'AI avrà il 66% di probabilità di fare quello normale e il 33% di fare quello corazzato.
--	Aggiungi la categoria che vuoi ["CAT_esempio_robotT3"] = = { "icuraz" }, -- Meglio se la categoria "CAT_esempio_robotT3" sia presente in tutte le fazioni. Usa poi la categoria nella "AI_BUILD_LEVELS"
----------------------------
-- ICU
----------------------------
    ["ICU"] = {
        ["CAT_MEX_T1"]            = { "icumetex" },			
        ["CAT_MEX_T2"]            = { "armmoho" },				
        ["CAT_ENERGY_T1"]      = { "armsolar" },
        ["CAT_ENERGY_T2"]      = { "aafus" },		
        ["CAT_LASER_T1"]       = { "iculighlturr" },
        ["CAT_AA_T1"]          = { "armrl" },
        ["CAT_FACTORY_T1"] = {					-- fabbrica T1 si categorizza per tipologia ( terra, aria o mare), in funzione dei MAP_PROFILES l'AI effettuerà una scelta
            land = { "armlab", "armvp" },		-- randomizza la fabbrica
            air  = { "armap" },
            sea  = { "armsy" },
        },
        ["CAT_FACTORY_T2"] = {
            land = { "armalab", "armavp" },
            air  = { "armaap" },
            sea  = { "armasy" },
        },		
        ["CAT_ALL_CONSTRUCTORS"] = { "icucom", "icuck", "armcv", "armca", "armcs" }, -- categoria con tutti i costruttori (incluso il comandante), la uso al livello 0 per due motivi: 1) in caso di distruzione totale, quando l'AI torna a 0, se uno dei costruttori elencati è sopravvissuto, lo usa per ripartire con le costruzioni dal livello 0. 2) col game start, si parte col comandante, che è incluso nella lista. Soddisfa quindi il requisito del lvl 0.
        ["CAT_CONSTRUCTORS_T1"] = { "icuck", "armcv", "armca", "armcs" }, 		
        ["CAT_CONSTRUCTORS_T2"] = { "icuack", "armacv", "armaca", "armacs" }, 				
    },
----------------------------
-- AND
----------------------------
    ["AND"] = {
        ["CAT_MEX_T1"]            = { "andmex" },
        ["CAT_ENERGY_T1"]      = { "andsolar" },
        ["CAT_LASER_T1"]       = { "andlaser" },
        ["CAT_AA_T1"]          = { "andaa" },
        ["CAT_FACTORY_T1"] = {
            land = { "andlab", "andhp" },
            air  = { "andplat" },
            sea  = { "andplat" },
        },
        ["CAT_ALL_CONSTRUCTORS"] = { "andcom", "andcon", "andcv", "andca", "andcs" },
    }
}

local AI_BUILD_LEVELS = {
-- il numero [0] o [1] rappresenta il livello della AI. L'AI parte sempre dal livello 0. Per ogni livello vengono specificate quante unità devono essere costruite. l'AI sale di livello una volta che ha completato tutte le unità di quel livello. Se vengono distrutte le unità, e i requisiti di un livello non vengono rispettati, l'AI scende di livello per "recuperare" i requisiti che lo soddisfano.
-- "cat=" rappresenta quali unità  di categoria l'AI deve costruire in quel determinato livello. Le categorie sono definite sopra e si possono aggiungere a piacimento (a patto che sia presente in tutte le fazioni)
-- "count=" rappresenta la variabile ASSOLUTA di quante unità della categoria corrispondente devono essere attive in quel dato livello
    [0] = { 												-- livello di partenza. può diventare anche livello di RESET LIVELLO AI quando subisce pesanti attacchi (vedere sotto logica di RESET LIVELLO). E' importante che vi siano, in questo livello, le costruzioni che, in loro assenza/mancato numero (definito dalla logica di "RESET LIVELLO") resettino l'AI, altrimenti si entra in un LOOP infinito di salto livello (0 -> 1 e torna subito a 0)
        simultanea = 1,
        requisiti = {
            {cat = "CAT_ALL_CONSTRUCTORS", 	count = 1}, 	-- al livello 0 ne deve avere almeno 1 in totale. In fase di start skirmish è il comandante. In caso di restart AI, può essere qualunque costruttore, se presente. Ecco il motivo per cui metto la categoria "CAT_ALL_CONSTRUCTORS"
            {cat = "CAT_ENERGY_T1",         count = 2},		-- importanti per la logica RESET LIVELLO !!
            {cat = "CAT_MEX_T1",               count = 2},		-- importanti per la logica RESET LIVELLO !!
            {cat = "CAT_FACTORY_T1",        count = 1}, 	-- importanti per la logica RESET LIVELLO !!
            {cat = "CAT_MEX_T1",               count = 3}, 
        } 	-- end requisiti di livello
    },		-- end livello  [n]
    [1] = {
        simultanea = 2,
        requisiti = {
            {cat = "CAT_CONSTRUCTORS_T1", count = 2},
            {cat = "CAT_MEX_T1",               count = 3},
            {cat = "CAT_ENERGY_T1",         count = 5},
        } 	-- end requisiti di livello
    },		-- end livello  [n]
    [2] = {
        simultanea = 2,
        requisiti = {
            {cat = "CAT_CONSTRUCTORS_T1", count = 2},
            {cat = "CAT_MEX_T1",               count = 6},
            {cat = "CAT_ENERGY_T1",         count = 6},
        } 	-- end requisiti di livello
    }		-- end livello  [n]	
}

-- inserimento manuale degli spot di metallo per ogni mappa
local MANUAL_MAP_DATA = {
	["Zoty Outpost"] = { {x = 2241, z = 675}, {x = 492, z = 1206}, {x = 1918, z = 1285}, {x = 844, z = 1942}, {x = 1328, z = 2341}, {x = 661, z = 2387}, {x = 2108, z = 2422} },
	["Eridlon Island"] = { {x = 10586, z = 1255}, {x = 10520, z = 1224}, {x = 10794, z = 1399}, {x = 10744, z = 1372}, {x = 5872, z = 1445}, {x = 10602, z = 1495}, {x = 5661, z = 1542}, {x = 10536, z = 1480}, {x = 5608, z = 1520}, {x = 5874, z = 1679}, {x = 5832, z = 1648}, {x = 9749, z = 1747}, {x = 7221, z = 1939}, {x = 6722, z = 2095}, {x = 6680, z = 2076}, {x = 7152, z = 2149}, {x = 6516, z = 2179}, {x = 3809, z = 2223}, {x = 3752, z = 2192}, {x = 4026, z = 2359}, {x = 10624, z = 2373}, {x = 3976, z = 2332}, {x = 10568, z = 2328}, {x = 3810, z = 2469}, {x = 10836, z = 2483}, {x = 3768, z = 2448}, {x = 10776, z = 2440}, {x = 10612, z = 2611}, {x = 6248, z = 2755}, {x = 6200, z = 2736}, {x = 6256, z = 2997}, {x = 5568, z = 3253}, {x = 5528, z = 3240}, {x = 5796, z = 3363}, {x = 5736, z = 3344}, {x = 5568, z = 3493}, {x = 5512, z = 3464}, {x = 9164, z = 3558}, {x = 9096, z = 3528}, {x = 9372, z = 3638}, {x = 11117, z = 3702}, {x = 8720, z = 3717}, {x = 8680, z = 3692}, {x = 9136, z = 3797}, {x = 9096, z = 3768}, {x = 8496, z = 3861}, {x = 8456, z = 3832}, {x = 11232, z = 3909}, {x = 11184, z = 3882}, {x = 8733, z = 3942}, {x = 11004, z = 3942}, {x = 4722, z = 3989}, {x = 8680, z = 3928}, {x = 3306, z = 4031}, {x = 4680, z = 3968}, {x = 4514, z = 4079}, {x = 3090, z = 4133}, {x = 8088, z = 4131}, {x = 3048, z = 4112}, {x = 8040, z = 4112}, {x = 4748, z = 4230}, {x = 3325, z = 4262}, {x = 4696, z = 4200}, {x = 7629, z = 4278}, {x = 3272, z = 4232}, {x = 7853, z = 4294}, {x = 7573, z = 4270}, {x = 7800, z = 4272}, {x = 8096, z = 4373}, {x = 4858, z = 4391}, {x = 8056, z = 4360}, {x = 11113, z = 4431}, {x = 4808, z = 4376}, {x = 11373, z = 4486}, {x = 11320, z = 4448}, {x = 5069, z = 4534}, {x = 5024, z = 4504}, {x = 4874, z = 4631}, {x = 11202, z = 4655}, {x = 10093, z = 4934}, {x = 10040, z = 4904}, {x = 7933, z = 4982}, {x = 7880, z = 4952}, {x = 9874, z = 5045}, {x = 9832, z = 5020}, {x = 7714, z = 5093}, {x = 7672, z = 5068}, {x = 7949, z = 5222}, {x = 7896, z = 5200}, {x = 3956, z = 6195}, {x = 3841, z = 6383}, {x = 4064, z = 6549}, {x = 9642, z = 6407}, {x = 4010, z = 6520}, {x = 4277, z = 6579}, {x = 9501, z = 6598}, {x = 9740, z = 6630}, {x = 4157, z = 6758}, {x = 4104, z = 6732}, {x = 6689, z = 7263}, {x = 6461, z = 7302}, {x = 6408, z = 7264}, {x = 10926, z = 7365}, {x = 6621, z = 7478}, {x = 6568, z = 7448}, {x = 11148, z = 7510}, {x = 10926, z = 7605}, {x = 10872, z = 7580}, {x = 5888, z = 7765}, {x = 5832, z = 7740}, {x = 6112, z = 7797}, {x = 9261, z = 8614}, {x = 9208, z = 8592}, {x = 9162, z = 8743}, {x = 9786, z = 8759}, {x = 9720, z = 8736}, {x = 9994, z = 8903}, {x = 9944, z = 8876}, {x = 9778, z = 9013}, {x = 9736, z = 8992}, {x = 3228, z = 9686}, {x = 3586, z = 9711}, {x = 3176, z = 9672}, {x = 3528, z = 9688}, {x = 3541, z = 9891}, {x = 3496, z = 9856}, {x = 3552, z = 10021}, {x = 4944, z = 10133}, {x = 4888, z = 10104}, {x = 5168, z = 10277}, {x = 4948, z = 10371}, {x = 4904, z = 10336}, {x = 8109, z = 10454}, {x = 8056, z = 10444}, {x = 9648, z = 10517}, {x = 8314, z = 10559}, {x = 9592, z = 10496}, {x = 8264, z = 10536}, {x = 2624, z = 10629}, {x = 9417, z = 10655}, {x = 9368, z = 10616}, {x = 9632, z = 10757} },	
}

--------------------------------------------------------------------------------
-- 2) VARIABILI DI STATO
--------------------------------------------------------------------------------
local aiTeamIDs = {}
local teamLevels = {}       
local teamFactions = {}     
local teamBasePos = {}      
local metalSpots = {}
local scanDone = false

--------------------------------------------------------------------------------
-- 3) FUNZIONI DI SUPPORTO
--------------------------------------------------------------------------------

-- Questa funzione serve a capire dove si trovano le risorse.
--	•	Controlla se esistono coordinate predefinite per la mappa corrente in MANUAL_MAP_DATA.
--	•	Se non ci sono, scansiona l'intera mappa con un salto di 32 pixel cercando punti dove il valore del metallo è superiore a 0.1.
--	•	Salva le coordinate in una tabella metalSpots per usi futuri.
local function AnalyzeMetalMap()
    metalSpots = {}
    local mapName = Game.mapName
    if MANUAL_MAP_DATA[mapName] then
        for _, spot in ipairs(MANUAL_MAP_DATA[mapName]) do table.insert(metalSpots, {x = spot.x, z = spot.z}) end
    else
        local step = 32
        for z = 16, Game.mapSizeZ, step do
            for x = 16, Game.mapSizeX, step do
                if Spring.GetMetalAmount(x, z) > 0.1 then
                    table.insert(metalSpots, {x = x, z = z})
                end
            end
        end
    end
    scanDone = true
    Spring.Echo("WMRTS AI: Metal scan complete (" .. #metalSpots .. " spots)")
end

-- Trova il punto di metallo più vicino alla posizione (cx, cz) (solitamente la base dell'AI).
--	•	Scorre la lista dei punti trovati da AnalyzeMetalMap.
--	•	Per ogni punto, verifica se è già occupato da un altro estrattore usando Spring.GetUnitsInSphere.
--	•	Restituisce le coordinate del punto libero più vicino.
local function GetClosestMetalSpot(cx, cz)
    local bestSpot = nil
    local minDist = 5000 * 5000 
    for i = 1, #metalSpots do
        local spot = metalSpots[i]
        local dx, dz = cx - spot.x, cz - spot.z
        local distSq = dx*dx + dz*dz
        if distSq < minDist then
            local units = Spring.GetUnitsInSphere(spot.x, Spring.GetGroundHeight(spot.x, spot.z), spot.z, 64)
            local occupied = false
            for _, uID in ipairs(units) do
                local ud = UnitDefs[Spring.GetUnitDefID(uID)]
                if ud and ud.isExtractor then occupied = true; break end
            end
            if not occupied then minDist = distSq; bestSpot = spot end
        end
    end
    if bestSpot then return bestSpot.x, Spring.GetGroundHeight(bestSpot.x, bestSpot.z), bestSpot.z end
    return nil
end

-- È il "contabile" dell'AI.
--	•	Riceve la categoria (es. "CAT_MEX_T1") e la fazione.
--	•	Usa Spring.GetTeamUnitDefCount per contare quante unità di quel tipo il team possiede già sulla mappa.
--	•	Gestisce anche le categorie multi-tipo (es. le fabbriche che possono essere Land, Air o Sea).
local function CountUnitsInCategory(teamID, category, faction)
    local entry = CATEGORY_TO_UNIT[faction][category]
    if not entry then return 0 end
    local total = 0
    local function c(list)
        for _, name in ipairs(list) do
            local ud = UnitDefNames[name]
            if ud then total = total + Spring.GetTeamUnitDefCount(teamID, ud.id) end
        end
    end
    if entry.land or entry.air or entry.sea then
        if entry.land then c(entry.land) end
        if entry.air then c(entry.air) end
        if entry.sea then c(entry.sea) end
    else c(entry) end
    return total
end

-- Sceglie quale unità specifica costruire all'interno di una categoria.
--	•	Utilizza i MAP_PROFILES per decidere se la mappa permette unità di terra, aria o mare.
--	•	Restituisce un nome di unità casuale tra quelle valide per quel profilo (es. se la mappa è solo terra, non sceglierà una fabbrica navale).
local function GetRandomUnitFromCat(faction, category)
    local entry = CATEGORY_TO_UNIT[faction][category]
    if not entry then return nil end
    local profile = MAP_PROFILES[Game.mapName] or MAP_PROFILES["Default"]
    local valid = {}
    
    if entry.land or entry.air or entry.sea then
        if profile.land and entry.land then for _,u in ipairs(entry.land) do table.insert(valid,u) end end
        if profile.air and entry.air then for _,u in ipairs(entry.air) do table.insert(valid,u) end end
        if profile.sea and entry.sea then for _,u in ipairs(entry.sea) do table.insert(valid,u) end end
        if #valid > 0 then return valid[math.random(#valid)] end
    else
        return entry[math.random(#entry)]
    end
    return nil
end

-- Funzione per contare quante unità di quella categoria sono "in arrivo" nelle code delle fabbriche 
local function CountUnitsInQueues(teamID, category, faction)
    local entry = CATEGORY_TO_UNIT[faction][category]
    if not entry then return 0 end
    
    -- Trasformiamo i nomi in ID per un confronto veloce
    local validIDs = {}
    local function fillIDs(list)
        for _, name in ipairs(list) do
            local ud = UnitDefNames[name]
            if ud then validIDs[ud.id] = true end
        end
    end

    if entry.land or entry.air or entry.sea then
        if entry.land then fillIDs(entry.land) end
        if entry.air then fillIDs(entry.air) end
        if entry.sea then fillIDs(entry.sea) end
    else fillIDs(entry) end

    local totalInQueue = 0
    local teamUnits = Spring.GetTeamUnits(teamID)
    for _, uID in ipairs(teamUnits) do
        local ud = UnitDefs[Spring.GetUnitDefID(uID)]
        if ud and ud.isFactory then
            local queue = Spring.GetFullBuildQueue(uID)
            if queue then
                for _, buildItem in ipairs(queue) do
                    -- buildItem è { [unitDefID] = count }
                    for uDefID, count in pairs(buildItem) do
                        if validIDs[uDefID] then
                            totalInQueue = totalInQueue + count
                        end
                    end
                end
            end
        end
    end
    return totalInQueue
end

--------------------------------------------------------------------------------
-- 4) GADGET CORE
--------------------------------------------------------------------------------

function gadget:GameFrame(n)
    if n < 35 then return end 
    if not scanDone then AnalyzeMetalMap() end
    if (n % 150 ~= 0) then return end 

    local teamList = Spring.GetTeamList()
    for _, teamID in ipairs(teamList) do
        if not aiTeamIDs[teamID] then
            local aiName = Spring.GetTeamLuaAI(teamID)
            if aiName and aiName ~= "" then
                aiTeamIDs[teamID] = true
                teamLevels[teamID] = 0
                local side = select(5, Spring.GetTeamInfo(teamID))
                teamFactions[teamID] = (side and string.find(string.lower(side), "and")) and "AND" or "ICU"
                Spring.Echo("WMRTS AI: Team " .. teamID .. " detected (" .. teamFactions[teamID] .. ")")
            end
        end
    end

    for teamID, _ in pairs(aiTeamIDs) do
        local faction = teamFactions[teamID]


        if not teamBasePos[teamID] then
            local units = Spring.GetTeamUnits(teamID)
            if units and #units > 0 then
                local x,y,z = Spring.GetUnitPosition(units[1])
                teamBasePos[teamID] = {x=x, y=y, z=z}
            else return end
        end

        local currentLvl = teamLevels[teamID]
--[[		-- funzionante, logica solo fabbriche
		------------------------------------------------------------------------
        -- LOGICA DI RESET LIVELLO di tipo A: Ritorno al Livello 0 se le fabbriche sono distrutte
        ------------------------------------------------------------------------
        if currentLvl > 0 then
            -- Contiamo quante fabbriche totali ha l'AI (T1 + T2 se esiste)
            local nFabbriche = CountUnitsInCategory(teamID, "CAT_FACTORY_T1", faction)
            
            -- Se hai aggiunto anche le T2 nel database, contiamo anche quelle
            if CATEGORY_TO_UNIT[faction]["CAT_FACTORY_T2"] then
                nFabbriche = nFabbriche + CountUnitsInCategory(teamID, "CAT_FACTORY_T2", faction)
            end

            -- Se non ci sono più fabbriche, resettiamo il livello a 0
            if nFabbriche == 0 then
                teamLevels[teamID] = 0
                if GG.WMRTS_Levels then GG.WMRTS_Levels[teamID] = 0 end
                Spring.Echo("WMRTS AI: Team " .. teamID .. " has no factories! Reverting to Level 0.")
                -- Aggiorniamo la variabile currentLvl per il resto del frame
                currentLvl = 0 
            end
        end
        ------------------------------------------------------------------------
]]--		
		------------------------------------------------------------------------
        -- LOGICA DI RESET LIVELLO di tipo B: Ritorno al Livello 0 se:  le fabbriche sono distrutte oppure abbiamo meno di x estrattori oppure abbiamo meno di y fabbriche di energia
        ------------------------------------------------------------------------
        if currentLvl > 0 then
            -- Contiamo tutti i tipi di fabbriche, Mex e Energia 
            local nFabbriche = CountUnitsInCategory(teamID, "CAT_FACTORY_T1", faction) 															-- per ora ho messo solo le fabbriche T1
            local nMex = CountUnitsInCategory(teamID, "CAT_MEX_T1", faction)+CountUnitsInCategory(teamID, "CAT_MEX_T2", faction) 				-- sommo gli estrattori delle categorie T1 e T2
            local nEnergia = CountUnitsInCategory(teamID, "CAT_ENERGY_T1", faction) + CountUnitsInCategory(teamID, "CAT_ENERGY_T2", faction) 	-- sommo le fabbriche di energia delle categorie T1 e T2
            
            -- Condizioni di fallimento critico:
            local fallimentoFabbriche = (nFabbriche == 0)		-- Se le fabbriche T0 sono totalmente distrutte
            local fallimentoMetallo   = (nMex < 2)       		-- Se scende sotto i 2 estrattori di metallo
            local fallimentoEnergia   = (nEnergia < 2)   		-- Se scende sotto i 2 powerplant

            if fallimentoFabbriche or fallimentoMetallo or fallimentoEnergia then
                teamLevels[teamID] = 0
                if GG.WMRTS_Levels then GG.WMRTS_Levels[teamID] = 0 end
                
                local motivo = fallimentoFabbriche and "No Factories" or (fallimentoMetallo and "Low Metal" or "Low Energy")
                Spring.Echo("WMRTS AI: Team " .. teamID .. " Critical Failure (" .. motivo .. ")! Reverting to Level 0.")
                
                currentLvl = 0 
            end
        end
        ------------------------------------------------------------------------		
		
		
        local config = AI_BUILD_LEVELS[currentLvl]
        if not config then return end

        -- Logica Avanzamento Livello
        local levelBroken = false
        for _, req in ipairs(config.requisiti) do
            if CountUnitsInCategory(teamID, req.cat, faction) < req.count then
                levelBroken = true; break
            end
        end
        if not levelBroken and AI_BUILD_LEVELS[currentLvl + 1] then
            teamLevels[teamID] = currentLvl + 1
            if not GG.WMRTS_Levels then GG.WMRTS_Levels = {} end
            GG.WMRTS_Levels[teamID] = teamLevels[teamID]
            Spring.Echo("WMRTS AI: Team " .. teamID .. " Level Up -> " .. teamLevels[teamID])
            return
        end

        -- Identificazione Costruttori e Fabbriche
        local builders = {}
        local factories = {}
        local teamUnits = Spring.GetTeamUnits(teamID)
        for _, uID in ipairs(teamUnits) do
            local ud = UnitDefs[Spring.GetUnitDefID(uID)]
            if ud then
                if ud.canBuild or ud.isBuilder then
                    if Spring.GetCommandQueue(uID, 0) == 0 and not Spring.GetUnitIsBuilding(uID) then
                        table.insert(builders, uID)
                    end
                end
                if ud.isFactory then table.insert(factories, uID) end
            end
        end

        -- Esecuzione Requisiti
        local started = 0
        for _, req in ipairs(config.requisiti) do
            if started >= config.simultanea then break end
            
            local totalPresent = CountUnitsInCategory(teamID, req.cat, faction)
            local totalPending = CountUnitsInQueues(teamID, req.cat, faction)

            if (totalPresent + totalPending) < req.count then
                local unitName = GetRandomUnitFromCat(faction, req.cat)
                local uDef = UnitDefNames[unitName]
                
                if uDef then
                    -- CASO A: È una STRUTTURA (Richiede un Builder)
                    if uDef.isBuilding or uDef.isStructure then
                        if #builders > 0 then
                            local bx, by, bz
-- to do, aggiungere qui l'upgrade in T2 degli estrattori!!							
                            if req.cat == "CAT_MEX_T1" then																		-- aggiungere qui le categorie che riguardano gli estrattori
                                bx, by, bz = GetClosestMetalSpot(teamBasePos[teamID].x, teamBasePos[teamID].z)
                            else
                                for _ = 1, 30 do
                                    local angle = math.random() * math.pi * 2
                                    local dist = math.random(100, 500)
                                    local tx = teamBasePos[teamID].x + math.cos(angle) * dist
                                    local tz = teamBasePos[teamID].z + math.sin(angle) * dist
                                    if Spring.TestBuildOrder(uDef.id, tx, 0, tz, 0) == 2 then
                                        bx, by, bz = tx, Spring.GetGroundHeight(tx,tz), tz
                                        break
                                    end
                                end
                            end
                            
                            if bx then
                                Spring.Echo("WMRTS AI: Team " .. teamID .. " builder " .. builders[1] .. " builds " .. unitName)
                                Spring.GiveOrderToUnit(builders[1], -uDef.id, {bx, by, bz, 0}, {})
                                table.remove(builders, 1)
                                started = started + 1
                            end
                        end
                    
                    -- CASO B: È un ROBOT/UNITA' MOBILE (Richiede una Fabbrica)
                    else
                        for _, fID in ipairs(factories) do
                            local fud = UnitDefs[Spring.GetUnitDefID(fID)]
                            local canProduce = false
                            for _, optID in ipairs(fud.buildOptions) do
                                if optID == uDef.id then canProduce = true; break end
                            end
                            
                            if canProduce then
                                -- Evita di spammare se la fabbrica ha già l'unità in coda
                                local alreadyBuilding = false
                                local q = Spring.GetFullBuildQueue(fID)
                                if q then
                                    for _, item in ipairs(q) do
                                        if item[uDef.id] then alreadyBuilding = true; break end
                                    end
                                end

                                if not alreadyBuilding then
                                    Spring.Echo("WMRTS AI: Factory " .. fID .. " priority production: " .. unitName)
                                    Spring.GiveOrderToUnit(fID, -uDef.id, {}, {"alt"})
                                    started = started + 1
                                    break 
                                end
                            end
                        end
                    end -- Fine distinzione edificio/mobile
                end
            end
        end -- Fine ciclo requisiti
    end -- Fine ciclo team
end