function gadget:GetInfo()
	return {
		name      = "WMRTS Construction Manager",
		desc      = "Gestore costruzioni V1.9 - War Machines RTS",
		author    = "molix & AI",
		date      = "2025",
		license   = "GPL",
		layer     = 90,
		enabled   = true
	}
end

if (not gadgetHandler:IsSyncedCode()) then return end

--------------------------------------------------------------------------------
-- DATABASE CATEGORIE
--------------------------------------------------------------------------------

local CATEGORY_TO_UNIT = {
    ["ICU"] = {
        ["CAT_ENERGY_T1"]      = { "armsolar" },
        ["CAT_CONSTRUCTOR_T1"] = { "icucom", "icuck", "icucv" }, 
        ["CAT_FACTORY_T1"]     = { "armlab", "armvp" },
        ["CAT_LASER_T1"]       = { "armrl" },
        ["CAT_AA_T1"]          = { "armlightad" },
        ["CAT_MEX"]            = { "icumetex" },
    },
    ["AND"] = {
        ["CAT_ENERGY_T1"]      = { "andsolar" },
        ["CAT_CONSTRUCTOR_T1"] = { "andcom", "andcon" },
        ["CAT_FACTORY_T1"]     = { "andlab" },
        ["CAT_LASER_T1"]       = { "andlaser" },
        ["CAT_AA_T1"]          = { "andaa" },
        ["CAT_MEX"]            = { "andmex" },
    }
}

local AI_BUILD_LEVELS = {
    [0] = {
        simultanea = 1,
        requisiti = {
            {cat = "CAT_CONSTRUCTOR_T1", count = 1}, 
            {cat = "CAT_MEX",            count = 1}, 
            {cat = "CAT_ENERGY_T1",      count = 1},
            {cat = "CAT_FACTORY_T1",     count = 1},
            {cat = "CAT_MEX",            count = 3}, 
            {cat = "CAT_ENERGY_T1",      count = 3},
        }
    }
}

--------------------------------------------------------------------------------
-- TABELLA MANUALE MAPPE
--------------------------------------------------------------------------------

local MANUAL_MAP_DATA = {
    ["Zoty Outpost"] = {
        {x = 664, z = 2360},
        {x = 2101, z = 2412},
        {x = 1320, z = 2312},		
    },
}

--------------------------------------------------------------------------------
-- FUNZIONI DI SUPPORTO (CORRETTE)
--------------------------------------------------------------------------------

local metalSpots = {}
local scanDone = false

local function AnalyzeMetalMap()
    metalSpots = {}
    local mapName = Game.mapName
    if MANUAL_MAP_DATA[mapName] then
        for _, spot in ipairs(MANUAL_MAP_DATA[mapName]) do table.insert(metalSpots, {x = spot.x, z = spot.z}) end
    else
        local step = 16
        for z = 8, Game.mapSizeZ, step do
            for x = 8, Game.mapSizeX, step do
                if Spring.GetMetalAmount(x, z) > 0.1 then
                    local foundNear = false
                    for i=1, #metalSpots do
                        local dx, dz = x - metalSpots[i].x, z - metalSpots[i].z
                        if (dx*dx + dz*dz) < 150*150 then foundNear = true; break end
                    end
                    if not foundNear then table.insert(metalSpots, {x = x, z = z}) end
                end
            end
        end
    end
    scanDone = true
end

-- Conta unità finite
local function CountFinishedUnits(teamID, category, faction)
    local unitList = CATEGORY_TO_UNIT[faction][category]
    if not unitList then return 0 end
    local total = 0
    for _, unitName in ipairs(unitList) do
        local uDef = UnitDefNames[unitName]
        if uDef then total = total + Spring.GetTeamUnitDefCount(teamID, uDef.id) end
    end
    return total
end

-- Conta unità TOTALI (Finite + Ordinate) - CORRETTA
local function CountTotalPlannedUnits(teamID, category, faction)
    local unitList = CATEGORY_TO_UNIT[faction][category]
    if not unitList then return 0 end
    
    local total = CountFinishedUnits(teamID, category, faction)
    
    local teamUnits = Spring.GetTeamUnits(teamID)
    for _, uID in ipairs(teamUnits) do
        local udID = Spring.GetUnitDefID(uID)
        local ud = UnitDefs[udID]
        if ud and ud.isBuilder then
            local queue = Spring.GetUnitCommands(uID, 10) -- Controlla i primi 10 ordini
            if queue then
                for _, cmd in ipairs(queue) do
                    if cmd.id < 0 then -- Ordine di costruzione
                        local buildDefID = -cmd.id
                        for _, unitName in ipairs(unitList) do
                            local targetDef = UnitDefNames[unitName]
                            -- CHECK DI SICUREZZA: verifichiamo che targetDef non sia nil
                            if targetDef and targetDef.id == buildDefID then
                                total = total + 1
                            end
                        end
                    end
                end
            end
        end
    end
    return total
end

local function GetClosestMetalSpot(cx, cz)
    local bestSpot = nil
    local minDist = 4000 * 4000 
    for i = 1, #metalSpots do
        local spot = metalSpots[i]
        local dx, dz = cx - spot.x, cz - spot.z
        local distSq = dx*dx + dz*dz
        if distSq < minDist then
            local units = Spring.GetUnitsInSphere(spot.x, Spring.GetGroundHeight(spot.x, spot.z), spot.z, 64)
            local occupied = false
            for _, uID in ipairs(units) do
                local ud = UnitDefs[Spring.GetUnitDefID(uID)]
                if ud and ud.isExtractor then occupied = true; break end
            end
            if not occupied then minDist = distSq; bestSpot = spot end
        end
    end
    if bestSpot then return bestSpot.x, Spring.GetGroundHeight(bestSpot.x, bestSpot.z), bestSpot.z end
    return nil
end

local function FindGoodBuildSite(unitDefID, cx, cz)
    for _ = 1, 50 do 
        local angle = math.random() * math.pi * 2
        local dist = math.random(80, 400)
        local tx, tz = cx + math.cos(angle) * dist, cz + math.sin(angle) * dist
        if Spring.TestBuildOrder(unitDefID, tx, 0, tz, 0) == 2 then
            local _, ny, _ = Spring.GetGroundNormal(tx, tz)
            if ny > 0.9 then return tx, Spring.GetGroundHeight(tx, tz), tz end
        end
    end
    return nil
end

--------------------------------------------------------------------------------
-- GADGET CORE
--------------------------------------------------------------------------------

local aiTeamIDs = {}
local teamLevels = {}       
local teamFactions = {}     
local teamBasePos = {}      

function gadget:GameFrame(n)
    if n < 35 then return end 
    if not scanDone then AnalyzeMetalMap() end
    if (n % 150 ~= 0) then return end 

    local teamList = Spring.GetTeamList()
    for _, teamID in ipairs(teamList) do
        if not aiTeamIDs[teamID] then
            local aiName = Spring.GetTeamLuaAI(teamID)
            if aiName and string.find(string.lower(aiName), "ai") then
                aiTeamIDs[teamID] = true
                teamLevels[teamID] = 0
                local side = select(5, Spring.GetTeamInfo(teamID))
                teamFactions[teamID] = (side and string.find(string.lower(side), "and")) and "AND" or "ICU"
                if not GG.WMRTS_Levels then GG.WMRTS_Levels = {} end
                GG.WMRTS_Levels[teamID] = 0
            end
        end
    end

    for teamID, _ in pairs(aiTeamIDs) do
        local faction = teamFactions[teamID]
        local currentLvl = teamLevels[teamID]
        local config = AI_BUILD_LEVELS[currentLvl]
        if not config then return end

        if not teamBasePos[teamID] then
            local units = Spring.GetTeamUnits(teamID)
            if units and units[1] then
                local x,_,z = Spring.GetUnitPosition(units[1])
                teamBasePos[teamID] = {x=x, z=z}
            else return end
        end

        -- Avanzamento livello
        local levelComplete = true
        for _, req in ipairs(config.requisiti) do
            if CountFinishedUnits(teamID, req.cat, faction) < req.count then
                levelComplete = false; break
            end
        end
        if levelComplete and AI_BUILD_LEVELS[currentLvl + 1] then
            teamLevels[teamID] = currentLvl + 1
            GG.WMRTS_Levels[teamID] = currentLvl + 1
            Spring.Echo("WMRTS AI: Team " .. teamID .. " sale al livello " .. teamLevels[teamID])
            return
        end

        -- Trova costruttori liberi
        local builders = {}
        local teamUnits = Spring.GetTeamUnits(teamID)
        for _, uID in ipairs(teamUnits) do
            local ud = UnitDefs[Spring.GetUnitDefID(uID)]
            if ud and ud.isBuilder then
                local qSize = Spring.GetCommandQueue(uID, 0)
                if qSize == 0 and not Spring.GetUnitIsBuilding(uID) then
                    table.insert(builders, uID)
                end
            end
        end

        -- Ordini
        local started = 0
        for _, req in ipairs(config.requisiti) do
            if started >= config.simultanea then break end
            
            local pianificati = CountTotalPlannedUnits(teamID, req.cat, faction)
            
            if pianificati < req.count then
                local unitName = CATEGORY_TO_UNIT[faction][req.cat][1]
                local targetUDef = UnitDefNames[unitName]
                
                if targetUDef and #builders > 0 then
                    local bx, by, bz
                    if req.cat == "CAT_MEX" then
                        bx, by, bz = GetClosestMetalSpot(teamBasePos[teamID].x, teamBasePos[teamID].z)
                    else
                        bx, by, bz = FindGoodBuildSite(targetUDef.id, teamBasePos[teamID].x, teamBasePos[teamID].z)
                    end
                    if bx then
                        Spring.Echo("WMRTS AI: Team " .. teamID .. " ordina " .. unitName)
                        Spring.GiveOrderToUnit(builders[1], -targetUDef.id, {bx, by, bz, 0}, {})
                        table.remove(builders, 1)
                        started = started + 1
                    end
                end
            end
        end
    end
end