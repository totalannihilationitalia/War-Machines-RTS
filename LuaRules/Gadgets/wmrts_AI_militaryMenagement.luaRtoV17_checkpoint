function gadget:GetInfo()
	return {
		name      = "WMRTS Squad Commander AI",
		desc      = "AI V17 for War Machnines RTS",
		author    = "molix",
		date      = "2025",
		license   = "GPL",
		layer     = 100,
		enabled   = true
	}
end

-- 08/01/2025 = creata l'AI WMRTS_AI per missioni (base per l'AI skirmish)
-- 09/01/2025 = implementato il comando attack al gruppo di bombardieri. Prima l'AI gestiva solamente il comando FIGHT ma i bombardieri non bombardano automaticamente, bisogna indicargli il punto da bombardare con il comando Attack.
-- 09/01/2025 = esternizzata la tabella/db delle unità in WMRTS_AI_mission_db.lua
-- 11/01/2025 = sistemato bug tabelle NIL quando una fabbrica viene distrutta/rimossa
-- 12/01/2025 = agguiunti i livelli di difficoltà della AI. Per ora scattano dopo x minuti di tempo. Predisposto per una logica migliore di avanzamento (ad esempio quando ci sarà il controllo dei costruttori e l'avanzamento è dato da quanti estrattori e/o centrali solari l'AI ha costruito)
-- 14/01/2025 = le AI sono ora indipendenti (mentre prima il livello delle AI era unico per tutti i teams
-- 14/01/2025 = Aggiungo la gestione " ignore = true" nel database, da applicare ai costruttori, gestiti da altri gadget. In questo gadget i costruttori devono essere ignorati (cioè non devono essere inseriti in gruppi e mandati all'attacco), devono essere considerati invece solo come bersagli da attaccare ("ground" o relativi)
-- 29/01/2025 = Ora l'avanzamento di livello viene gestito dal gadget construcionManagement
-- 09/02/2025 = Aggiunta priorità nella categoria di attacco (per bombardieri & Co) e aggiunta categoria defence e strategicdefence
-- 20/02/2026 = Ho aggiunto la categoria (type) strategicshield in quanto prima gli shield erano inclusi in "strategicbuilding". In questo modo i cannoni a lungo raggio gestiti dalla AI del gadget "wmrts_AI_longWeaponManagement.lua" non prendono di mira gli shield (antiplasma) che prima erano categorizzati come "strategicbuilding". Il codice in questo gadget viene modificato in modo che, se prima, la categoria "X" attaccava solo "strategicbuilding", ora deve attaccare anche la type scorporata "strategicbuilding"
-- 23/02/2026 = Implementazione punto base, raggio di difesa e stato di battaglia. La gestione di questi tre parametri è dettata da "wmrts_AI_constructionManagement.lua". In funzione di queste impostazioni, le truppe verranno cosi gestite: in modalità "attacco" -> tutte le truppe all'attacco come ora. In modalità "difesa_pesante" tutte le truppe vengono mandate all'attacco contro nemici dentro il raggio della base. In modalità "difesa_leggera" solo le truppe/gruppi dentro il raggio della base vengono mandati contro i nemici dentro il raggio della base

-- to do LIST ################################
-- 1) implementare i SUB


if (not gadgetHandler:IsSyncedCode()) then
	return false
end

--------------------------------------------------------------------------------
-- 1) DATABASE UNITÀ -- caricato dal file WMRTS_AI_mission_db.lua
--------------------------------------------------------------------------------
-- Qui puoi aggiungere campi extra in futuro (es. priority, armor_type, ecc.)
-- La tipologia di ogni singola unità è necessaria affinchè la AI gestisca le squadre/gruppi (punto 2) contro le singole unità.
-- Ad esempio le tipologie di unità "ground" definite nel database verranno bersagliate dai gruppi tipo "ground" e "air_toground" definiti nel punto 2. 
-- Questa logica di "chi attacca cosa" è definita poi nel punto "4) LOGICA DI TARGETING BASATA SU DATABASE"
-- definizione delle tipologie "type":
--			type = ground 				-> unità mobile di terra (veicoli e Kbot)
--			type = air 					-> unità mobile aerea
--			type = hovercraft 			-> unità mobile di terra che può andare sul mare
--			type = naval 				-> unità mobile navale (di superficie, no SUB)
--			type = building 			-> unità fissa di superficie su terra (di difesa/produzione/energia)
--			type = navalbuilding 		-> unità fissa di superficie su mare (di difesa/produzione/energia)
--			type = defence 				-> unità fissa di difesa T1-2 + ( Es torrette di difesa importanti, antiaerea ecc )
--			type = strategicbuilding 	-> unità fissa di superficie strategica ( Es factory 3 livello, silos, antipalline, ecc )
--			type = strategicdefence 	-> unità fissa di difesa strategica ( Es bertha, corbuzz, toaster, ecc )
--			type = strategicshield		-> unità fissa shield (es. plasma repulsor) 
--			tutte le unità che non sono identificate in questo database, prenderanno valore type = unknown , vedere poi la logica di targetin come gestirle

local dbPath = "LuaRules/Configs/WMRTS_AI_mission_db.lua"
local UNIT_DB = VFS.Include(dbPath)

-- Debug in caso di mancanza del database
if not UNIT_DB then
    Spring.Echo("WMRTS_militMngm_AI: WARNING -> WM AI units database not found in: " .. dbPath)
    UNIT_DB = {}
end

--------------------------------------------------------------------------------
-- 2a) CONFIGURAZIONE SQUADRE / GRUPPI (LISTE DI COSTRUZIONE) e tipologia
--------------------------------------------------------------------------------

-- Il nome dello "squad_template" identifica solamente il nome del gruppo da creare. Es. ["ICU_armlab_light_patrol_1"], verrà poi impiegato nel punto 2b per dire alla fabbrica: costruisci le unità di questo gruppo e forma il gruppo
-- units = l'elenco delle unità (solo militari) che comporranno il gruppo (ad esempio il gruppo "ICU_armlab_light_patrol_1". Le unità di costruzione (dichiarate nel database) non verranno gestite nel gruppo ma verranno ignorate per essere gestite da altri gadget
-- type = tipologia di squadra, la tipologia verrà impiegata nella logica di targeting (punto 4) per dire quali unità devono attaccare. In generale descrizioni a seguito:
-- 					type = "ground" 				-> manda all'attacco verso la prima unità, trovata in base all'ID, che corrisponda a "ground", "building", "strategicbuilding", "strategicdefence", "unknown" e "defence" se y di quest'ultima > -1 (vedere punto 4). Ideale per le truppe di terra o gli aerei.
-- 					type = "ground_hovercraft" 		-> manda all'attacco verso la prima unità, trovata in base all'ID, che corrisponda a "ground", "building", "strategicbuilding", "strategicdefence", "unknown", "defence" e "hover" a prescindere dalla y di quest'ultima (rispetto al gruppo "ground". Ideale per gli hovecraft e per gli aerei
--					type = "air_toair" 				-> tutti gli aerei destinati ad attaccare solo aerei
--					type = "air_toground" 			-> tutti gli aerei destinati ad attaccare tutte le unità mobili di terra (ground, hovercraft e naval). Attenzione: non sono presenti "building", "strategicbuilding", "strategicdefence", "defence". In questa categoria non mettere bombardieri in quanto sorvolerebbero solamente la zona per poi "sedersi". Per loro ci vuole una logica di attacco diretto sull'unità, per questo usare i gruppi specifici per bombardieri
--					type = "air_bomber" 			-> specifico per tutti gli aerei da bombardamento. In questo gruppo possono essere inclusi anche gli aerei di attacco a terra (tipo armfig e bombardieri). Hanno una logica con priorità sui target e manda le unità all'attacco direttamente sull'unità di tipo (in ordine di priorità): "building", "defence", "strategicbuilding", "strategicdefence", "ground")
--					type = "air_bomber_strategic" 	-> specifico per tutti gli aerei da bombardamento. In questo gruppo possono essere inclusi anche gli aerei di attacco a terra (tipo armfig e bombardieri). Hanno una logica con priorità sui target e manda le unità all'attacco direttamente sull'unità di tipo (in ordine di priorità):"strategicbuilding", "strategicdefence", "building", "defence" e "ground"

local SQUAD_TEMPLATES = {

-- divido qui sotto i template di costruzione in funzione del livello, solo per maggior chiarezza. Quando il livello sale, vado a cambiare i templates di costruzione in 2b)

-------------------------------------------------------------------------------
--  Set di gruppi per l'AI - le ho divise per livello per una maggiore visibilità, ma sono soltanto nomi di gruppi e nessuno vieta che al livello 3 si posssa produrre il gruppo "ICU_armlab_light_patrol_1" del livello 0. Basta elencare i gruppi che si voglio creare, in base al livello, nel paragrafo 2b
-------------------------------------------------------------------------------

---------------
-- ICU gruppi creati per il lvl 0÷4 -------- 
---------------
-- armlab
	["ICU_armlab_light_patrol_1"] = {
		units = { "icupatroller", "icupatroller", "icurock", "icurock" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armlab_light_patrol_2"] = {
		units = { "icuwar", "icupatroller", "icurock", "icurock" },				
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armvp	
	["ICU_armvp_light_patrol_1"] = {
		units = { "armfav", "icuflash", "icuflash", "icuflash" }, 
		type = "ground"
	},
	["ICU_armvp_light_patrol_2"] = {
		units = { "armsam", "armsam", "armstump", "armpincer", "armpincer","tawf013" }, 
		type = "ground"
	},	
-- armap	
	["ICU_armap_air_raid_1"] = { 			
		units = { "armkam", "armfig", "armfig", "armkam", "armkam" },
		type = "air_toground"
	},
	["ICU_armap_antiair_raid_1"] = { 
		units = { "armfig", "armfig", "armfig" },
		type = "air_toair"
	},
	["ICU_armap_air_bomber_1"] = { 
		units = { "armthund", "armthund", "armthund", "armthund", "armthund" }, 	-- gruppo da 5 bombardieri
		type = "air_bomber"
	},	
--	["naval_fleet"] = {
--		units = { "corbats", "corbats", "corbats" },
--		type = "naval"
--	}
-- armalab
	["ICU_armalab_light_patrol_1"] = {
		units = { "armfast", "armfast", "armfast" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armalab_light_patrol_2"] = {
		units = { "armfast", "armfast", "armzeus" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armavp
	["ICU_armavp_light_patrol_1"] = {
		units = { "armmart", "armmart", "armlatnk" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armavp_light_patrol_2"] = {
		units = { "armlatnk", "armlatnk"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armaap
	["ICU_armaap_light_patrol_1"] = {
		units = { "armhawk", "armhawk", "armhawk" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armaap_light_patrol_2"] = {
		units = { "armhawk", "armhawk"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
---------------
-- AND gruppi creati per il lvl 0÷4 -------- 
---------------
	["AND_andlab_light_patrol_1"] = {
		units = { "andscouter", "andscouter", "andscouter", "andscouter" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["AND_andlab_light_patrol_2"] = {
		units = { "andscouter", "anddauber", "anddauber", "andbrskr" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["AND_andalab_light_patrol_1"] = { 
		units = { "walker", "walker", "exxec", "andogre" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["AND_andalab_light_patrol_2"] = { 
		units = { "andogre", "interceptor", "walker", "exxec" },
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
	["AND_andhp_light_patrol_1"] = {
		units = { "andgaso", "andlipo", "andlipo", "andgaso" }, 
		type = "ground_hovercraft"
	},
	["AND_andhp_light_patrol_2"] = {
		units = { "andgaso", "andlipo", "andlipo", "andgaso","andmisa","andmisa" }, 
		type = "ground_hovercraft"
	},	
	["AND_andahp_light_patrol_1"] = {
		units = { "androck", "andtanko", "andtesla", "andnikola" }, 
		type = "ground_hovercraft"
	},	
	["AND_andahp_light_patrol_2"] = {
		units = { "andnikola", "andnikola", "androck", "androck", "andtanko" }, 
		type = "ground_hovercraft"
	},		
	["AND_andplatplat_air_raid_1"] = { 			
		units = { "andstr", "andfig", "andfig", "andstr", "andstr" },
		type = "air_toground"
	},
	["AND_andplat_antiair_raid_1"] = { 
		units = { "andfig", "andfig", "andfig" },
		type = "air_toair"
	},
	["AND_andplat_air_bomber_1"] = { 
		units = { "andbomb", "andbomb", "andbomb", "andbomb", "andbomb" }, 	-- gruppo da 5 bombardieri
		type = "air_bomber"
	},		
	["AND_andaplatplat_air_raid_1"] = { 			
		units = { "anddragon", "corhors", "corhors" },
		type = "air_toground"
	},
	["AND_andaplat_air_bomber_1"] = { 
		units = { "anddragon", "anddragon", "corhors", "corhors", "corhors" }, 	
		type = "air_bomber"
	},		
	["AND_andaplat_air_bomber_2"] = { 
		units = { "anddragon", "anddragon", "corhors", "corhors", "corhors" }, 	
		type = "air_bomber_strategic"
	},				

-------------------------------------------------------------------------------
-- Elenco di produzioni per l'AI al livello 5+ - le fabbriche avranno gruppi più numerosi e composti da unità più forti 
-------------------------------------------------------------------------------
	
---------------
-- ICU gruppi creati per il lvl 5+ -------- 
---------------
-- armlab
	["ICU_armlab_medium_patrol_1"] = {
		units = { "icuwar", "icuwar", "icuwar", "icurock", "icurock" , "icurock", "icuinv", "armjeth"  }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armlab_medium_patrol_2"] = {
		units = { "icuwar", "icuwar", "icurock", "icurock", "icurock", "icurock", "armjeth", "icuinv", "icuinv" },				
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armvp	
	["ICU_armvp_medium_patrol_1"] = {
		units = { "armsam", "armsam", "armsam", "tawf013", "armsam", "armstump", "armpincer", "armsam" }, 
		type = "ground"
	},
	["ICU_armvp_medium_patrol_2"] = {
		units = { "armsam", "armsam", "armsam", "tawf013", "armstump", "tawf013", "armstump", "armpincer", "armpincer", "armpincer" }, 
		type = "ground"
	},	
-- armap	
	["ICU_armap_air_mediumraid_1"] = { 			
		units = { "armkam", "armfig", "armfig", "armkam", "armkam", "armkam", "armkam", "armkam", "armkam", "armkam" },
		type = "air_toground"
	},
	["ICU_armap_antiair_mediumraid_1"] = { 
		units = { "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig", "armfig" },
		type = "air_toair"
	},
	["ICU_armap_air_mediumbomber_1"] = { 
		units = { "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund" }, 	-- gruppo da 10 bombardieri
		type = "air_bomber"
	},	
	["ICU_armap_air_mediumstrategicbomber_1"] = { 
		units = { "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund", "armthund" }, 	-- gruppo da 12 bombardieri
		type = "air_bomber_strategic"
	},				
--	["naval_fleet"] = {
--		units = { "corbats", "corbats", "corbats" },
--		type = "naval"
--	}
-- armalab
	["ICU_armalab_medium_patrol_1"] = {
		units = { "icufboy", "icufboy", "icufboy", "armaak", "icufboy", "icufboy", "armfido" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armalab_medium_patrol_2"] = {
		units = { "armsptk", "armsptk", "armsptk", "armsptk", "armsptk", "armaak", "armsptk", "armsptk" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
-- armavp
	["ICU_armavp_medium_patrol_1"] = {
		units = { "armmart", "armmart", "armyork", "armmart", "armmart", "armmart", "armmart", "armmart", "armmart", "icubull", "icubull" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armavp_medium_patrol_2"] = {
		units = { "armlatnk", "armlatnk", "icubull", "icubull", "armmart", "armyork"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armavp_medium_patrol_3"] = {
		units = { "armlatnk", "armlatnk", "icubull", "icubull", "armmart", "armyork", "armmanni", "armcroc", "armcroc"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
-- armaap
	["ICU_armaap_medium_patrol_1"] = {
		units = { "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk", "armhawk" }, 
		type = "air_toair" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},
	["ICU_armaap_medium_patrol_2"] = {
		units = { "blade", "blade", "armbrawl", "armbrawl", "blade", "blade", "armbrawl", "armbrawl", "armbrawl", "armbrawl"}, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
	["ICU_armaap_air_bomber_1"] = { 
		units = { "armbrawl", "armbrawl", "armbrawl", "armbrawl", "armpnix", "armpnix", "armbrawl", "armbrawl", "armbrawl" }, 	
		type = "air_bomber"
	},		
	["ICU_armaap_air_bomber_2"] = { 
		units = { "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix", "armpnix" }, 	
		type = "air_bomber_strategic"
	},		
-- icugant
	["ICU_icugant_medium_patrol_1"] = {
		units = { "armshock", "armshock", "armtigre" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},		
	["ICU_icugant_medium_patrol_2"] = {
		units = { "armshock", "armshock" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},			
	["ICU_icugant_medium_patrol_3"] = {
		units = { "armtigre", "armtigre" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},			
-- armshltx
	["ICU_armshltx_medium_patrol_1"] = {
		units = { "icuraz", "icuraz", "icuraz" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armshltx_medium_patrol_2"] = {
		units = { "icuraz", "icuraz", "icuraz", "icuraz", "warhammer" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armshltx_medium_patrol_3"] = {
		units = { "icufurie" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},	
	["ICU_armshltx_medium_patrol_4"] = {
		units = { "icufurie", "icuraz","icuraz" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},			
	["ICU_armshltx_medium_patrol_5"] = {
		units = { "warhammer", "warhammer", "icuraz","icuraz" }, 
		type = "ground" -- squadtype, nella logica di targeting (punto 4) andrà a definire cosa attaccare 
	},				
---------------
-- AND gruppi creati per il lvl 5+ -------- 
---------------
-- ################################## da completare	
} -- end tabella squadre

--------------------------------------------------------------------------------
-- 2b) CONFIGURAZIONE FABBRICHE E BUILDLIST
--------------------------------------------------------------------------------
-- Funzione CONFIGURAZIONE FABBRICHE in base al teamLevels, selezionare gli squad_templates (le liste di costruzione)
-- ad ogni livello il numero di unità x squadra aumenta come aumenta la qualità delle unità prodotte
-- ogni livello è indipendente per ogni team
local teamLevels = {}       -- Tabella: [teamID] = livello attuale dell'AI per ogni singolo team (0, 1, 2...)
local teamConfigs = {}      -- Tabella: [teamID] = la FACTORY_CONFIG specifica per livello di ogni team
local FACTORY_CONFIG = {} 		-- all'inizio imposto la tabella vuota ################################  SOSTITUIRE???

local function GetConfigPerLivello(livello) -- Questa funzione restituisce, per ciascun team, la tabella delle fabbriche in funzione del livello corrente del team
    if livello <= 4 then					
        return {
            -- ICU --
            ["armlab"] = { "ICU_armlab_light_patrol_1", "ICU_armlab_light_patrol_2" },
            ["armvp"] = { "ICU_armvp_light_patrol_1", "ICU_armvp_light_patrol_2" },
            ["armap"]  = { "ICU_armap_antiair_raid_1", "ICU_armap_air_raid_1","ICU_armap_air_bomber_1" },			
            ["armalab"] = { "ICU_armalab_light_patrol_1", "ICU_armalab_light_patrol_2" },							-- inseriti in caso di recessione della AI dal livello 4+ a 0
            ["armavp"] = { "ICU_armavp_light_patrol_1", "ICU_armavp_light_patrol_2" },			
            ["armaap"]  = { "ICU_armaap_light_patrol_1", "ICU_armaap_light_patrol_2"},			
            -- AND -- ################### CONCLUDERE
            ["andlab"] = { "AND_andlab_light_patrol_1", "AND_andlab_light_patrol_2" },
            ["andalab"] = { "AND_andalab_light_patrol_1", "AND_andalab_light_patrol_2" }, 
            ["andhp"] = { "AND_andhp_light_patrol_1", "AND_andhp_light_patrol_2" },
            ["andahp"] = { "AND_andahp_light_patrol_1", "AND_andahp_light_patrol_2" },        
            ["andplat"]  = { "AND_andplatplat_air_raid_1", "AND_andplat_antiair_raid_1","AND_andplat_air_bomber_1" },
            ["andaplat"]  = { "AND_andaplatplat_air_raid_1", "AND_andaplat_air_bomber_1","AND_andaplat_air_bomber_2" },
        }
    elseif livello > 4 then
        return {
            -- ICU --
            ["armlab"] = { "ICU_armlab_medium_patrol_1", "ICU_armlab_medium_patrol_2" },
            ["armvp"] = { "ICU_armvp_medium_patrol_1", "ICU_armvp_medium_patrol_2" },
            ["armap"]  = { "ICU_armap_air_mediumraid_1", "ICU_armap_antiair_mediumraid_1","ICU_armap_air_mediumbomber_1","ICU_armap_air_mediumstrategicbomber_1" },
            ["armalab"] = { "ICU_armalab_medium_patrol_1", "ICU_armalab_medium_patrol_2" },			
            ["armavp"] = { "ICU_armavp_medium_patrol_1", "ICU_armavp_medium_patrol_2", "ICU_armavp_medium_patrol_3" },
            ["armaap"]  = { "ICU_armaap_medium_patrol_1", "ICU_armaap_medium_patrol_2","ICU_armaap_air_bomber_1","ICU_armaap_air_bomber_2" },		
            ["icugant"] = { "ICU_icugant_medium_patrol_1", "ICU_icugant_medium_patrol_2", "ICU_icugant_medium_patrol_3" },		
            ["armshltx"] = { "ICU_armshltx_medium_patrol_1", "ICU_armshltx_medium_patrol_2", "ICU_armshltx_medium_patrol_3", "ICU_armshltx_medium_patrol_4", "ICU_armshltx_medium_patrol_5" },		
            -- AND -- ################### CONCLUDERE
            ["andlab"] = { "AND_andlab_light_patrol_1", "AND_andlab_light_patrol_2" },
            ["andhp"] = { "AND_andhp_light_patrol_1", "AND_andhp_light_patrol_2" },
            ["andplat"]  = { "AND_andplatplat_air_raid_1", "AND_andplat_antiair_raid_1","AND_andplat_air_bomber_1" },
        }
    end
    return {} -- default vuoto
end

local TARGET_AI_NAME = "WarMachinesRTSmissionAI" 
local SQUAD_TIMEOUT_SECONDS = 600 -- questo timeout definisce i secondi di attesa per la formazione del gruppo delle unità uscite dalla fabbrica. Oltre questo timeout il gruppo si completa cosi com'è e parte all'attacco o difesa 

--------------------------------------------------------------------------------
-- 3) VARIABILI
--------------------------------------------------------------------------------

local aiTeamIDs = {}      
local factories = {}      
local squads = {}     
local basePoint = {}		-- Tabella: [teamID] = coordinate del punto base per ogni singolo team (0, 1, 2...)
local baseRadius = {}		-- Tabella: [teamID] = raggio di difesa della base per ogni singolo team (0, 1, 2...)
local warStatus = {}		-- Tabella: [teamID] = stato di guerra  per ogni singolo team (0, 1, 2...), può essere "attacco", "difesa_leggera", "difesa_pesante". Si veda "wmrts_AI_constructionManagement.lua" per maggiori dettagli    

--------------------------------------------------------------------------------
-- 4) LOGICA DI TARGETING BASATA SU DATABASE
--------------------------------------------------------------------------------

-- Funzione per ottenere la categoria dal NOSTRO database
local function GetUnitCategoryFromDB(unitID)
	local uDefID = Spring.GetUnitDefID(unitID)	-- definizione di Spring.GetUnitDefID(unitID)
	if not uDefID then return "unknown" end		-- se non esiste ID assegnato all'unità la funzione restituisce il valore "unknown"
	local unitName = UnitDefs[uDefID].name		-- altrimenti prosegui e assegna a unitrname il nome dell'unità
	
	if UNIT_DB[unitName] then					-- se nel database è presente la voce col il nome dell'unità (unitName)
		return UNIT_DB[unitName].type			-- restituisci type inerente al nome di quella unità
	end											
	return "unknown" 							-- altrimenti se niente di cui sopra è avvenuto, restituisci "unknown"
end

-- Funzione per trovare il bersaglio 
local function GetSmartEnemyTarget(myTeamID, squadType, searchCenter, searchRadius)
    local allUnits = Spring.GetAllUnits()
    local gaiaTeamID = Spring.GetGaiaTeamID()
    local bestTarget = nil
    local highestPriority = -1

    for i = 1, #allUnits do
        local uID = allUnits[i]
        local uTeam = Spring.GetUnitTeam(uID)
        
        if uTeam ~= gaiaTeamID and not Spring.AreTeamsAllied(myTeamID, uTeam) then
            local enemyCat = GetUnitCategoryFromDB(uID)
            local x, y, z = Spring.GetUnitPosition(uID)
            
            if x then
                local inRange = true
                if searchCenter and searchRadius then
                    local dx = x - searchCenter.x
                    local dz = z - searchCenter.z
                    if (dx*dx + dz*dz) > (searchRadius * searchRadius) then
                        inRange = false
                    end
                end     

                if inRange then
                    -- Verifichiamo la corrispondenza
                    local match = false
                    if squadType == "ground" or squadType == "ground_hovercraft" then
                        if enemyCat == "ground" or enemyCat == "unknown" or enemyCat == "building" or enemyCat == "strategicbuilding" or enemyCat == "strategicdefence" or enemyCat == "defence" or enemyCat == "strategicshield" then 
                            match = true
                        elseif enemyCat == "hover" then
                            match = true
                        end
                    elseif squadType == "air_toair" and enemyCat == "air" then match = true
                    elseif squadType == "air_toground" and (enemyCat == "ground" or enemyCat == "naval" or enemyCat == "hover") then match = true
                    elseif squadType == "air_bomber" or squadType == "air_bomber_strategic" then
                        -- [Tua logica priorità...]
                        match = true -- Semplificato per brevità
                    end

                    if match then
                        -- Se è una squadra normale (non bombardieri), restituisci il primo trovato
                        if not (squadType == "air_bomber" or squadType == "air_bomber_strategic") then
                            return {x=x, y=y, z=z, id=uID}
                        else
                            -- Per i bombardieri calcola la priorità...
                            bestTarget = {x=x, y=y, z=z, id=uID}
                        end
                    end
                end
            end
        end
    end
    return bestTarget -- Restituisce nil se proprio non trova nulla
end

--------------------------------------------------------------------------------
-- 5) GESTIONE ORDINI E GADGET CORE 
--------------------------------------------------------------------------------
local function GiveAttackOrder(unitID, targetData)
    if not targetData then
		Spring.Echo("WMRTS Debug: Nessun target trovato per unità " .. unitID)
		return 
	end 
	Spring.Echo("WMRTS Debug: Ordine inviato a " .. unitID .. " verso X:" .. targetData.x)
    local udID = Spring.GetUnitDefID(unitID)
    local ud = UnitDefs[udID]
    local unitName = ud.name
    local dbEntry = UNIT_DB[unitName]
    -- Se l'unità è un bombardiere o un cecchino (isLRA), usa l'ID per la massima precisione
    if targetData.id and (dbEntry and (dbEntry.type == "air_bomber" or "air_bomber_strategic")) then
        Spring.GiveOrderToUnit(unitID, CMD.ATTACK, {targetData.id}, {})
    else
        -- Per tutte le altre unità (Ground, Hover, ecc.), usa le coordinate.
        -- Aggiungiamo un piccolo "offset" casuale così non puntano tutte allo stesso pixel identico
        local tx = targetData.x + math.random(-250, 250) 	-- offset di 250 px
        local tz = targetData.z + math.random(-250, 250)	-- offset di 250 px
        local ty = Spring.GetGroundHeight(tx, tz)
        
        -- Usiamo FIGHT per le truppe di terra: si muovono e sparano se vedono nemici
        Spring.GiveOrderToUnit(unitID, CMD.FIGHT, {tx, ty, tz}, {})
    end
end

-- Questa funzione serve ad evitare che l'AI "rubi" o interferisca con unità non sue (ad esempio di altre AI), ci si assicura che le tabelle siano sempre pulite. In questo modo se spring dovesse riassegnare l'ID di una unità distrutta ad un altra squadra, il codice non lo utilizza come se fosse sua
function gadget:UnitDestroyed(unitID, unitDefID, unitTeam)
    -- 1. Se muore una fabbrica, cancellala subito dalle nostre liste
    if factories[unitID] then
        factories[unitID] = nil
    end

    -- 2. Se muore un'unità, rimuovila da qualsiasi squadra (squads) la stia usando
    for sID, sData in pairs(squads) do
        for i = #sData.units, 1, -1 do
            if sData.units[i] == unitID then
                table.remove(sData.units, i)
            end
        end
    end
end

-- Come UnitDestroyed ma in caso di "cambio di proprietà" (es. se un'unità viene catturata)
function gadget:UnitTaken(unitID, unitDefID, unitOldTeam, unitNewTeam)
    gadget:UnitDestroyed(unitID, unitDefID, unitOldTeam)
end

function gadget:Initialize()
	local teamList = Spring.GetTeamList()
	for _, teamID in ipairs(teamList) do
		local assignedAI = Spring.GetTeamLuaAI(teamID)
		if assignedAI and string.find(string.lower(assignedAI), string.lower(TARGET_AI_NAME)) then
			aiTeamIDs[teamID] = true
            teamLevels[teamID] = -1 						-- era 0, impostazione livello 0 per il team corrente (for... do...) 
            teamConfigs[teamID] = GetConfigPerLivello(0)	-- impostazione livello 0 per il team corrente (for... do...) 
		end
	end
end

-- Funzione per restituire true se l'unità è segnata come ignore nel DB WMRTS_AI_mission_db.lua (ignore = true). sono ignore = true tutte le unità che non devono essere gestite in questo gadget (come gruppi da mandare all'attacco)
local function IsUnitIgnored(unitID)
	local uDefID = Spring.GetUnitDefID(unitID)				-- definisci localmente uDefID
	if not uDefID then return false end						-- se uDefID non è presente restituisci false (usato per altre logiche)
	local unitName = UnitDefs[uDefID].name					-- altrimenti prosegui e definisci localmente unitName
	
	if UNIT_DB[unitName] and UNIT_DB[unitName].ignore then	-- se nel database è presente l'unità unitName, e la voce "ignore" di quella unità = true allora...
		return true											-- ...restituisci true (usato poi per altre logiche)
	end
	return false											-- ...altrimenti restituisci false (usato poi per altre logiche)
end

function gadget:UnitFinished(unitID, unitDefID, unitTeam)
		-- CONTROLLO SE IL TEAM NON è L'AI
    if not aiTeamIDs[unitTeam] then return end 				-- se il team non è AI non fare niente, esci
	    -- CONTROLLO IGNORE: Se l'unità deve essere ignorata, definita nel database (ignore = true) esci subito e non gestire l'unità
    if IsUnitIgnored(unitID) then							-- utilizza la funzione IsUnitIgnored per capire se l'unità in questione è impostata con " ignore = true" nel file "WMRTS_AI_mission_db.lua", e restituisci true o false. se true non fare niente
         Spring.Echo("WMRTS_militMngm_AI: Unità ignorata per design: " .. unitID)
        return 
    end
		-- Altrimenti (se ignore = false o non impostate) associa l'unità ad una squadra
    local unitName = UnitDefs[unitDefID].name
    local config = teamConfigs[unitTeam]     	-- Recupero la configurazione attuale di QUESTO team
    if config and config[unitName] then 		-- 2) Controllo se il nome dell'unità appena finita è presente nella lista fabbriche e se config è NIL (per sicurezza), non facciamo nulla
        factories[unitID] = { defName = unitName, squadID = nil, teamID = unitTeam }
        return
    end
	local bestFactoryID = nil
	local nearestDist = 3000					-- distanza per associare l'unità creata alla fabbrica più vicino entro il valore "nearest", se non è presente alcuna fabbrica, l'unità rimane orfana
	for fID, fData in pairs(factories) do
		if fData.teamID == unitTeam then
			local dist = Spring.GetUnitSeparation(unitID, fID)
			if dist and dist < nearestDist then
				if fData.squadID and squads[fData.squadID] then
					nearestDist = dist
					bestFactoryID = fID
				end
			end
		end
	end

	if bestFactoryID then
		local fData = factories[bestFactoryID]
		local sID = fData.squadID
		local squad = squads[sID]
		table.insert(squad.units, unitID)
		
		if squad.state == "gathering" then
			local fX, _, fZ = Spring.GetUnitPosition(bestFactoryID)
			Spring.GiveOrderToUnit(unitID, CMD.MOVE, {fX + math.random(-300,300), 0, fZ + math.random(300,500)}, {"shift"})
		elseif squad.state == "attacking_monitor" then
			GiveAttackOrder(unitID, squad.attackTarget)
		end
	end
end

function gadget:GameFrame(n)
    if (n % 30 ~= 0) then return end 

	-- Prelevo le variabili globali gestite dal gadget "wmrts_AI_constructionManagement.lua" e che servono in questo.
	for teamID, _ in pairs(aiTeamIDs) do
	-- GESTIONE DEI LIVELLI (CARICO I LIVELLI DALLA VARIABILE GLOBALE GESTITA DA constructionManagement GADGET 
    local newL = (GG.WMRTS_Levels and GG.WMRTS_Levels[teamID]) or 0		-- Leggo il valore globale (se non esiste ancora, considero livello 0)
        if teamLevels[teamID] ~= newL then 								-- Se il livello del team è cambiato (o non è ancora inizializzato)
            teamLevels[teamID] = newL
            teamConfigs[teamID] = GetConfigPerLivello(newL)
            Spring.Echo("WMRTS_militMngm_AI:: Team " .. teamID .. " si è allineato al livello " .. newL)
        end
	-- GESTIONE DEL PUNTO DELLA BASE, indica dove è il centro della base
        local newBP = GG.AI_BasePos and GG.AI_BasePos[teamID]
        if newBP then
            -- Se non esiste ancora una posizione locale, o se le coordinate sono cambiate
            if not basePoint[teamID] or 
               basePoint[teamID].x ~= newBP.x or 
               basePoint[teamID].z ~= newBP.z then
                
                basePoint[teamID] = {x = newBP.x, y = newBP.y, z = newBP.z}
                Spring.Echo(string.format("WMRTS_militMngm_AI:: Team %d BasePos: X=%.0f Z=%.0f", teamID, newBP.x, newBP.z))
            end
        end
	-- GESTIONE DEL RAGGIO DI DIFESA DAL PUNTO DELLA BASE, servirà, in funzione dello stato di guerra, a mandare all'attacco le truppe o a difendere la base entro questo raggio
	local newRadius = (GG.AI_RaggioDifesa and GG.AI_RaggioDifesa[teamID]) or 100 				-- imposto un raggio di default poi tanto si aggiorna automaticamente	
        if baseRadius[teamID] ~= newRadius then 												-- Se il raggio di difesa del team è cambiato...
            baseRadius[teamID] = newRadius
            Spring.Echo("WMRTS_militMngm_AI:: Team " .. teamID .. " ha impostato il raggio della base a: " .. newRadius)
        end		
	-- GESTIONE DELLO STATO DI GUERRA, servirà per mandare in attacco le truppe, difendere lievemente la base o difenderla pesantemente
	local newWS = (GG.AI_StatoGuerra and GG.AI_StatoGuerra[teamID]) or "attacco" 		-- imposto l'attacco di default, poi tanto si aggiorna automaticamente
        if warStatus[teamID] ~= newWS then 												-- se lo stato di guerra è cambiato...
            warStatus[teamID] = newWS
            Spring.Echo("WMRTS_militMngm_AI:: Team " .. teamID .. " ha impostato lo stato di guerra a: " .. newWS)
        end			
--	local nuovoStato = (GG.AI_StatoGuerra and GG.AI_StatoGuerra[teamID]) or "attacco" 		-- imposto l'attacco di default, poi tanto si aggiorna automaticamente

    end

    -- GESTIONE FABBRICHE
    for fID, fData in pairs(factories) do
        local qSize = Spring.GetCommandQueue(fID, 0)
        
        if qSize == nil then
            factories[fID] = nil 
        else		
            local isBuilding = Spring.GetUnitIsBuilding(fID)
            local isLocked = false
            
            if fData.squadID and squads[fData.squadID] then
                if (qSize > 0) or isBuilding or (squads[fData.squadID].state == "gathering") then
                    isLocked = true
                else
                    fData.squadID = nil
                end
            end

            if not isLocked and qSize == 0 and not isBuilding then
                -- RECUPERO LA CONFIGURAZIONE SPECIFICA DI QUEL TEAM
                local configDelTeam = teamConfigs[fData.teamID]
                if configDelTeam then
                    local options = configDelTeam[fData.defName]
                    if options then
                        local templateName = options[math.random(1, #options)]
                        local template = SQUAD_TEMPLATES[templateName]
                        if template then
                            -- ... (il resto della tua logica di creazione squadID rimane uguale)
                            local newSquadID = n .. "_" .. fID
                            squads[newSquadID] = {
                                units = {},
                                targetSize = #template.units,
                                state = "gathering",
                                startTime = Spring.GetGameSeconds(),
                                myTeam = fData.teamID,
                                attackTarget = nil,
                                type = template.type 
                            }
                            fData.squadID = newSquadID
                            for _, uName in ipairs(template.units) do
                                local uDef = UnitDefNames[uName]
                                if uDef then Spring.GiveOrderToUnit(fID, -uDef.id, {}, {}) end
                            end
                        end
                    end
                end
            end
        end
    end

	-- GESTIONE SQUADRE
	for sID, sData in pairs(squads) do
		local teamID = sData.myTeam
		local currentWarStatus = warStatus[teamID] or "attacco"
		local bPos = basePoint[teamID]
		local bRad = baseRadius[teamID]
			-- LOGICA DI FORZATURA STATO (SCRAMBLE)
		if sData.state == "gathering" then
			local forceStart = false
			if currentWarStatus == "difesa_pesante" then
				forceStart = true -- Tutti fuori subito!	
				Spring.Echo("WMRTS_militMngm_AI:: Team " .. teamID .. " SCRAMBLE PESANTE!")
			elseif currentWarStatus == "difesa_leggera" then
				-- Verifica se la squadra (almeno la prima unità) è in base
				if #sData.units > 0 and bPos then
					local ux, uy, uz = Spring.GetUnitPosition(sData.units[1])
					local dx, dz = ux - bPos.x, uz - bPos.z
					if (dx*dx + dz*dz) < (bRad * bRad) then
						forceStart = true -- La squadra è in base, falla reagire
						Spring.Echo("WMRTS_militMngm_AI:: Team " .. teamID .. " SCRAMBLE LEGGERO (Unità in base)") -- log squadra in base che esce
					end
				end
			end				
	-- Se è passato il tempo normale O se dobbiamo forzare la difesa
			if #sData.units >= sData.targetSize or (Spring.GetGameSeconds() - sData.startTime) > SQUAD_TIMEOUT_SECONDS or forceStart then
				sData.state = "attacking_monitor"
	-- Al primo avvio, cerchiamo il target in base allo stato		
				local sCenter = (currentWarStatus ~= "attacco") and bPos or nil
				local sRadius = (currentWarStatus ~= "attacco") and bRad or nil	
				sData.attackTarget = GetSmartEnemyTarget(teamID, sData.type, sCenter, sRadius)

				
				-- Se non trova nemici in base durante una difesa, cerchiamo ovunque (fallback)
				if not sData.attackTarget then 
					sData.attackTarget = GetSmartEnemyTarget(teamID, sData.type) 
				end
				-- FALLBACK FINALE: Se proprio non c'è nessuno sulla mappa
				if not sData.attackTarget then
					sData.attackTarget = { x = Game.mapSizeX/2, y = 0, z = Game.mapSizeZ/2 }  -- porta al centro della mappa ##### verificare poi cosa fare (forse è meglio mandarle in pattuglia da dove sono al centro della base???????) ######## molix
				end				

				for _, uID in ipairs(sData.units) do
					if Spring.ValidUnitID(uID) then GiveAttackOrder(uID, sData.attackTarget) end
				end
			end
			
		-- 2. LOGICA DI MONITORAGGIO ATTACCO/DIFESA
		elseif sData.state == "attacking_monitor" then
			if n % 90 == 0 then
				local anyAlive = false
				local anyIdle = false
				
				-- Calcoliamo la posizione media della squadra (opzionale, per difesa_leggera)
				local avgX, avgZ = 0, 0
				local aliveCount = 0

				for i = #sData.units, 1, -1 do
					local uID = sData.units[i]
					if Spring.ValidUnitID(uID) and not Spring.GetUnitIsDead(uID) then
						anyAlive = true
						local ux, _, uz = Spring.GetUnitPosition(uID)
						avgX, avgZ = avgX + ux, avgZ + uz
						aliveCount = aliveCount + 1
						if Spring.GetCommandQueue(uID, 0) == 0 then anyIdle = true end
					else
						table.remove(sData.units, i)
					end
				end
				
				if anyAlive and anyIdle then
					avgX, avgZ = avgX / aliveCount, avgZ / aliveCount
					
					-- Determiniamo se questa specifica squadra deve limitarsi alla base
					local useBaseLimit = false
					if currentWarStatus == "difesa_pesante" then
						useBaseLimit = true
					elseif currentWarStatus == "difesa_leggera" then
						-- Limita alla base solo se la squadra è fisicamente vicina alla base
						local dx, dz = avgX - bPos.x, avgZ - bPos.z
						if (dx*dx + dz*dz) < (bRad * bRad) then
							useBaseLimit = true
						end
					end

					local sCenter = useBaseLimit and bPos or nil
					local sRadius = useBaseLimit and bRad or nil

					sData.attackTarget = GetSmartEnemyTarget(teamID, sData.type, sCenter, sRadius)
					
					-- Fallback: se in difesa non c'è nessuno, cerca bersagli normali (contrattacco)
					if not sData.attackTarget then
						sData.attackTarget = GetSmartEnemyTarget(teamID, sData.type)
					end
                  -- FALLBACK 2: Se proprio non c'è nessuno sulla mappa, vai al centro (o in base)
                    if not sData.attackTarget then
                        sData.attackTarget = { x = Game.mapSizeX/2, y = 0, z = Game.mapSizeZ/2 }
                    end
					
					for _, uID in ipairs(sData.units) do
						-- Diamo l'ordine solo se l'unità è ferma
						if Spring.GetCommandQueue(uID, 0) == 0 then
							GiveAttackOrder(uID, sData.attackTarget)
						end
					end
				end -- fine if anyAlive and anyIdle
				if not anyAlive then squads[sID] = nil end
			end -- fine if n % 90
		end -- fine elseif attacking_monitor
	end	-- fine for sID, sData in pairs(squads)
end -- fine function gadget:GameFrame(n)