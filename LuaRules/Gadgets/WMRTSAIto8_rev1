--------------------------------------------------------------------------------
-- War Machines RTS - AI Gadget (v0.6 - Correzioni Multiple)
-- Nome AI: WMRTSAI
--------------------------------------------------------------------------------

function gadget:GetInfo()
  return {
    name      = "WMRTSAI", -- Nome usato per assegnare l'IA ai team!
    desc      = "AI con gestione fazioni, tiers, tipi mappa e config per livello tech.",
    author    = "Il Tuo Nome", -- Cambia questo!
    date      = "Data Corrente", -- Cambia questo!
    license   = "La Tua Licenza", -- Cambia questo!
    layer     = 90, -- Layer alto per eseguire dopo altri gadget (come Mexspot Fetcher)
    enabled   = true
  }
end

-- Variabili globali del gadget
local gameStarted = false
local teamData = {} -- Stato per ogni team AI
local WMRTSAI_Debug_Mode = 1 -- Iniziamo con debug attivo

--------------------------------------------------------------------------------
-- SYNCED CODE - Logica di gioco principale
--------------------------------------------------------------------------------
if (gadgetHandler:IsSyncedCode()) then

  -- Speedups e locali (CMD non serve più qui se usiamo Command.* o -ID)
  local Spring = Spring
  local Game = Game
  -- local CMD = Command -- Rimosso, usiamo Command.* o -ID
  local UnitDefs = UnitDefs
  local UnitDefNames = UnitDefNames

  local LOG_SECTION = "WMRTSAI"

  -- Funzione helper per il logging debug
  local function Log(teamID, message)
    if WMRTSAI_Debug_Mode > 0 then
      local teamPrefix = teamID and ("Team[" .. teamID .. "] ") or (LOG_SECTION .. ": ")
      Spring.Echo(teamPrefix .. message)
    end
  end

  -- === 1. DEFINIZIONE FAZIONI E UNITÀ PER TIER ===
  -- !! IMPORTANTE: Compila con NOMI ESATTI, moveType e role corretti !!
  local factionUnits = {
      ICU = {
          commander = "icucom",
          T1 = {
              extractor =   { name = "icumetex", moveType="BUILDING", role="Extractor_T1"},
              powerPlant =  { name = "armsolar", moveType="BUILDING", role="Power_T1"},
              factory =     { name = "armlab", moveType = "BUILDING", role="Factory_Land_T1"},
			  estorage =	{ name = "icuestor", moveType = "BUILDING", role="Estorage_T1"}, -- aggiunto
			  mstorage =	{ name = "armmstor", moveType = "BUILDING", role="Mstorage_T1"}, -- aggiunto			  
              constructor = { name = "icuck", moveType = "LAND", role="Constructor_T1" },
			  attackers = { 
							{ name = "icupatroller", moveType = "LAND", role="Basic_T1", viewradius = 429 } 
							-- Aggiungi altre unità attaccanti T1 qui se ne hai
						  },
              defenses = { { name = "iculighlturr", moveType = "BUILDING", role="Light_T1" }, }
          },
          T2 = {
              extractor =   { name = "armamex", moveType="BUILDING", role="Extractor_T2"},
              powerPlant =  { name = "armfus", moveType="BUILDING", role="Power_T2"},
              factory =     { name = "armalab", moveType = "BUILDING", role="Factory_Land_T2" },
              constructor = { name = "armack", moveType = "LAND", role="Constructor_T2" },
              attackers = { { name = "armfboy", moveType = "LAND", role="Heavy_T2" }, },
              defenses = { { name = "armhlt", moveType = "BUILDING", role="Heavy_T2" } }
          },
          T3 = {
              factory =     { name = "armshltx", moveType = "BUILDING", role="Factory_Land_T3" },
              -- constructor = { ... },
              attackers = { { name = "armshock", moveType = "LAND", role="Experimental_T3" }, },
              defenses = { { name = "armanni", moveType = "BUILDING", role="Experimental_T3" } }
          },
          _unitDefIDs = {}
      },
      NFA = { -- !! COMPILA !!
          commander = "nfacom",
          T1 = { extractor = { name = "nfa_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="nfa_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="nfa_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="nfa_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="nfa_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="nfa_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "nfa_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="nfa_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="nfa_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="nfa_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="nfa_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="nfa_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="nfa_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="nfa_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="nfa_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="nfa_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      },
       AND = { -- !! COMPILA !!
          commander = "andcom",
          T1 = { extractor = { name = "and_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="and_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="and_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="and_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="and_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="and_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "and_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="and_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="and_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="and_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="and_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="and_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="and_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="and_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="and_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="and_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      },
      EUF = { -- !! COMPILA !!
          commander = "eufcd",
          T1 = { extractor = { name = "euf_mex_t1", moveType="BUILDING", role="Extractor_T1" }, powerPlant = { name="euf_pow_t1", moveType="BUILDING", role="Power_T1" }, factory = {name="euf_factory_t1", moveType="BUILDING", role="Factory_Land_T1"}, constructor = {name="euf_con_t1", moveType="LAND", role="Constructor_T1"}, attackers = {{name="euf_attacker_t1", moveType="LAND", role="Basic_T1"}}, defenses = {{name="euf_defense_t1", moveType="BUILDING", role="Light_T1"}} },
          T2 = { extractor = { name = "euf_mex_t2", moveType="BUILDING", role="Extractor_T2" }, powerPlant = { name="euf_pow_t2", moveType="BUILDING", role="Power_T2" }, factory = {name="euf_factory_t2", moveType="BUILDING", role="Factory_Land_T2"}, constructor = {name="euf_con_t2", moveType="LAND", role="Constructor_T2"}, attackers = {{name="euf_attacker_t2", moveType="LAND", role="Heavy_T2"}}, defenses = {{name="euf_defense_t2", moveType="BUILDING", role="Heavy_T2"}} },
          T3 = { factory = {name="euf_factory_t3", moveType="BUILDING", role="Factory_Land_T3"}, constructor = {name="euf_con_t3", moveType="LAND", role="Constructor_T3"}, attackers = {{name="euf_attacker_t3", moveType="LAND", role="Experimental_T3"}}, defenses = {{name="euf_defense_t3", moveType="BUILDING", role="Experimental_T3"}} },
          _unitDefIDs = {}
      }
      -- Non serve sezione common se tutto è per fazione/tier
  }

  -- Mappa Comandante -> Fazione
  local commanderFactionMap = {
      icucom = "ICU",
      nfacom = "NFA",
      andcom = "AND",
      eufcd  = "EUF"
  }

  -- Funzione ricorsiva per popolare la tabella 'idTable' (es. factionUnits.ICU._unitDefIDs)
  -- con i dati da 'sourceDataTable' (es. factionUnits.ICU), aggiungendo il campo '.id'
  -- e copiando altri campi rilevanti come viewradius.
  local function PopulateUnitDefIDs(sourceDataTable, idTable, currentPath) -- Aggiunto currentPath per debug
      currentPath = currentPath or "factionUnits" -- Inizializza il percorso per il debug

      -- CONTROLLO INIZIALE PER sourceDataTable
      if type(sourceDataTable) ~= "table" then
          Log(nil, "ERROR PopulateUnitDefIDs: sourceDataTable at path '" .. currentPath .. "' is not a table (it is " .. type(sourceDataTable) .. "). Aborting this branch.")
          return
      end
      -- CONTROLLO INIZIALE PER idTable
      if type(idTable) ~= "table" then
          Log(nil, "ERROR PopulateUnitDefIDs: idTable for path '" .. currentPath .. "' is not a table (it is " .. type(idTable) .. "). Aborting this branch.")
          return
      end

      for key, valueFromSource in pairs(sourceDataTable) do
          local newPath = currentPath .. "." .. key -- Aggiorna il percorso per i log

          -- Processa la chiave solo se NON è "_unitDefIDs"
          if key ~= "_unitDefIDs" then 
              if type(valueFromSource) == "table" then
                  -- Caso 1: È una definizione di unità singola (es. commander, extractor, factory, constructor)
                  if valueFromSource.name and valueFromSource.moveType then 
                      local unitDef = UnitDefNames[valueFromSource.name]
                      if unitDef then
                          idTable[key] = {} 
                          for k, v in pairs(valueFromSource) do 
                              idTable[key][k] = v 
                          end
                          idTable[key].id = unitDef.id 
                          Log(nil, "PopulateUnitDefIDs ["..newPath.."]: Processed single unit '" .. key .. "' (" .. valueFromSource.name .. "), ID: " .. unitDef.id)
                      else
                          Log(nil, "ERROR PopulateUnitDefIDs ["..newPath.."]: Unit definition name '" .. valueFromSource.name .. "' not found for key '" .. key .. "'!")
                          idTable[key] = nil 
                      end

                  -- Caso 2: È una lista di unità (attackers, defenses)
                  elseif (key == "attackers" or key == "defenses") then 
                      idTable[key] = {} 
                      Log(nil, "PopulateUnitDefIDs ["..newPath.."]: Processing list '" .. key .. "'")
                      if type(valueFromSource) == "table" then -- Assicurati che la lista stessa sia una tabella
                          for i, unitDataFromSourceList in ipairs(valueFromSource) do
                              if type(unitDataFromSourceList) == "table" and unitDataFromSourceList.name and unitDataFromSourceList.moveType then
                                  local unitDef = UnitDefNames[unitDataFromSourceList.name]
                                  if unitDef then
                                      local newItem = {} 
                                      for k, v in pairs(unitDataFromSourceList) do 
                                          newItem[k] = v 
                                      end
                                      newItem.id = unitDef.id 
                                      table.insert(idTable[key], newItem) 
                                      Log(nil, "PopulateUnitDefIDs ["..newPath.."]:  - Added '" .. unitDataFromSourceList.name .. "' to list '"..key.."', ID: " .. unitDef.id)
                                  else
                                      Log(nil, "ERROR PopulateUnitDefIDs ["..newPath.."]: Unit definition name '" .. unitDataFromSourceList.name .. "' not found in list '" .. key .. "'!")
                                  end
                              else
                                  Log(nil, "WARN PopulateUnitDefIDs ["..newPath.."]: Invalid entry in list '"..key.."' at index "..i..". Missing name/moveType or not a table.")
                              end
                          end
                      else
                         Log(nil, "WARN PopulateUnitDefIDs ["..newPath.."]: List '"..key.."' is not a table, it's a "..type(valueFromSource)..". Skipping.")
                      end

                  -- Caso 3: È una sottotabella da processare ricorsivamente (T1, T2, T3, o altre sottostrutture)
                  else 
                      if not idTable[key] then 
                          idTable[key] = {} 
                      end
                      Log(nil, "PopulateUnitDefIDs ["..newPath.."]: Descending into sub-table '" .. key .. "'.")
                      PopulateUnitDefIDs(valueFromSource, idTable[key], newPath) -- Passa il nuovo percorso
                  end
              
              -- Caso 4: valueFromSource è una stringa (es. vecchio commander)
              elseif type(valueFromSource) == "string" and key == "commander" then
                   Log(nil, "PopulateUnitDefIDs ["..newPath.."]: Commander '"..valueFromSource.."' defined as string, ID not populated here. Define as table for ID population.")
              -- else Log(nil, "PopulateUnitDefIDs ["..newPath.."]: Key '"..key.."' has non-table, non-string-commander value type: " .. type(valueFromSource) .. ". Skipping.")
              end
          end -- Fine del if key ~= "_unitDefIDs"
      end -- Fine del for
  end -- Fine della funzione

  -- === 2. DEFINIZIONE CATEGORIE MAPPE ===
  local mapCategories = {
      ["zoty outpost"] = "LAND",
      ["altra_mappa_terra"] = "LAND",
      ["mappa_isole_1"] = "NAVAL_ISLANDS",
      ["arcadia bay"] = "NAVAL_ISLANDS",
      ["spazio_profondo_x"] = "SPACE",
      ["oceano_infinito"] = "NAVAL_PURE",
      -- ... aggiungi tutte le tue mappe ...
  }
 


  local currentMapCategory = "LAND" -- Default

  -- === 4. CONFIGURAZIONE AI PER TECH LEVEL ===
  local aiConfig = {
      [0] = {
          economyTargets = {
              { role = "T1_Extractor", min = 1, max = 2 },
              { role = "T1_PowerPlant", min = 1, max = 2 },
          },
          factoryTargets = { minTotal = 1, maxTotal = 1, targetTier = 1 },
          productionList = { },
          attackGroup = { min = 5, max = 8, target = "PATROL_NEARBY" }
      },
      [1] = {
          economyTargets = {
              { role = "T1_Extractor", min = 2, max = 3 },
              { role = "T1_PowerPlant", min = 2, max = 3 },
			  { role = "T1_Estorage", min = 1, max = 1 }, -- aggiunto magazzino energia x1
			  { role = "T1_Mstorage", min = 1, max = 1 }, -- aggiunto magazzino metallo x1
          },
          factoryTargets = { minTotal = 2, maxTotal = 3, targetTier = 1 },
          productionList = {
              { role = "T1_Constructor", priority = 100, max = 3 },
              { role = "T1_Attacker_Basic", priority = 80, max = 0 },
          },
          attackGroup = { min = 8, max = 12, target = "ATTACK_ENEMY_EXPANSION" }
      },
      [2] = {
          economyTargets = {
              { role = "T1_Extractor", min = 6, max = 8 },
              { role = "T1_PowerPlant", min = 8, max = 12 },
              { role = "T2_Extractor", min = 3, max = 5 },
              { role = "T2_PowerPlant", min = 4, max = 6 },
          },
          factoryTargets = { minTotal = 3, maxTotal = 5, targetTier = 2 },
          productionList = {
               { role = "T2_Constructor", priority = 100, max = 2 },
               { role = "T2_Attacker_Heavy", priority = 80, max = 0 },
               { role = "T1_Attacker_Basic", priority = 60, max = 0 },
          },
          attackGroup = { min = 10, max = 15, target = "ATTACK_ENEMY_BASE" }
      },
      [3] = {
          economyTargets = {
              { role = "T2_Extractor", min = 5, max = 8 },
              { role = "T2_PowerPlant", min = 6, max = 10 },
              -- { role = "T3_Extractor", min = 2, max = 4 },
              -- { role = "T3_PowerPlant", min = 3, max = 5 },
          },
          factoryTargets = { minTotal=4, maxTotal=7, targetTier=3 },
          productionList = {
             -- { role = "T3_Constructor", priority = 100, max = 1 },
             { role = "T3_Attacker_Experimental", priority = 90, max = 3 },
             { role = "T2_Attacker_Heavy", priority = 70, max = 0 },
          },
          attackGroup = { min = 12, max = 20, target = "ATTACK_ENEMY_BASE_PRIORITY" }
      }
  }

  -- === Funzioni Helper ===

  -- Helper: GetUnitDataByRole - Versione che gestisce eco tiered
  function GetUnitDataByRole(faction, tier, role)
      local factionData = factionUnits[faction]
      if not factionData then return nil end
      local fDefs = factionData._unitDefIDs
      if not fDefs then return nil end

      local roleTier = tonumber(role:match("^T(%d+)")) or 0
      if roleTier == 0 then return nil end

      local tierKey = "T" .. roleTier
      local tDefs = fDefs[tierKey]
      if not tDefs then return nil end

      if role == tierKey .. "_Constructor" then return tDefs.constructor
      elseif role == tierKey .. "_Factory" then return tDefs.factory
      elseif role == tierKey .. "_Extractor" then return tDefs.extractor
      elseif role == tierKey .. "_PowerPlant" then return tDefs.powerPlant
      elseif role == tierKey .. "_Estorage" then return tDefs.estorage -- Usa la chiave 'estorage' da factionUnits
      elseif role == tierKey .. "_Mstorage" then return tDefs.mstorage -- Usa la chiave 'mstorage' da factionUnits	  
      elseif role:find(tierKey .. "_Attacker") then
          if not tDefs.attackers or #tDefs.attackers == 0 then return nil end
          if role == tierKey .. "_Attacker_Basic" then return tDefs.attackers[1]
          elseif role == tierKey .. "_Attacker_Heavy" then return tDefs.attackers[1]
          elseif role == tierKey .. "_Attacker_Support" then return #tDefs.attackers >= 2 and tDefs.attackers[2] or nil
          elseif role == tierKey .. "_Attacker_Experimental" then return tDefs.attackers[1]
          else return tDefs.attackers[1] end
      elseif role:find(tierKey .. "_Defense") then
           if not tDefs.defenses or #tDefs.defenses == 0 then return nil end
           if role == tierKey .. "_Defense_Light" then return tDefs.defenses[1]
           elseif role == tierKey .. "_Defense_Heavy" then return #tDefs.defenses >= 2 and tDefs.defenses[2] or nil
           else return tDefs.defenses[1] end
      end

      -- Log(faction, "Warning: Role '"..role.."' could not be mapped.")
      return nil
  end


-- === FUNZIONE HELPER CON LOG AGGIUNTI ===
  -- Trova i dati AI per un unitDefID specifico nella nostra struttura factionUnits.
  -- Richiede che factionUnits sia popolata con gli ID tramite PopulateUnitDefIDs.
  -- Restituisce la tabella dell'unità {name=..., moveType=..., role=..., viewradius=..., id=...} o nil se non trovata.
   -- === FUNZIONE HELPER CON LOG AGGIUNTI (SENZA GOTO) ===
  local function GetAiUnitDataByDefID(unitDefID)
      if not unitDefID then 
          return nil 
      end

      Log(nil, "DEBUG GetAiUnitData: Searching for DefID: " .. unitDefID)

      -- Itera su tutte le fazioni definite in factionUnits
      for factionKey, factionSourceData in pairs(factionUnits) do
          -- Processa solo le chiavi che rappresentano fazioni e non sono "_unitDefIDs"
          if factionKey ~= "_unitDefIDs" and factionKey ~= "common" and factionKey ~= "_commonUnitDefIDs" and type(factionSourceData) == "table" then
              
              -- Log(nil, "DEBUG GetAiUnitData: Checking faction: " .. factionKey)

              -- IMPORTANTE: Dobbiamo cercare nella sottotabella _unitDefIDs
              local idProcessedFactionData = factionSourceData._unitDefIDs
              if not idProcessedFactionData then
                  Log(nil, "WARN GetAiUnitData: Faction "..factionKey.." does not have an _unitDefIDs sub-table. Skipping this faction.")
              else -- Procedi solo se _unitDefIDs esiste ed è una tabella
                  if type(idProcessedFactionData) ~= "table" then
                      Log(nil, "WARN GetAiUnitData: _unitDefIDs for faction "..factionKey.." is not a table. Type: "..type(idProcessedFactionData)..". Skipping this faction.")
                  else
                      -- Controlla il Comandante
                      if idProcessedFactionData.commander and 
                         type(idProcessedFactionData.commander) == "table" and 
                         idProcessedFactionData.commander.id and 
                         idProcessedFactionData.commander.id == unitDefID then
                          Log(nil, "DEBUG GetAiUnitData: Matched commander '".. (idProcessedFactionData.commander.name or "N/A") .."' in faction " .. factionKey .. " for DefID " .. unitDefID)
                          return idProcessedFactionData.commander 
                      end
                      
                      -- Itera sui tier (T1, T2, T3)
                      for tierKey, tierContent in pairs(idProcessedFactionData) do
                          if type(tierContent) == "table" and tierKey:find("^T%d") then
                              -- Log(nil, "DEBUG GetAiUnitData: Checking tier: " .. tierKey .. " in faction " .. factionKey)

                              for unitTypeKey, unitTypeValueOrList in pairs(tierContent) do
                                  if unitTypeKey == "attackers" or unitTypeKey == "defenses" then
                                      if type(unitTypeValueOrList) == "table" then
                                          for _, unitEntry in ipairs(unitTypeValueOrList) do
                                              -- Log(nil, "DEBUG GetAiUnitData: Checking list entry: "..tostring(unitEntry.name).." with ID: "..tostring(unitEntry.id)) 
                                              if type(unitEntry) == "table" and unitEntry.id and unitEntry.id == unitDefID then
                                                  Log(nil, "DEBUG GetAiUnitData: Matched list entry '" .. (unitEntry.name or "N/A") .. "' in " .. factionKey .. "." .. tierKey .. "." .. unitTypeKey .. " for DefID " .. unitDefID)
                                                  return unitEntry 
                                              end
                                          end
                                      end
                                  elseif type(unitTypeValueOrList) == "table" and unitTypeValueOrList.id then
                                      -- Log(nil, "DEBUG GetAiUnitData: Checking single entry: "..tostring(unitTypeValueOrList.name).." with ID: "..tostring(unitTypeValueOrList.id))
                                      if unitTypeValueOrList.id == unitDefID then
                                         Log(nil, "DEBUG GetAiUnitData: Matched single entry '" .. (unitTypeValueOrList.name or "N/A") .. "' in " .. factionKey .. "." .. tierKey .. "." .. unitTypeKey .. " for DefID " .. unitDefID)
                                         return unitTypeValueOrList 
                                      end
                                  end
                              end 
                          end 
                      end 
                  end -- fine else (idProcessedFactionData era una tabella)
              end -- fine if not idProcessedFactionData (controllo esistenza _unitDefIDs)
          end -- fine if factionKey non è speciale e factionSourceData è tabella
      end -- Fine ciclo Fazioni

      Log(nil, "WARN GetAiUnitData: Could not find AI data for DefID: " .. unitDefID .. " after checking all factions.")
      return nil 
  end



   -- Trova posizione Metallo - Aggiornato per leggere direttamente da GameRules (Fallback Definitivo per v100)
  function FindBestMetalSpotForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then Log(teamData.teamID, "FindBestMetalSpot: Builder position not found."); return nil end

      -- === LEGGI DIRETTAMENTE DALLE GAMERULES ===
      local mexCount = Spring.GetGameRulesParam("mex_count")
      -- ========================================

      local bestSpot = nil
      local minDistSq = math.huge
      local mexDefData = GetUnitDataByRole(teamData.faction, 1, "T1_Extractor")
      if not mexDefData then Log(teamData.teamID,"FindBestMetalSpot: Cannot find T1_Extractor definition!"); return nil end
      local mexDefID = mexDefData.id

      -- Itera usando i dati letti dalle GameRules
      if mexCount and mexCount > 0 then
           Log(teamData.teamID, "FindBestMetalSpot: Found " .. mexCount .. " metal spots in GameRules.") -- Debug
          for i = 1, mexCount do
               -- Leggi i dati per questo spot dalle GameRules
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotY = Spring.GetGameRulesParam("mex_y" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)

               -- Controlla se abbiamo ottenuto coordinate valide
               if spotX and spotY and spotZ then
                   -- Controlla se è occupato
                   local unitsNear = Spring.GetUnitsInRectangle(spotX-10, spotZ-10, spotX+10, spotZ+10)
                   local occupied = false
                   if unitsNear then
                       for _, nearID in ipairs(unitsNear) do
                           local nearDef = UnitDefs[Spring.GetUnitDefID(nearID)]
                           if nearDef and nearDef.extractsMetal and nearDef.extractsMetal > 0 then occupied = true; break end
                       end
                   end

                   if not occupied then
                      -- Controlla costruibilità usando TestBuildOrder
                      local buildResult = Spring.TestBuildOrder(mexDefID, spotX, spotY, spotZ, 1)
                      if buildResult == 0 or buildResult == 2 then
                          local dx, dz = spotX - bx, spotZ - bz
                          local distSq = dx*dx + dz*dz
                          if distSq < minDistSq then
                              minDistSq = distSq
                              bestSpot = {x=spotX, y=spotY, z=spotZ}
                          end
                       else Log(teamData.teamID, "Spot "..i.." not buildable, code: "..buildResult) -- Debug Build Fail
                      end
                    else Log(teamData.teamID, "Spot "..i.." occupied.") -- Debug Occupied
                   end
               else
                   Log(teamData.teamID, "FindBestMetalSpot: Warning - Got nil coordinate reading GameRules for mex index " .. i)
               end -- fine if spotX/Y/Z
          end -- fine ciclo for i=1, mexCount
      else
          Log(teamData.teamID, "FindBestMetalSpot: Could not find 'mex_count' or it was 0 in GameRules.")
      end -- fine if mexCount

      if bestSpot then Log(teamData.teamID,"Found best metal spot at " .. string.format("%.0f,%.0f", bestSpot.x, bestSpot.z) .. " using GameRules")
      else Log(teamData.teamID,"FindBestMetalSpot: No suitable metal spot found after checking GameRules.") end
      return bestSpot
  end

  -- Trova posizione Energia - Aggiornato per EVITARE Punti Metallo
  function FindGoodEnergySpotForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then return nil end

      local powerDefData = GetUnitDataByRole(teamData.faction, 1, "T1_PowerPlant") -- Cerca T1 power
      if not powerDefData then Log(teamData.teamID,"FindGoodEnergySpot: Cannot find T1_PowerPlant definition!"); return nil end
      local powerDefID = powerDefData.id

      -- Ottieni la lista dei punti metallo per evitarli
      local metalSpots = {}
      local mexCount = Spring.GetGameRulesParam("mex_count")
      if mexCount and mexCount > 0 then
          for i = 1, mexCount do
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)
               if spotX and spotZ then -- Non ci serve y qui
                   table.insert(metalSpots, {x = spotX, z = spotZ})
               end
          end
      end
      -- Log(teamData.teamID, "FindGoodEnergySpot: Found " .. #metalSpots .. " metal spots to avoid.") -- Debug

      local minDistanceToMetalSpotSq = (Game.extractorRadius or 32) * (Game.extractorRadius or 32) * 2.25 -- Distanza minima al quadrato (es. 1.5x raggio estrattore)

      for attempt = 1, 30 do -- Aumenta i tentativi se necessario
          local angle = math.random() * 2 * math.pi
          local dist = 80 + math.random(150) -- Raggio di ricerca più ampio
          local testX, testZ = bx + math.cos(angle)*dist, bz + math.sin(angle)*dist
          local testY = Spring.GetGroundHeight(testX, testZ)

          if testY then
              -- 1. Controlla se è troppo vicino a un punto metallo
              local tooCloseToMetal = false
              for _, metalSpot in ipairs(metalSpots) do
                  local dx = testX - metalSpot.x
                  local dz = testZ - metalSpot.z
                  if (dx*dx + dz*dz) < minDistanceToMetalSpotSq then
                      tooCloseToMetal = true
                      -- Log(teamData.teamID, "FindGoodEnergySpot: Candidate ("..string.format("%.0f,%.0f",testX,testZ)..") too close to metal spot ("..string.format("%.0f,%.0f",metalSpot.x,metalSpot.z)..")") -- Debug
                      break -- È troppo vicino, scarta questa posizione
                  end
              end

              -- 2. Se NON è troppo vicino al metallo, controlla se è costruibile
              if not tooCloseToMetal then
                  local buildResult = Spring.TestBuildOrder(powerDefID, testX, testY, testZ, 1) -- Usa facing 1
                  if buildResult == 0 or buildResult == 2 then
                      -- Log(teamData.teamID,"FindGoodEnergySpot: Found good energy spot at " .. string.format("%.0f,%.0f", testX, testZ))
                      return { x=testX, y=testY, z=testZ }
                  -- else Log(teamData.teamID,"FindGoodEnergySpot: TestBuildOrder failed at ("..string.format("%.0f,%.0f",testX,testZ)..") code: "..buildResult) -- Debug
                  end
              end
          end
      end
      Log(teamData.teamID,"FindGoodEnergySpot: Could not find suitable (non-metal) spot near builder after multiple attempts (30).") 
      return nil
  end

    -- Trova posizione Fabbrica - Aggiornato per EVITARE Punti Metallo
  function FindGoodFactoryPosForTeam(teamData, builderID)
      local bx, by, bz = Spring.GetUnitPosition(builderID)
      if not bx then return nil end

      -- Determina il tier della fabbrica da costruire
      local targetTier = teamData.techLevel + 1
      if targetTier > 3 then targetTier = 3 end -- Non superare il T3 massimo
      local factoryDefData = GetUnitDataByRole(teamData.faction, targetTier, "T"..targetTier.."_Factory")
      if not factoryDefData then Log(teamData.teamID,"FindGoodFactoryPos: Cannot find Factory T"..targetTier.." definition!"); return nil end
      local factoryDefID = factoryDefData.id

      -- Ottieni la lista dei punti metallo per evitarli
      local metalSpots = {}
      local mexCount = Spring.GetGameRulesParam("mex_count")
      if mexCount and mexCount > 0 then
          for i = 1, mexCount do
               local spotX = Spring.GetGameRulesParam("mex_x" .. i)
               local spotZ = Spring.GetGameRulesParam("mex_z" .. i)
               if spotX and spotZ then
                   table.insert(metalSpots, {x = spotX, z = spotZ})
               end
          end
      end
      -- Log(teamData.teamID, "FindGoodFactoryPos: Found " .. #metalSpots .. " metal spots to avoid.") -- Debug

      -- Distanza minima al quadrato da un punto metallo (puoi aggiustare il moltiplicatore)
      local minDistanceToMetalSpotSq = (Game.extractorRadius or 32) * (Game.extractorRadius or 32) * 2.25

      for attempt = 1, 30 do -- Aumenta i tentativi se necessario
          local angle = math.random() * 2 * math.pi
          local dist = 150 + math.random(150) -- Raggio di ricerca per fabbriche
          local testX, testZ = bx + math.cos(angle)*dist, bz + math.sin(angle)*dist
          local testY = Spring.GetGroundHeight(testX, testZ)

          if testY then
              -- 1. Controlla se è troppo vicino a un punto metallo
              local tooCloseToMetal = false
              for _, metalSpot in ipairs(metalSpots) do
                  local dx = testX - metalSpot.x
                  local dz = testZ - metalSpot.z
                  if (dx*dx + dz*dz) < minDistanceToMetalSpotSq then
                      tooCloseToMetal = true
                      -- Log(teamData.teamID, "FindGoodFactoryPos: Candidate ("..string.format("%.0f,%.0f",testX,testZ)..") too close to metal spot.") -- Debug
                      break
                  end
              end

              -- 2. Se NON è troppo vicino al metallo, controlla se è costruibile
              if not tooCloseToMetal then
                  local buildResult = Spring.TestBuildOrder(factoryDefID, testX, testY, testZ, 1) -- Usa facing 1
                  if buildResult == 0 or buildResult == 2 then
                      -- Log(teamData.teamID,"FindGoodFactoryPos: Found good factory spot at " .. string.format("%.0f,%.0f", testX, testZ))
                      return { x=testX, y=testY, z=testZ }
                  -- else Log(teamData.teamID,"FindGoodFactoryPos: TestBuildOrder failed at ("..string.format("%.0f,%.0f",testX,testZ)..") code: "..buildResult) -- Debug
                  end
              end
          end
      end
      Log(teamData.teamID,"FindGoodFactoryPos: Could not find suitable (non-metal) spot near builder after " .. attempt .. " attempts.")
      return nil
  end

  -- Funzione per controllare un team e trovare comandante/fazione
  local function CheckTeamCommander(teamID)
      if not teamData[teamID] or teamData[teamID].faction then return end
      local teamUnits = Spring.GetTeamUnits(teamID)
      if not teamUnits then return end
      for _, unitID in ipairs(teamUnits) do
          local unitDefID = Spring.GetUnitDefID(unitID)
          if unitDefID then
              local unitDef = UnitDefs[unitDefID]
              if unitDef then
                  local commanderNameLower = unitDef.name:lower()
                  local faction = commanderFactionMap[commanderNameLower]
                  if faction then
                      local commanderName = unitDef.name:upper()
                      Log(teamID, "Found Commander: " .. commanderName .. " - Faction set to: " .. faction)
                      teamData[teamID].faction = faction
                      teamData[teamID].commanderInfo = { name = commanderName, id = unitID, defID = unitDefID }
                      local comMoveType = UnitDefs[unitDefID].movedata and UnitDefs[unitDefID].movedata.moveType or "UNKNOWN"
                      teamData[teamID].constructors[unitID] = { tier = 0, state = "idle", task = nil, moveType = comMoveType }
                      return
                  end
              end
          end
      end
      if not teamData[teamID].faction and Game.frame > 90 then
          Log(teamID, "WARNING: Could not find starting commander/faction unit after 3 seconds!")
          teamData[teamID].faction = "UNKNOWN"
      end
  end

  -- === 3. LOGICA AVANZAMENTO TECNOLOGICO ===
  local function ManageTechLevel(teamID, frame)
      local data = teamData[teamID]
      if not data or not data.faction or data.faction == "UNKNOWN" or data.techLevel == nil then return end
      local currentLevel = data.techLevel
      local res = data.resourceInfo
      local thresholds = {
          [1] = { metal = 400, energy = 400, prereq = function() return true end },
          [2] = { metal = 2000, energy = 4000, prereq = function() return data:HasFactoryOfTier(1) end },
          [3] = { metal = 8000, energy = 15000, prereq = function() return data:HasFactoryOfTier(2) end }
      }
      local nextLevel = currentLevel + 1
      if thresholds[nextLevel] and currentLevel < 3 then
          local target = thresholds[nextLevel]
          local prereqMet, _ = pcall(target.prereq)
          if prereqMet and (res.metal and res.energy and res.metal >= target.metal and res.energy >= target.energy) then
              data.techLevel = nextLevel
              Log(teamID, "Advanced to Tech Level " .. nextLevel .. "!")
              -- Resetta obiettivi economici quando si sale di livello per ricalcolarli
              data.economyObjectives = {}
              Log(teamID,"Economy objectives reset for new tech level.")
          end
      end
  end

  -- Helper per fabbriche
  function TeamHasFactoryOfTier(teamData, tier)
      local faction = teamData.faction
      if not faction or faction == "UNKNOWN" then return false end
      local targetFactoryData = GetUnitDataByRole(faction, tier, "T"..tier.."_Factory")
      if not targetFactoryData then return false end
      local factories = Spring.GetTeamUnitsByDefs(teamData.teamID, targetFactoryData.id)
      return (factories and #factories > 0)
  end

  -- Funzioni di Gestione Principali
  local function UpdateResourceInfo(teamID, frame)
      local data = teamData[teamID]
      if not data then return end
      if frame - (data.resourceInfo.lastUpdateFrame or -100) > 30 then
          data.resourceInfo.metal, data.resourceInfo.energy = Spring.GetTeamResources(teamID, "metal", "energy")
          local metIncomeOk, metIncome = pcall(Spring.GetTeamResourceIncome, teamID, "metal")
          local metUsageOk, metUsage = pcall(Spring.GetTeamResourceUsage, teamID, "metal")
          local engIncomeOk, engIncome = pcall(Spring.GetTeamResourceIncome, teamID, "energy")
          local engUsageOk, engUsage = pcall(Spring.GetTeamResourceUsage, teamID, "energy")
          data.resourceInfo.metalIncome = (metIncomeOk and metIncome) or 0
          data.resourceInfo.metalUsage = (metUsageOk and metUsage) or 0
          data.resourceInfo.energyIncome = (engIncomeOk and engIncome) or 0
          data.resourceInfo.energyUsage = (engUsageOk and engUsage) or 0
          data.resourceInfo.lastUpdateFrame = frame
      end
  end

  local function ManageEconomy(teamID, frame)
      local data = teamData[teamID]
      if not data or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config or not config.economyTargets then return end

      local res = data.resourceInfo
      local currentEnergyIncome = res.energyIncome or 0
      local currentEnergyUsage = res.energyUsage or 0
      local energyBalance = currentEnergyIncome - currentEnergyUsage
      local desiredEnergySurplus = 15 -- Potresti abbassare leggermente questa, es. 10 o 5
      local prioritizeEnergy = (energyBalance < desiredEnergySurplus)

      local orderGivenThisFrame = false -- Flag per dare solo un ordine per ciclo

      -- 1. Controlla PRIMA se dobbiamo costruire ENERGIA (se prioritaria o no)
      local powerTargetConfig = nil
      local targetPowerRole = (data.techLevel >= 2 and GetUnitDataByRole(data.faction, 2, "T2_PowerPlant") and "T2_PowerPlant") or "T1_PowerPlant" -- Cerca T2 se possibile, altrimenti T1

      for _, target in ipairs(config.economyTargets) do
          if target.role == targetPowerRole then
              powerTargetConfig = target; break
          end
      end

      if powerTargetConfig then
          local roleTier = tonumber(targetPowerRole:match("^T(%d+)")) or 1
          local unitData = GetUnitDataByRole(data.faction, roleTier, targetPowerRole)
          if unitData then
              local unitDefID = unitData.id; local unitDef = UnitDefs[unitDefID]
              if unitDef then
                  -- Determina l'obiettivo numerico random per le centrali
                  if not data.economyObjectives[targetPowerRole] then
                      data.economyObjectives[targetPowerRole] = { targetCount = math.random(powerTargetConfig.min, powerTargetConfig.max), reached = false }
                      Log(teamID, "New Economy Objective for " .. targetPowerRole .. ": Build " .. data.economyObjectives[targetPowerRole].targetCount)
                  end
                  local currentObjective = data.economyObjectives[targetPowerRole]
                  local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)

                  if currentCount < currentObjective.targetCount then
                      if data:CanAfford(unitDefID, frame) then
                          -- Se l'energia è prioritaria OPPURE se semplicemente ne servono di più (sotto obiettivo)
                          if prioritizeEnergy or (not currentObjective.reached) then
                              local builderTier = math.max(0, roleTier - 1)
                              local builderID = data:FindIdleConstructor(builderTier)
                              if builderID then
                                  local buildPos = data:FindGoodEnergySpot(builderID)
                                  if buildPos then
                                      Log(teamID, ">>>>>> Ordering T"..builderTier.." builder "..builderID.." to build "..targetPowerRole.." #"..(currentCount+1).."/"..currentObjective.targetCount.. (prioritizeEnergy and " (PRIORITY)" or ""))
                                      Spring.GiveOrderToUnit(builderID, -unitDefID, { buildPos.x, buildPos.y, buildPos.z }, {})
                                      if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                                      orderGivenThisFrame = true -- Segna che abbiamo dato un ordine
                                      -- NON USCIRE SUBITO, potremmo voler costruire metallo se non era priorità energia
                                  end
                              end
                          end
                      elseif currentCount >= currentObjective.targetCount and not currentObjective.reached then
                           -- Log(teamID, "Economy Objective for " .. targetPowerRole .. " reached.")
                           currentObjective.reached = true
                      end
                  elseif not currentObjective.reached then -- Marcala come raggiunta se >= target
                      -- Log(teamID, "Economy Objective for " .. targetPowerRole .. " already met or exceeded.")
                      currentObjective.reached = true
                  end
              end
          end
      end

      -- 2. Se NON abbiamo dato un ordine per l'energia O l'energia non era prioritaria, controlla ALTRI obiettivi (Estrattori)
      if not orderGivenThisFrame then
          for i, targetConfig in ipairs(config.economyTargets) do
              -- Salta le centrali, le abbiamo già considerate
              if not targetConfig.role:find("PowerPlant") then
                  local role = targetConfig.role
                  local minCount = targetConfig.min; local maxCount = targetConfig.max

                  if not data.economyObjectives[role] then
                      local targetNum = math.random(minCount, maxCount)
                      data.economyObjectives[role] = { targetCount = targetNum, reached = false }
                      Log(teamID, "New Economy Objective for " .. role .. ": Build " .. targetNum)
                  end
                  local currentObjective = data.economyObjectives[role]

                  if not currentObjective.reached then
                      local roleTier = tonumber(role:match("^T(%d+)")) or 1
                      local unitData = GetUnitDataByRole(data.faction, roleTier, role)
                      if unitData then
                          local unitDefID = unitData.id; local unitDef = UnitDefs[unitDefID]
                          if unitDef then
                              local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)
                              if currentCount < currentObjective.targetCount then
                                  if data:CanAfford(unitDefID, frame) then
                                      local builderTier = math.max(0, roleTier - 1)
                                      local builderID = data:FindIdleConstructor(builderTier)
                                      if builderID then
                                          local buildPos = nil
                                          if role:find("Extractor") then 
										  buildPos = data:FindBestMetalSpot(builderID) 
                                          -- === NUOVA CONDIZIONE PER POSIZIONE STORAGE ===
                                          elseif role:find("Estorage") or role:find("Mstorage") then
                                              -- Riusiamo la logica di posizionamento delle centrali
                                              -- o potresti creare una nuova funzione FindGoodStorageSpot se necessario
                                              buildPos = data:FindGoodEnergySpot(builderID) -- Usiamo questo per ora
                                              if buildPos then
                                                  Log(teamID, "Found spot for " .. role .. " using EnergySpot logic.")
                                              else
                                                  Log(teamID, "Could NOT find spot for " .. role .. " using EnergySpot logic.")
                                              end
                                          -- ==========================================										  
										  end
                                          if buildPos then
                                              Log(teamID, ">>>>>> Ordering builder "..builderID.." to build "..role.." #"..(currentCount+1).."/"..currentObjective.targetCount)
                                              Spring.GiveOrderToUnit(builderID, -unitDefID, { buildPos.x, buildPos.y, buildPos.z }, {})
                                              if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                                              orderGivenThisFrame = true -- Abbiamo dato un ordine
                                              -- Esci dal ciclo interno DOPO aver dato un ordine per altri edifici
                                              break
                                          end
                                      end
                                  end
                              elseif currentCount >= currentObjective.targetCount then
                                  -- Log(teamID, "Economy Objective for " .. role .. " reached.")
                                  currentObjective.reached = true
                              end
                          end
                      end
                  end
              end -- fine if not PowerPlant
          end -- fine for altri obiettivi
      end -- fine if not orderGivenThisFrame
  end -- Fine ManageEconomy

  -- ManageProduction con correzione ordine fabbrica
  local function ManageProduction(teamID, frame)
      local data = teamData[teamID]
      if not data or not data.faction or data.faction == "UNKNOWN" or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config then return end

      local faction = data.faction
      local techLevel = data.techLevel
      local allowedMoveTypes = {}
      if currentMapCategory == "LAND" then allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true, BUILDING = true }
      elseif currentMapCategory == "NAVAL_ISLANDS" then allowedMoveTypes = { NAVAL = true, AIR = true, BUILDING = true }
      elseif currentMapCategory == "SPACE" then allowedMoveTypes = { AIR = true, SPACE = true, BUILDING = true }
      elseif currentMapCategory == "NAVAL_PURE" then allowedMoveTypes = { NAVAL = true, BUILDING = true }
      end

      -- 1. Costruire Fabbriche?
      if config.factoryTargets then
          local totalFactories = 0
          for tier=1, data.techLevel + 1 do
              local facData = GetUnitDataByRole(faction, tier, "T"..tier.."_Factory")
              if facData then totalFactories = totalFactories + #Spring.GetTeamUnitsByDefs(teamID, facData.id) end
          end

          if totalFactories < config.factoryTargets.minTotal then
              local targetTier = config.factoryTargets.targetTier
              local factoryData = GetUnitDataByRole(faction, targetTier, "T"..targetTier.."_Factory")
              if factoryData and allowedMoveTypes[factoryData.moveType] then
                   if data:CanAfford(factoryData.id, frame) then
                       local builderID = data:FindIdleConstructor(targetTier - 1)
                       if builderID then
                           local buildPos = data:FindGoodFactoryPos(builderID)
                           if buildPos then
                               Log(teamID, "Ordering T"..(targetTier-1).." builder " .. builderID .. " to build T"..targetTier.." factory ("..factoryData.name..") at " .. string.format("%.0f,%.0f", buildPos.x, buildPos.z))
                               Spring.GiveOrderToUnit(builderID, -factoryData.id, { buildPos.x, buildPos.y, buildPos.z }, {})
                               if data.constructors[builderID] then data.constructors[builderID].state = "busy" end
                               return
                           end
                       end
                   end
              end
          end
      end -- Fine costruzione fabbriche

      -- 2. Produrre Unità dalle Fabbriche Esistenti
      if config.productionList then
          local sortedProdList = {}
          for _, item in ipairs(config.productionList) do table.insert(sortedProdList, item) end
          table.sort(sortedProdList, function(a,b) return a.priority > b.priority end)

          for factoryTier = 1, data.techLevel do
              local factoryData = GetUnitDataByRole(faction, factoryTier, "T"..factoryTier.."_Factory")
              if factoryData then
                  local factories = Spring.GetTeamUnitsByDefs(teamID, factoryData.id)
                  if factories then
                      for _, factoryID in ipairs(factories) do
                          local orderGivenToThisFactory = false
                          local queue = Spring.GetFactoryCommands(factoryID)
                          if not queue or #queue < 3 then
                              for _, prodItem in ipairs(sortedProdList) do
                                  local unitTier = tonumber(prodItem.role:match("T(%d+)")) or 0
                                  if unitTier <= factoryTier then
                                      local unitData = GetUnitDataByRole(faction, unitTier, prodItem.role)
                                      if unitData and allowedMoveTypes[unitData.moveType] then
                                          local unitDefID = unitData.id
                                          local currentCount = #Spring.GetTeamUnitsByDefs(teamID, unitDefID)
                                          local maxCount = prodItem.max
                                          local buildThis = false
                                          if prodItem.role:find("Constructor") then
                                               if data:NeedsConstructor(unitTier) then buildThis = true end
                                          elseif maxCount == 0 or currentCount < maxCount then
                                               buildThis = true
                                          end
                                          if buildThis and data:CanAfford(unitDefID, frame) then
                                              Log(teamID, "Ordering T"..factoryTier.." factory " .. factoryID .. " to build "..prodItem.role.." (DefID "..unitDefID..")")
                                              Spring.GiveOrderToUnit(factoryID, -unitDefID, {}, {})
                                              orderGivenToThisFactory = true
                                              break
                                          end
                                      end
                                  end
                              end
                          end
                      end
                  end
              end
          end
      end
  end -- Fine ManageProduction


   function GeneratePatrolPoints(teamID, data)
      if #data.patrolPoints > 0 and not data.regeneratePatrolPoints then
          Log(teamID, "GeneratePatrolPoints: Points already exist and no regeneration forced. Count: " .. #data.patrolPoints)
          return
      end

      Log(teamID, "GeneratePatrolPoints: STARTING generation...")
      data.patrolPoints = {};
      local mapW, mapH = Game.mapSizeX, Game.mapSizeZ
      Log(teamID, "GeneratePatrolPoints: Map Dimensions W="..mapW..", H="..mapH) -- LOG MAP SIZE
      local startX, startY, startZ = Spring.GetTeamStartPosition(teamID)

      if not startX then
          Log(teamID, "GeneratePatrolPoints: ERROR - Cannot get team start position!")
          return
      end
      Log(teamID, "GeneratePatrolPoints: StartPos = " .. string.format("%.0f,%.0f", startX, startZ))

      local tempPoints = {}
      -- ... (logica per aggiungere punti a tempPoints) ...
      -- Assicurati che i log per ogni tipo di punto (base, enemy, resource, center) mostrino se vengono aggiunti a tempPoints
	  
	        -- === INIZIO LOGICA AGGIUNTA PER POPOLARE tempPoints ===

      -- 1. Punti attorno alla propria base per un pattugliamento iniziale/difensivo
      local basePatrolRadius = 300 -- Distanza dalla base per i punti di pattuglia
      table.insert(tempPoints, { x = startX + basePatrolRadius, z = startZ, type = "HOME_PATROL_E" })
      table.insert(tempPoints, { x = startX - basePatrolRadius, z = startZ, type = "HOME_PATROL_W" })
      table.insert(tempPoints, { x = startX, z = startZ + basePatrolRadius, type = "HOME_PATROL_S" })
      table.insert(tempPoints, { x = startX, z = startZ - basePatrolRadius, type = "HOME_PATROL_N" })
      Log(teamID, "GeneratePatrolPoints: Added 4 home patrol points around start position.")

      -- 2. Punto al centro della mappa (se la mappa non è troppo piccola)
      if mapW > 1000 and mapH > 1000 then -- Evita su mappe piccolissime
          table.insert(tempPoints, { x = mapW / 2, z = mapH / 2, type = "MAP_CENTER" })
          Log(teamID, "GeneratePatrolPoints: Added map center point.")
      end

      -- 3. Punti verso le posizioni di partenza nemiche (se esistono nemici)
      local allTeams = Spring.GetTeamList()
      local enemyTeamsFound = {} -- Tabella per conservare gli ID dei team nemici effettivi

      if allTeams then
          for _, otherTeamID in ipairs(allTeams) do
              if otherTeamID ~= teamID then -- Non considerare il proprio team
                  -- Per la v100, dobbiamo usare Spring.AreTeamsAllied
                  -- Spring.AreTeamsAllied(teamID1, teamID2) restituisce true se sono alleati, false altrimenti
                  if not Spring.AreTeamsAllied(teamID, otherTeamID) then
                      table.insert(enemyTeamsFound, otherTeamID)
                  end
              end
          end
      end

            -- All'interno di GeneratePatrolPoints, dopo aver trovato enemyTeamsFound

      if #enemyTeamsFound > 0 then
          Log(teamID, "GeneratePatrolPoints: Found " .. #enemyTeamsFound .. " enemy teams.")
          for i, enemyTeamID in ipairs(enemyTeamsFound) do
              local ex, _, ez = Spring.GetTeamStartPosition(enemyTeamID)
              if ex and ez then
                  -- 1. PUNTO A METÀ STRADA (già presente)
                  local midX = (startX + ex) / 2
                  local midZ = (startZ + ez) / 2
                  table.insert(tempPoints, { x = midX, z = midZ, type = "ENEMY_APPROACH_" .. enemyTeamID })
                  Log(teamID, "GeneratePatrolPoints: Added enemy approach point towards team " .. enemyTeamID .. " at " .. string.format("%.0f,%.0f", midX, midZ))

                  -- 2. NUOVO: PUNTO DI PATTUGLIA SUL PERIMETRO DELLA BASE NEMICA
                  -- Vogliamo un punto che sia vicino alla base nemica, ma non direttamente sopra,
                  -- e magari in una direzione "sicura" o strategica dalla nostra prospettiva.
                  -- Calcoliamo un vettore dalla nostra base a quella nemica
                  local vecToEnemyX = ex - startX
                  local vecToEnemyZ = ez - startZ
                  local distToEnemy = math.sqrt(vecToEnemyX*vecToEnemyX + vecToEnemyZ*vecToEnemyZ)

                  if distToEnemy > 0 then -- Evita divisione per zero se le basi sono sovrapposte (improbabile)
                      -- Normalizza il vettore
                      local normVecX = vecToEnemyX / distToEnemy
                      local normVecZ = vecToEnemyZ / distToEnemy

                      -- Distanza dal centro della base nemica per il punto di pattuglia perimetrale
                      local perimeterPatrolOffset = 400 -- Aggiustabile: abbastanza vicino per vedere, non troppo per morire subito
                      if perimeterPatrolOffset > distToEnemy * 0.4 then -- Non andare oltre il 40% della distanza totale
                          perimeterPatrolOffset = distToEnemy * 0.4
                      end


                      -- Calcola il punto sul perimetro: parti dalla base nemica e "torna indietro" un po' verso di noi,
                      -- oppure vai di lato. Per ora, torniamo indietro lungo la linea che ci congiunge.
                      local perimeterX = ex - normVecX * perimeterPatrolOffset
                      local perimeterZ = ez - normVecZ * perimeterPatrolOffset
                      
                      -- Potresti anche aggiungere una piccola deviazione laterale per non essere troppo prevedibile
                      -- local offsetX = normVecZ * math.random(-150, 150) -- Usa il vettore perpendicolare per lo spostamento laterale
                      -- local offsetZ = -normVecX * math.random(-150, 150)
                      -- perimeterX = perimeterX + offsetX
                      -- perimeterZ = perimeterZ + offsetZ


                      table.insert(tempPoints, { x = perimeterX, z = perimeterZ, type = "ENEMY_BASE_PERIMETER_" .. enemyTeamID })
                      Log(teamID, "GeneratePatrolPoints: Added enemy base perimeter point for team " .. enemyTeamID .. " at " .. string.format("%.0f,%.0f", perimeterX, perimeterZ))
                  end

              else
                  Log(teamID, "GeneratePatrolPoints: Could not get start position for enemy team " .. enemyTeamID)
              end

              if i >= 2 then -- Manteniamo il limite per non avere troppi punti per singolo nemico all'inizio
                  Log(teamID, "GeneratePatrolPoints: Limiting enemy-related points generation to first "..i.." enemies for now.")
                  break
              end
          end
      else
          Log(teamID, "GeneratePatrolPoints: No enemy teams found.")
      end

      -- 4. (Opzionale avanzato) Punti su metal spot importanti e non presi
      -- Questa è un po' più complessa perché richiede di controllare quali spot sono liberi
      -- e magari distanti dalla propria base. Per ora la omettiamo per semplicità.
      -- Esempio concettuale:
      -- local mexCount = Spring.GetGameRulesParam("mex_count")
      -- if mexCount and mexCount > 0 then
      --    local spotsChecked = 0
      --    for i = 1, mexCount do
      --        local spotX = Spring.GetGameRulesParam("mex_x" .. i)
      --        local spotZ = Spring.GetGameRulesParam("mex_z" .. i)
      --        if spotX and spotZ then
      --            -- Qui dovresti controllare se lo spot è libero e se è "interessante"
      --            -- (es. non troppo vicino alla tua base, non troppo vicino a uno già aggiunto)
      --            -- table.insert(tempPoints, { x = spotX, z = spotZ, type = "RESOURCE_SPOT_" .. i })
      --            -- spotsChecked = spotsChecked + 1
      --            -- if spotsChecked >= 3 then break end -- Limita il numero di spot aggiunti
      --        end
      --    end
      -- end
      -- Log(teamID, "GeneratePatrolPoints: Considered metal spots for patrol points.")

      -- === FINE LOGICA AGGIUNTA ===
	  

      Log(teamID, "GeneratePatrolPoints: BEFORE filtering - Total temp points: " .. #tempPoints)
      if #tempPoints == 0 then
          Log(teamID, "GeneratePatrolPoints: WARNING - No points added to tempPoints before filtering!")
      end

      local uniquePoints = {}
      local finalPatrolPoints = {}
      for i, p in ipairs(tempPoints) do -- Aggiunto indice 'i' per i log
          local key = string.format("%.0f,%.0f", p.x, p.z)
          Log(teamID, "GeneratePatrolPoints: Processing tempPoint "..i.." ("..p.type..") at "..key) -- LOG PROCESSING
          if not uniquePoints[key] then
             local clampedX = math.max(16, math.min(p.x, mapW - 16)) -- Aggiunto piccolo margine dai bordi
             local clampedZ = math.max(16, math.min(p.z, mapH - 16)) -- Aggiunto piccolo margine
             if clampedX ~= p.x or clampedZ ~= p.z then
                Log(teamID, "GeneratePatrolPoints: Point " .. p.type .. " ("..key..") was clamped from ("..string.format("%.0f,%.0f",p.x,p.z)..") to ("..string.format("%.0f,%.0f",clampedX,clampedZ)..")")
             end
             p.x = clampedX
             p.z = clampedZ
             p.y = Spring.GetGroundHeight(p.x,p.z)
             if p.y == nil then -- Punto fuori mappa o su acqua non navigabile?
                Log(teamID, "GeneratePatrolPoints: Point " .. p.type .. " ("..key..") has nil height after clamping, SKIPPING.")
             else
                Log(teamID, "GeneratePatrolPoints: Adding final point "..p.type.." at "..string.format("%.0f,%.0f,%.0f",p.x,p.y,p.z))
                table.insert(finalPatrolPoints, p)
                uniquePoints[key] = true
             end
          else
              Log(teamID, "GeneratePatrolPoints: Point "..p.type.." ("..key..") was duplicate, SKIPPED.")
          end
      end
      data.patrolPoints = finalPatrolPoints
      Log(teamID, "GeneratePatrolPoints: AFTER filtering - Final unique patrol points: " .. #data.patrolPoints)

      -- ... (resto della funzione con fallback e log finale) ...
      if #data.patrolPoints == 0 then
          Log(teamID, "GeneratePatrolPoints: WARNING - No valid patrol points generated after filtering!")
          -- ... (logica fallback) ...
      end
      data.nextPatrolPointIndex = 1; data.regeneratePatrolPoints = false;
      Log(teamID, "GeneratePatrolPoints: FINISHED. Final count: " .. #data.patrolPoints .. ", Next Index: " .. data.nextPatrolPointIndex)
  end



  



   -- Funzione per creare un nuovo gruppo di combattimento (versione con analisi capacità)
    local function CreateNewCombatGroup(teamID, data, unitIDs, frame)
      local newGroupID = data.nextGroupID
      data.nextGroupID = data.nextGroupID + 1

      local newGroup = {
          id = newGroupID, units = {}, state = "idle", targetPoint = nil,
          currentPatrolIndex = nil, lastOrderFrame = frame,
          groupMoveType = "UNKNOWN", canAttackLand = false, canAttackAir = false,
          canAttackNaval = false, isHomogeneous = true 
      }

      local moveTypesInGroup = {} -- Tabella per tracciare i moveType visti
      local firstMoveType = nil
      Log(teamID, "DEBUG CNCG "..newGroupID..": START. Unit IDs to add: " .. #unitIDs) -- CNCG = CreateNewCombatGroup

      if not unitIDs or #unitIDs == 0 then 
          Log(teamID, "WARN CNCG "..newGroupID..": No unitIDs provided.")
          data.nextGroupID = data.nextGroupID - 1 
          return 
      end

      for i, unitIDinGroup in ipairs(unitIDs) do
          Log(teamID, "DEBUG CNCG "..newGroupID..": Processing unit #"..i..", ID: " .. unitIDinGroup)
          if data.combatUnits[unitIDinGroup] then
              table.insert(newGroup.units, unitIDinGroup)
              data.combatUnits[unitIDinGroup].state = "assigned_to_group"
              data.combatUnits[unitIDinGroup].groupID = newGroupID
              
              local unitDefID = Spring.GetUnitDefID(unitIDinGroup)
              if unitDefID then
                  local aiUnitData = GetAiUnitDataByDefID(unitDefID) 
                  if aiUnitData and aiUnitData.moveType then
                      local currentUnitMoveType = aiUnitData.moveType
                      Log(teamID, "DEBUG CNCG "..newGroupID..": Unit " .. unitIDinGroup .. " (DefID " .. unitDefID .. ", Name: "..(aiUnitData.name or "N/A")..") got AI MoveType: " .. currentUnitMoveType)

                      if not firstMoveType then 
                          firstMoveType = currentUnitMoveType 
                          Log(teamID, "DEBUG CNCG "..newGroupID..": Set firstMoveType to: " .. firstMoveType)
                      end
                      if firstMoveType ~= currentUnitMoveType then 
                          newGroup.isHomogeneous = false 
                          Log(teamID, "DEBUG CNCG "..newGroupID..": Group no longer homogeneous.")
                      end
                      moveTypesInGroup[currentUnitMoveType] = true -- Registra il tipo
                      Log(teamID, "DEBUG CNCG "..newGroupID..": Added "..currentUnitMoveType.." to moveTypesInGroup. Current content:")
                      for mt_key, _ in pairs(moveTypesInGroup) do Log(teamID, "    "..mt_key) end
                      
                      local mtLower = currentUnitMoveType:lower()
                      if mtLower == "land" or mtLower == "building" or mtLower == "kbot" or mtLower == "vehicle" or mtLower == "spider" then
                          newGroup.canAttackLand = true
                      end
                      if mtLower == "air" then
                          newGroup.canAttackAir = true
                          newGroup.canAttackLand = true 
                      end
                      if mtLower == "naval" or mtLower == "submarine" then
                          newGroup.canAttackNaval = true
                          newGroup.canAttackLand = true 
                      end
                      if mtLower == "hover" then
                          newGroup.canAttackLand = true
                          newGroup.canAttackNaval = true
                      end
                      Log(teamID, "DEBUG CNCG "..newGroupID..": Unit " ..unitIDinGroup.. " set caps L/A/N: "..tostring(newGroup.canAttackLand).."/"..tostring(newGroup.canAttackAir).."/"..tostring(newGroup.canAttackNaval))
                  else
                      Log(teamID, "WARN CNCG "..newGroupID..": Could not get AI Unit Data or moveType for own unitDefID " .. unitDefID .. " (UnitID: "..unitIDinGroup..")")
                  end
              else 
                  Log(teamID, "WARN CNCG "..newGroupID..": Could not get DefID for UnitID: " .. unitIDinGroup)
              end
          else
              Log(teamID, "WARN CNCG "..newGroupID..": Unit " .. unitIDinGroup .. " not in data.combatUnits.")
          end
      end -- Fine loop su unitIDs

      -- Logga lo stato delle variabili PRIMA di determinare groupMoveType
      Log(teamID, "DEBUG CNCG "..newGroupID..": END OF LOOP. firstMoveType: " .. tostring(firstMoveType) .. ". moveTypesInGroup content:")
      for mt_key, _ in pairs(moveTypesInGroup) do Log(teamID, "    "..mt_key) end

      local numMoveTypes = 0; for _ in pairs(moveTypesInGroup) do numMoveTypes = numMoveTypes + 1 end
      Log(teamID, "DEBUG CNCG "..newGroupID..": numMoveTypes calculated: " .. numMoveTypes)

      if numMoveTypes == 1 and firstMoveType then 
          newGroup.groupMoveType = firstMoveType
      elseif numMoveTypes > 1 then
          newGroup.groupMoveType = "MIXED"
          newGroup.isHomogeneous = false
      elseif #newGroup.units > 0 then 
          Log(teamID, "WARN CNCG "..newGroupID..": Group has units but numMoveTypes is 0. Setting UNKNOWN. firstMoveType was: "..tostring(firstMoveType))
          newGroup.groupMoveType = "UNKNOWN" 
      end
      Log(teamID, "DEBUG CNCG "..newGroupID..": Final groupMoveType: " .. newGroup.groupMoveType)
      
      if #newGroup.units > 0 then
         data.combatGroups[newGroupID] = newGroup
         Log(teamID, "Created new combat group " .. newGroupID .. " with " .. #newGroup.units .. " units. MoveType: "..newGroup.groupMoveType ..
                     " Caps L/A/N: " ..tostring(newGroup.canAttackLand).."/"..tostring(newGroup.canAttackAir).."/"..tostring(newGroup.canAttackNaval))
      else
         Log(teamID, "WARN CNCG "..newGroupID..": Attempted to create an empty group AFTER unit processing (should not happen if initial check works).")
         data.nextGroupID = data.nextGroupID - 1
      end
  end


  
  -- altra utility per debug unitsdef
  function PrintUnitDefViaMetaPairs(teamID, uDef, unitDefName)
    if not uDef then
        Log(teamID, "PrintUnitDefViaMetaPairs: uDef is nil for " .. unitDefName)
        return
    end
    Log(teamID, "Inspecting UnitDef fields via :pairs() for: " .. unitDefName .. " (Name in uDef: " .. tostring(uDef.name) .. ")")
    
    if uDef.pairs then -- Controlla se il metodo :pairs() esiste (dovrebbe secondo la doc)
        for keyName, keyValue in uDef:pairs() do
            -- Logghiamo solo tipi semplici per evitare di stampare tabelle intere (come 'weapons')
            if type(keyValue) == "number" or type(keyValue) == "string" or type(keyValue) == "boolean" then
                Log(teamID, "  Key: '" .. tostring(keyName) .. "', Value: [" .. tostring(keyValue) .. "], Type: " .. type(keyValue))
            elseif keyValue == nil then
                 Log(teamID, "  Key: '" .. tostring(keyName) .. "', Value: [nil], Type: nil")
            else
                Log(teamID, "  Key: '" .. tostring(keyName) .. "', Type: " .. type(keyValue) .. " (Table or Function - not printing value)")
            end
        end
    else
        Log(teamID, "PrintUnitDefViaMetaPairs: uDef.pairs method not found for " .. unitDefName .. ". Trying standard pairs.")
        -- Fallback a pairs standard, anche se potrebbe non mostrare tutto
        for keyName, keyValue in pairs(uDef) do
             if type(keyValue) == "number" or type(keyValue) == "string" or type(keyValue) == "boolean" then
                Log(teamID, "  (StdPairs) Key: '" .. tostring(keyName) .. "', Value: [" .. tostring(keyValue) .. "], Type: " .. type(keyValue))
            else
                Log(teamID, "  (StdPairs) Key: '" .. tostring(keyName) .. "', Type: " .. type(keyValue) .. " (Table or Function - not printing value)")
            end
        end
    end
    Log(teamID, "Finished inspecting UnitDef via :pairs() for " .. unitDefName)
end
  
  
--[[
-- utility per debug unitdef
function LogAllUnitDefFields(teamID, unitDefID, unitDefName)
    Log(teamID, "Inspecting ALL UnitDef fields for: " .. unitDefName .. " (ID: " .. unitDefID .. ")")
    local currentKey = nil -- Inizia con nil per ottenere la prima chiave
    local i = 0
    while true do
        currentKey = Spring.GetUnitDefNextKey(unitDefID, currentKey)
        if currentKey == nil then
            break -- Fine delle chiavi
        end
        local value = Spring.GetUnitDefValueByKey(unitDefID, currentKey)
        Log(teamID, "  Key: '" .. currentKey .. "', Value: [" .. tostring(value) .. "], Type: " .. type(value))
        i = i + 1
        if i > 200 then Log(teamID, "STOPPING KEY INSPECTION, too many keys"); break end -- Sicurezza
    end
    Log(teamID, "Finished inspecting keys.")
end
]]--



 
 


local function CreateOrUpdateHotspot(teamID, data, frameValue, hx, hy, hz, htype, hstrength, hradius, hCreatorUnitID, hEnemyUnitDefID)
      -- Log iniziale per debug, mostra il frame ricevuto
      -- Log(teamID, "DEBUG CreateOrUpdateHotspot: Called. Received frameValue: " .. tostring(frameValue)) 

      -- === 1. Controlli di Validità Input ===
      if not hx or not hy or not hz then
          Log(teamID, "WARN CreateOrUpdateHotspot: Invalid coordinates (nil). Aborting.")
          return nil
      end
       if not hstrength or type(hstrength) ~= "number" or hstrength <= 0 then
          Log(teamID, "WARN CreateOrUpdateHotspot: Invalid strength ("..tostring(hstrength).."). Aborting.")
          return nil
      end
      if frameValue == nil or type(frameValue) ~= "number" then 
          Log(teamID, "WARN CreateOrUpdateHotspot: CRITICAL - frameValue is invalid ("..tostring(frameValue)..")! Aborting.")
          return nil
      end

      -- Imposta valori di default se necessario
      hradius = hradius or 350 
      htype = htype or "ENEMY_CONTACT"
      local mergeDistanceSq = (hradius * 0.75) * (hradius * 0.75) -- Distanza per unire hotspot

      -- === 2. Cerca Hotspot Esistente Vicino ===
      local existingHotspotID = nil
      local existingSpot = nil
      for id, spot in pairs(data.hotspots) do
          local dx = spot.x - hx
          local dz = spot.z - hz -- Confronto solo su XZ per unire più facilmente
          if (dx*dx + dz*dz) < mergeDistanceSq then
              existingHotspotID = id
              existingSpot = spot -- Salva la tabella dell'hotspot trovato
              break
          end
      end

      -- === 3. Determina Tipo e Capacità del Nemico (se DefID è fornito) ===
      local enemyMoveType = "UNKNOWN" -- Default
      local isLandEnemy = false 
      local isAirEnemy = false
      local isNavalEnemy = false -- Include sub
      local isHoverEnemy = false

      if hEnemyUnitDefID then
          local enemyAiData = GetAiUnitDataByDefID(hEnemyUnitDefID) -- <<< USA HELPER PER DATI NEMICO DA factionUnits
          if enemyAiData then
              enemyMoveType = enemyAiData.moveType or "UNKNOWN" -- Leggi moveType dai nostri dati
              -- Log(teamID, "DEBUG CreateHotspot: Found AI data for enemy DefID " .. hEnemyUnitDefID .. ". Name: "..(enemyAiData.name or "N/A")..". MoveType from AI data: " .. enemyMoveType)
              
              -- Determina i flag basati sul nostro moveType definito manualmente
              local mtLower = enemyMoveType:lower()
              if mtLower == "land" or mtLower == "building" or mtLower == "kbot" or mtLower == "vehicle" or mtLower == "spider" then
                  isLandEnemy = true
              elseif mtLower == "air" then
                  isAirEnemy = true
              elseif mtLower == "naval" or mtLower == "submarine" then
                  isNavalEnemy = true
              elseif mtLower == "hover" then 
                  isHoverEnemy = true
                  -- Un hover è sia una minaccia terrestre che navale
                  isLandEnemy = true  
                  isNavalEnemy = true 
              end
          else
               -- Log(teamID, "WARN CreateHotspot: Could not find AI Unit Data in factionUnits for enemy DefID: " .. hEnemyUnitDefID)
          end
      -- else Log(teamID, "DEBUG CreateHotspot: No hEnemyUnitDefID provided.") -- Avviso se non viene passato l'ID nemico
      end

      -- === 4. Aggiorna Hotspot Esistente o Creane Uno Nuovo ===
      if existingSpot then 
          -- === Aggiorna Esistente ===
          existingSpot.lastSeenFrame = frameValue     -- è da tenere?? non capisco
          existingSpot.needsReinforcement = existingSpot.needsReinforcement or false -- Assicura esista
        existingSpot.lastReinforcementCheckFrame = existingSpot.lastReinforcementCheckFrame or 0 
          -- Aggiorna posizione (media pesata) e forza
          -- Usiamo una forza minima di 1 per evitare divisioni per zero se la forza iniziale fosse 0
          local currentStrength = existingSpot.strength or 1
          local newStrength = hstrength or 1
          local totalStrength = currentStrength + newStrength
          
          -- Puoi scegliere come aggiornare la forza: max, somma, media... Somma è semplice.
          existingSpot.strength = currentStrength + newStrength 
          -- O prendi il massimo: existingSpot.strength = math.max(currentStrength, newStrength)
          
          -- Media pesata per la posizione
          existingSpot.x = (existingSpot.x * currentStrength + hx * newStrength) / totalStrength 
          existingSpot.y = (existingSpot.y * hy * newStrength) / totalStrength -- Aggiunto hy mancante
          existingSpot.z = (existingSpot.z * currentStrength + hz * newStrength) / totalStrength 
          
          if hCreatorUnitID then existingSpot.lastCreatorUnitID = hCreatorUnitID end -- Opzionale: ultimo vedente

          -- Aggiungi i tipi di nemici visti a quelli già presenti nell'hotspot (logica OR)
          if isLandEnemy then existingSpot.hasLandEnemies = true end
          if isAirEnemy then existingSpot.hasAirEnemies = true end
          if isNavalEnemy then existingSpot.hasNavalEnemies = true end
          -- Potremmo aggiungere un flag specifico per hover se serve:
          -- if isHoverEnemy then existingSpot.hasHoverEnemies = true end 
          
          -- Aggiorna tipo dominante (logica migliorata)
          local currentDominant = existingSpot.dominantEnemyMoveType or "UNKNOWN"
          if currentDominant ~= "MIXED" then
             if isHoverEnemy then -- Se vediamo un hover, la situazione è complessa
                if currentDominant == "UNKNOWN" or currentDominant == "HOVER" then existingSpot.dominantEnemyMoveType = "HOVER" -- Se c'era solo hover o niente, rimane/diventa HOVER
                else existingSpot.dominantEnemyMoveType = "MIXED" end -- Se c'era LAND/NAVAL/AIR, diventa MIXED
             elseif enemyMoveType ~= "UNKNOWN" and currentDominant ~= "UNKNOWN" and enemyMoveType ~= currentDominant then
                existingSpot.dominantEnemyMoveType = "MIXED" -- Se vediamo un tipo diverso da quello esistente (e non sono UNKNOWN o HOVER), diventa MIXED
             elseif currentDominant == "UNKNOWN" and enemyMoveType ~= "UNKNOWN" then
                existingSpot.dominantEnemyMoveType = enemyMoveType -- Se era UNKNOWN, prende il nuovo tipo
             end
          end

          Log(teamID, "Updated existing hotspot " .. existingHotspotID .. " at ~" .. string.format("%.0f,%.0f", existingSpot.x, existingSpot.z) .. " (Str: " .. string.format("%.0f", existingSpot.strength) .. ") LastSeen: " .. existingSpot.lastSeenFrame .. " DomType: " .. existingSpot.dominantEnemyMoveType)
          return existingHotspotID
          
else
          -- === Crea Nuovo Hotspot ===
          local newID = data.nextHotspotID
          data.nextHotspotID = data.nextHotspotID + 1
          
          local newSpot = {
              id = newID,
              x = hx, y = hy, z = hz,
              type = htype, -- Usa il tipo passato o default
              strength = hstrength,
              radius = hradius,
              lastSeenFrame = frameValue, 
              creationFrame = frameValue, 
              creatorUnitID = hCreatorUnitID, -- Può essere nil
              needsReinforcement = false, -- <<< INIZIALIZZATO QUI (Corretto!)
              lastReinforcementCheckFrame = 0, -- <<< INIZIALIZZATO QUI (Corretto!)
              -- Imposta flag basati su questo primo avvistamento
              hasLandEnemies = isLandEnemy,
              hasAirEnemies = isAirEnemy,
              hasNavalEnemies = isNavalEnemy,
              -- hasHoverEnemies = isHoverEnemy, -- Aggiungi se vuoi tracciarlo specificamente
              dominantEnemyMoveType = enemyMoveType -- Imposta tipo iniziale (potrebbe essere UNKNOWN)
          }
          -- Raffina dominantEnemyMoveType se il primo avvistamento è Hover
          if isHoverEnemy then newSpot.dominantEnemyMoveType = "HOVER" end 
          
          data.hotspots[newID] = newSpot
          Log(teamID, "Created new hotspot " .. newID .. " type '"..newSpot.type.."' at " .. string.format("%.0f,%.0f", hx, hz) .. " (Str: " .. hstrength .. ", EnemyMoveType: "..(newSpot.dominantEnemyMoveType)..") LastSeen: " .. newSpot.lastSeenFrame .. " Created: " .. newSpot.creationFrame .. " L/A/N: "..tostring(newSpot.hasLandEnemies).."/"..tostring(newSpot.hasAirEnemies).."/"..tostring(newSpot.hasNavalEnemies))
          return newID
      end
  end





  
   
  

  -- Placeholder per Funzioni Hotspot (da implementare in futuro)
  function UpdateHotspots(teamID, frame, data) end
  function DecayOldHotspots(teamID, frame, data) end
  
  
  

  
 
 
 
 
 

  
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   -- Funzione per far decadere e rimuovere vecchi hotspot
  local function DecayHotspots(teamID, data, frame)
      local decayTime = Game.gameSpeed * 45 -- Es. 45 secondi a velocità normale (gameSpeed è solitamente 30)
                                          -- Aggiusta questo valore!
      local removedCount = 0
      local idsToRemove = {} -- Raccogli gli ID da rimuovere per evitare problemi di modifica tabella durante l'iterazione

      for id, spot in pairs(data.hotspots) do
	   -- === NUOVO BLOCCO DEBUG ===
          if spot == nil then
              Log(teamID, "DEBUG: DecayHotspots - Found a nil spot with id: " .. tostring(id) .. " - SKIPPING")
          elseif type(spot) ~= "table" then
              Log(teamID, "DEBUG: DecayHotspots - Spot with id: " .. tostring(id) .. " is not a table, it is a " .. type(spot) .. " - SKIPPING")
          elseif spot.lastSeenFrame == nil then
              Log(teamID, "DEBUG: DecayHotspots - Spot id: " .. tostring(id) .. " has spot.lastSeenFrame == nil. Spot data: ")
              -- Logga i campi dell'hotspot per capire cosa potrebbe essere successo
              for k, v in pairs(spot) do
                  Log(teamID, "    " .. tostring(k) .. " = " .. tostring(v))
              end
              -- Non aggiungere a idsToRemove qui, altrimenti non vediamo se altri hotspot hanno lo stesso problema
          elseif type(spot.lastSeenFrame) ~= "number" then
               Log(teamID, "DEBUG: DecayHotspots - Spot id: " .. tostring(id) .. " has spot.lastSeenFrame of type " .. type(spot.lastSeenFrame) .. " instead of number. Value: " .. tostring(spot.lastSeenFrame))
          else
          -- === FINE NUOVO BLOCCO DEBUG ===
	  
          if frame - spot.lastSeenFrame > decayTime then
              table.insert(idsToRemove, id)
              removedCount = removedCount + 1
          end
		  end -- Fine del blocco else del debug
      end

      if removedCount > 0 then
          for _, idToRemove in ipairs(idsToRemove) do
              data.hotspots[idToRemove] = nil
          end
          Log(teamID, "DecayHotspots: Removed " .. removedCount .. " old hotspot(s).")
      end
  end
 
 
 
 
 local function FindBestHotspotToAttack(teamID, data, attackingGroupData, currentFrame) -- Aggiunto currentFrame
      local bestHotspot = nil
      local highestScore = -1000000 -- Inizializza a un valore molto basso (usiamo math.huge se disponibile, ma -1M è sicuro)
      local consideredCount = 0
      local suitableCount = 0

      if not attackingGroupData or not attackingGroupData.units or #attackingGroupData.units == 0 then
          Log(teamID, "WARN FindBestHotspot: Attacking group data invalid or empty.")
          return nil 
      end
      
      -- Calcola la posizione approssimativa del gruppo AI
      local groupX, groupY, groupZ = 0, 0, 0
      local validUnitCount = 0
      for _, unitID in ipairs(attackingGroupData.units) do
          local ux, uy, uz = Spring.GetUnitPosition(unitID)
          if ux then
              groupX = groupX + ux; groupY = groupY + uy; groupZ = groupZ + uz;
              validUnitCount = validUnitCount + 1
          end
      end
      if validUnitCount == 0 then 
          Log(teamID, "WARN FindBestHotspot: Could not get group " .. attackingGroupData.id .. " position.")
          return nil 
      end
      groupX = groupX / validUnitCount
      groupY = groupY / validUnitCount
      groupZ = groupZ / validUnitCount
      
      Log(teamID, "LOG_DETAILED FindBestHotspot: Group " .. attackingGroupData.id .. " at ~"..string.format("%.0f,%.0f", groupX, groupZ).." searching for hotspot. GroupCaps L/A/N: "..tostring(attackingGroupData.canAttackLand).."/"..tostring(attackingGroupData.canAttackAir).."/"..tostring(attackingGroupData.canAttackNaval))

      -- Itera sugli hotspot attivi
      for hotspotID, hotspot in pairs(data.hotspots) do
          consideredCount = consideredCount + 1
          local score = 0
          local canEngage = false
          local reasonCannotEngage = "OK"

          -- === Controllo Compatibilità Gruppo vs Hotspot ===
          -- Il gruppo può effettivamente danneggiare i tipi di unità presenti nell'hotspot?
          if hotspot.hasLandEnemies and attackingGroupData.canAttackLand then canEngage = true 
          elseif hotspot.hasAirEnemies and attackingGroupData.canAttackAir then canEngage = true 
          elseif hotspot.hasNavalEnemies and attackingGroupData.canAttackNaval then canEngage = true 
          -- Se non può colpire specifici, ma l'hotspot è misto/sconosciuto E il gruppo può attaccare *qualcosa*
          elseif (hotspot.dominantEnemyMoveType == "UNKNOWN" or hotspot.dominantEnemyMoveType == "MIXED" or not hotspot.dominantEnemyMoveType) then
               if attackingGroupData.canAttackLand or attackingGroupData.canAttackAir or attackingGroupData.canAttackNaval then
                   canEngage = true 
                   reasonCannotEngage = "Type UNKNOWN/MIXED, Group can attack something"
               else reasonCannotEngage = "Group cannot attack anything" end
          else reasonCannotEngage = "Group cannot attack required type(s) (L:"..tostring(hotspot.hasLandEnemies).." A:"..tostring(hotspot.hasAirEnemies).." N:"..tostring(hotspot.hasNavalEnemies)..")"
          end

          Log(teamID, "LOG_DETAILED FindBestHotspot: Evaluating Hotspot "..hotspotID.." (Type:"..(hotspot.dominantEnemyMoveType or "N/A").." L/A/N:"..tostring(hotspot.hasLandEnemies).."/"..tostring(hotspot.hasAirEnemies).."/"..tostring(hotspot.hasNavalEnemies).." NeedsReinforce:"..tostring(hotspot.needsReinforcement)..") - CanEngage: " .. tostring(canEngage) .. " ("..reasonCannotEngage..")")

          if canEngage then
              suitableCount = suitableCount + 1
              -- === Calcolo Punteggio Hotspot ===
              -- Fattori: Forza, Distanza, Recenza, Urgenza
              
              -- 1. Forza dell'hotspot
              local strengthScore = (hotspot.strength or 1) * 10 
              score = score + strengthScore

              -- 2. Distanza (penalità)
              local dx, dz = hotspot.x - groupX, hotspot.z - groupZ
              local distSq = dx*dx + dz*dz
              local maxAttackDistSq = 2000 * 2000 -- Raggio massimo di considerazione (aumentato)
              local distPenalty = 0
              if distSq < 1 then distSq = 1 end -- Evita divisione per zero / log di zero

              if distSq < maxAttackDistSq then 
                  distPenalty = math.sqrt(distSq) * 0.1 -- Penalità lineare (aggiustabile)
                  score = score - distPenalty
              else 
                 -- Se troppo lontano, penalità molto forte
                 distPenalty = 10000 
                 score = score - distPenalty 
              end
------------------------ inizio debug
              -- 3. Recenza (penalità per età)
			  
		      Log(teamID, "DEBUG FindBestHotspot "..hotspotID..": Calculating age. Received currentFrame: " .. tostring(currentFrame) .. ", hotspot.lastSeenFrame: " .. tostring(hotspot.lastSeenFrame) .. ", Game.gameSpeed: " .. tostring(Game.gameSpeed))
			  Log(teamID, "DEBUG FindBestHotspot "..hotspotID..": Calculating age. Game.frame: " .. tostring(Game.frame) .. ", hotspot.lastSeenFrame: " .. tostring(hotspot.lastSeenFrame) .. ", Game.gameSpeed: " .. tostring(Game.gameSpeed))
			  Log(teamID, "DEBUG FindBestHotspot: Type of 'Game' is: " .. type(Game))
			  
			  -- 3. Recenza (penalità per età)
              Log(teamID, "DEBUG FindBestHotspot "..hotspotID..": Calculating age.")
              Log(teamID, "DEBUG FindBestHotspot: Type of GLOBAL Game is: " .. type(_G.Game)) -- Controlla la globale
              Log(teamID, "DEBUG FindBestHotspot: Type of LOCAL Game is: " .. type(Game))   -- Controlla la locale
              
              if type(Game) == "table" then
                  Log(teamID, "DEBUG FindBestHotspot: LOCAL Game.frame is: " .. tostring(Game.frame) .. " (Type: " .. type(Game.frame) .. ")")
                  Log(teamID, "DEBUG FindBestHotspot: GLOBAL Game.frame is: " .. tostring(_G.Game.frame) .. " (Type: " .. type(_G.Game.frame) .. ")") -- Accedi direttamente alla globale
                  Log(teamID, "DEBUG FindBestHotspot: hotspot.lastSeenFrame is: " .. tostring(hotspot.lastSeenFrame) .. " (Type: " .. type(hotspot.lastSeenFrame) .. ")")
                  Log(teamID, "DEBUG FindBestHotspot: Game.gameSpeed is: " .. tostring(Game.gameSpeed) .. " (Type: " .. type(Game.gameSpeed) .. ")")
              else
                  Log(teamID, "WARN FindBestHotspot: LOCAL Game is not a table!")
              end
              
              -- RIGA PROBLEMATICA (~1523):
              local ageInSeconds = (currentFrame - hotspot.lastSeenFrame) / (Game.gameSpeed or 30) 
              local agePenalty = ageInSeconds * 2
              score = score - agePenalty
			  
			  --------------------------- fine debug
			  
              local ageInSeconds = (currentFrame - hotspot.lastSeenFrame) / (Game.gameSpeed or 30)
              local agePenalty = ageInSeconds * 2 -- Penalità per secondo (aggiustabile)
              score = score - agePenalty 

              -- 4. Urgenza (Bonus Molto Alto)
              local urgentBonus = 0
              if hotspot.needsReinforcement then
                  urgentBonus = 10000 -- Bonus MOLTO ALTO (assicura priorità)
                  score = score + urgentBonus
                  -- Log(teamID, "LOG_DETAILED FindBestHotspot: Hotspot "..hotspotID.." is URGENT! Added Urgent Bonus: +"..urgentBonus) -- Log già incluso sotto
              end

              Log(teamID, "LOG_DETAILED FindBestHotspot: Hotspot "..hotspotID.." ScoreCalc: StrScr="..string.format("%.1f", strengthScore).." - DistPen="..string.format("%.1f", distPenalty).." - AgePen="..string.format("%.1f", agePenalty).." + UrgentBonus="..urgentBonus.." = FINAL SCORE: "..string.format("%.1f", score))

              -- Confronta con il miglior punteggio trovato finora
              if score > highestScore then
                  highestScore = score
                  bestHotspot = hotspot
                  Log(teamID, "LOG_DETAILED FindBestHotspot: >>> Hotspot "..hotspotID.." is new best candidate (Score: "..string.format("%.1f", highestScore)..")")
              end
          end -- fine if canEngage
      end -- fine for pairs(data.hotspots)

      if bestHotspot then
        Log(teamID, "FindBestHotspot: Group " .. attackingGroupData.id .. " chose Hotspot " .. bestHotspot.id .. " (Type: "..(bestHotspot.dominantEnemyMoveType or "N/A")..") with score " .. string.format("%.1f", highestScore) .. ". Considered: "..consideredCount..", Suitable: "..suitableCount)
      else 
          Log(teamID, "FindBestHotspot: Group " .. attackingGroupData.id .. " found no suitable hotspot. Considered: "..consideredCount..", Suitable: "..suitableCount)
      end
      
      return bestHotspot
  end



 function UpdateCombatGroupStates(teamID, frame, data)
      local groupIDsToIterate = {}; for id,_ in pairs(data.combatGroups) do table.insert(groupIDsToIterate, id) end
      
      for _, groupID in ipairs(groupIDsToIterate) do
          local groupData = data.combatGroups[groupID]
          if groupData then
              local originalState = groupData.state 
              local unitCountStart = 0
              if groupData.units then unitCountStart = #groupData.units end

              -- Rimuovi unità morte e conta perdite
              local aliveUnits = {}
              local unitsLostThisUpdate = 0
              local oldUnitMap = {}
              if groupData.units then 
                 for _,uID in ipairs(groupData.units) do oldUnitMap[uID] = true end
              end

              for uID, _ in pairs(oldUnitMap) do 
                 if Spring.ValidUnitID(uID) and not Spring.GetUnitIsDead(uID) then
                    table.insert(aliveUnits, uID)
                 else
                    unitsLostThisUpdate = unitsLostThisUpdate + 1
                    if data.combatUnits[uID] then
                       Log(teamID,"LOG_DETAILED UpdateCombat: Unit "..uID.." destroyed/removed from group "..groupID)
                       data.combatUnits[uID].groupID = nil
                       data.combatUnits[uID].state = "idle" 
                    end
                 end
              end
              groupData.units = aliveUnits
              local unitCountEnd = #groupData.units

              if unitCountEnd == 0 then
                  Log(teamID, "UpdateCombatGroupStates: Group " .. groupID .. " became empty, removing group.")
                  data.combatGroups[groupID] = nil
              else 
                  local associatedHotspotID = nil
                  local associatedHotspot = nil
                  local groupEngagedEnemyLocallyThisFrame = false 

                  -- Determina l'hotspot associato se il gruppo sta attaccando un hotspot assegnato
                  if groupData.state == "attacking_hotspot" then
                      associatedHotspotID = groupData.targetHotspotID
                      if associatedHotspotID then
                          associatedHotspot = data.hotspots[associatedHotspotID]
                      end
                  end

                  -- === 1. LOGICA DI REATTIVITÀ LOCALE E POTENZIALE ESCALATION A HOTSPOT URGENTE ===
                  if (groupData.state == "patrolling_area" or groupData.state == "moving_to_patrol") then
                      local groupCenterX, groupCenterY, groupCenterZ, validUnitCountForScan = 0,0,0,0
                      if groupData.units and #groupData.units > 0 then
                          for _, unitID_scan in ipairs(groupData.units) do
                              local ux, uy, uz = Spring.GetUnitPosition(unitID_scan)
                              if ux then 
                                  groupCenterX=groupCenterX+ux; groupCenterY=groupCenterY+uy; groupCenterZ=groupCenterZ+uz; 
                                  validUnitCountForScan=validUnitCountForScan+1 
                              end
                          end
                      end
                      
                      if validUnitCountForScan > 0 then
                          groupCenterX=groupCenterX/validUnitCountForScan; groupCenterY=groupCenterY/validUnitCountForScan; groupCenterZ=groupCenterZ/validUnitCountForScan;
                          local detectionRadius = 400 
                          local allUnitsInSphere = Spring.GetUnitsInSphere(groupCenterX, groupCenterY, groupCenterZ, detectionRadius) 
                          local enemiesNearbyFiltered = {} -- Rinominato per chiarezza
                          if allUnitsInSphere then
                              for _, unitIDinSphere in ipairs(allUnitsInSphere) do
                                  local unitActualTeam = Spring.GetUnitTeam(unitIDinSphere)
                                  if unitActualTeam ~= teamID and not Spring.AreTeamsAllied(teamID, unitActualTeam) then
                                      table.insert(enemiesNearbyFiltered, unitIDinSphere)
                                  end
                              end
                          end
                          
                          if #enemiesNearbyFiltered > 0 then
                              Log(teamID, "UpdateCombatGroupStates: Group " .. groupID .. " (State:"..originalState..") detected " .. #enemiesNearbyFiltered .. " enemies locally! Switching to ENGAGING_ENEMY.")
                              groupData.state = "engaging_enemy" 
                              groupData.lastEngageOrderFrame = frame 
                              
                              local firstEnemyID = enemiesNearbyFiltered[1]
                              local ex, ey, ez = Spring.GetUnitPosition(firstEnemyID)
                              local enemyDefID_forHotspot = Spring.GetUnitDefID(firstEnemyID) -- DefID del nemico

                              if ex then
                                  local CMD_FIGHT_ID = 16 
                                  Spring.GiveOrderToUnitArray(groupData.units, CMD_FIGHT_ID, {ex,ey,ez}, {}) 
                                  for _, uID_state in ipairs(groupData.units) do 
                                      if data.combatUnits[uID_state] then data.combatUnits[uID_state].state = "attacking" end 
                                  end

                                  -- CREA/AGGIORNA HOTSPOT PER L'INGAGGIO LOCALE E VALUTA SE URGENTE
                                  local hotspotType = "LOCAL_ENGAGEMENT" 
                                  local hotspotStrength = #enemiesNearbyFiltered 
                                  local hotspotRadius = 200 + (#enemiesNearbyFiltered * 5) 
                                  
                                  -- Usiamo l'ID della prima unità del gruppo come "creator" per questo hotspot automatico
                                  local creatorForAutoHotspot = groupData.units[1] 
                                  
                                  local createdOrUpdatedHotspotID = CreateOrUpdateHotspot(teamID, data, frame, ex, ey, ez, 
                                                                          hotspotType, hotspotStrength, hotspotRadius, 
                                                                          creatorForAutoHotspot, enemyDefID_forHotspot)
                                  
                                  if createdOrUpdatedHotspotID and data.hotspots[createdOrUpdatedHotspotID] then
                                      local engagedHotspot = data.hotspots[createdOrUpdatedHotspotID]
                                      -- Valuta la pressione per questo nuovo/aggiornato hotspot
                                      local ownStrength = unitCountEnd 
                                      local enemyStrengthForEval = engagedHotspot.strength or 1 -- Forza dall'hotspot
                                      if enemyStrengthForEval > ownStrength * 1.5 then -- Se i nemici sono > 1.5x noi
                                          if not engagedHotspot.needsReinforcement then
                                             Log(teamID, ">>>> UpdateCombatGroupStates: Group " .. groupID .. " in tough LOCAL engagement (Own:"..ownStrength.." vs Est.Enemy:"..enemyStrengthForEval.."). Setting needsReinforcement for Hotspot " .. createdOrUpdatedHotspotID)
                                          end
                                          engagedHotspot.needsReinforcement = true
                                          engagedHotspot.lastReinforcementCheckFrame = frame
                                          associatedHotspot = engagedHotspot -- Associa questo hotspot per la logica di pressione
                                          associatedHotspotID = createdOrUpdatedHotspotID
                                      end
                                  end
                              end
                              groupEngagedEnemyLocallyThisFrame = true 
                          end
                      end
                  end
                  -- === FINE REATTIVITÀ LOCALE ===


                  -- === 2. VALUTAZIONE PRESSIONE PER HOTSPOT ASSEGNATI (se non appena ingaggiato localmente) ===
                  if not groupEngagedEnemyLocallyThisFrame and associatedHotspot and (frame % 61 == groupID % 61) then 
                       local lostPercent = 0
                       if unitCountStart > 0 then lostPercent = (unitsLostThisUpdate / unitCountStart) * 100 end
                       local enemyStrength = associatedHotspot.strength or 1 
                       local ownStrength = unitCountEnd 
                       
                       local needsHelp = false
                       local helpReason = ""
                       if lostPercent > 20 then 
                           helpReason = "High losses ("..string.format("%.0f", lostPercent).."%) during assigned attack"
                           needsHelp = true
                       elseif enemyStrength > ownStrength * 1.5 then 
                           helpReason = "Outnumbered (Own:"..ownStrength.." vs Est.Enemy:"..enemyStrength..") during assigned attack"
                           needsHelp = true
                       end

                       if needsHelp then
                           if not associatedHotspot.needsReinforcement then
                              Log(teamID, ">>>> UpdateCombatGroupStates: Group " .. groupID .. " (attacking assigned hotspot) requesting reinforcements for Hotspot " .. associatedHotspotID .. " Reason: " .. helpReason)
                              associatedHotspot.needsReinforcement = true
                              associatedHotspot.lastReinforcementCheckFrame = frame 
                           end
                       elseif associatedHotspot.needsReinforcement then 
                           local resetReinforceFlagTime = 30 * (Game.gameSpeed or 30) 
                           if frame - (associatedHotspot.lastReinforcementCheckFrame or 0) > resetReinforceFlagTime and unitsLostThisUpdate == 0 then
                               Log(teamID, "UpdateCombatGroupStates: Resetting old needsReinforcement flag for Hotspot " .. associatedHotspotID .. " as situation seems stable (assigned attack).")
                               associatedHotspot.needsReinforcement = false
                           end
                       end
                  end
                  -- === FINE VALUTAZIONE PRESSIONE PER HOTSPOT ASSEGNATI ===

                  -- === 3. GESTIONE STATI PRINCIPALI (solo se NON ingaggiato localmente questo frame) ===
                  if not groupEngagedEnemyLocallyThisFrame then
                      
                      if groupData.state == "attacking_hotspot" then
                          if not associatedHotspot then -- L'hotspot target è sparito
                              Log(teamID, "UpdateCombatGroupStates: Group " .. groupID .. " target hotspot " .. (associatedHotspotID or "N/A") .. " vanished. Switching to IDLE.")
                              groupData.state = "idle"; groupData.targetHotspotID = nil; groupData.targetPoint = nil;
                              Spring.GiveOrderToUnitArray(groupData.units, CMD.STOP, {}, {}) 
                          else
                              local hotspotAgeLimit = (Game.gameSpeed or 30) * 25 
                              if frame - associatedHotspot.lastSeenFrame > hotspotAgeLimit and not associatedHotspot.needsReinforcement then -- Se è vecchio E non chiede rinforzi
                                  Log(teamID, "UpdateCombatGroupStates: Group " .. groupID .. " target hotspot " .. associatedHotspotID .. " is old and not urgent. Switching to IDLE.")
                                  groupData.state = "idle"; groupData.targetHotspotID = nil; groupData.targetPoint = nil;
                                  Spring.GiveOrderToUnitArray(groupData.units, CMD.STOP, {}, {}) 
                              end
                          end
                      
                      elseif groupData.state == "patrolling_area" then
                          -- ... (logica esistente per completamento pattuglia) ...
                          if allIdleNearTarget then -- Assumendo che allIdleNearTarget sia calcolata correttamente prima
                               Log(teamID,"UpdateCombatGroupStates: Group "..groupID.." completed patrol at point #"..tostring(groupData.currentPatrolIndex) .. ". Switching to IDLE.")
                               groupData.state = "idle"; groupData.targetPoint = nil; groupData.currentPatrolIndex = nil;
                               Spring.GiveOrderToUnitArray(groupData.units, CMD.STOP, {}, {}) 
                          end
                          
                      elseif groupData.state == "engaging_enemy" then
                          -- Questo stato è per l'ingaggio locale.
                          -- Se non è stato 'groupEngagedEnemyLocallyThisFrame', significa che era già in questo stato.
                          if frame - (groupData.lastEngageOrderFrame or 0) > 90 then -- Controlla periodicamente se il combattimento è finito
                              local groupCenterX_eng, groupCenterY_eng, groupCenterZ_eng, validUnitCount_eng = 0,0,0,0
                              -- ... (Calcola centro gruppo) ...
                               if validUnitCount_eng > 0 then
                                   -- ... (Calcola groupCenterX_eng, ecc.) ...
                                   local checkRadius = 450
                                   local allUnitsCheck = Spring.GetUnitsInSphere(groupCenterX_eng, groupCenterY_eng, groupCenterZ_eng, checkRadius) 
                                   local enemiesStillNearby = {}
                                   -- ... (Filtro nemici) ...
                                   if #enemiesStillNearby == 0 then
                                       Log(teamID, "UpdateCombatGroupStates: Group " .. groupID .. " no longer finds enemies after local engagement. Switching to IDLE.")
                                       groupData.state = "idle" 
                                       Spring.GiveOrderToUnitArray(groupData.units, CMD.STOP, {}, {}) 
                                   else
                                       groupData.lastEngageOrderFrame = frame 
                                   end
                               end
                          end 
                          
                      elseif groupData.state == "patrol_complete" then 
                          groupData.state = "idle"
                      end 
                  end 
              end 
          end 
      end 
  end
  


 local function AssignTaskToGroup(teamID, data, groupID, frame)
      local groupData = data.combatGroups[groupID]
      if not groupData or #groupData.units == 0 then
          Log(teamID, "AssignTaskToGroup: Group " .. groupID .. " is empty or nil, removing.")
          data.combatGroups[groupID] = nil
          return
      end
      Log(teamID, "AssignTaskToGroup: Assigning task to Group " .. groupID .. " (Current state: "..(groupData.state or "N/A")..")")

      -- === NUOVA PRIORITÀ 1: ATTACCA HOTSPOT ===
      -- Trova il miglior hotspot per questo gruppo specifico
      local targetHotspot = FindBestHotspotToAttack(teamID, data, groupData, frame) -- Passa 'frame'

      if targetHotspot then
          Log(teamID, ">>>> AssignTaskToGroup: Group " .. groupID .. " assigned to ATTACK Hotspot " .. targetHotspot.id .. " (Type: "..(targetHotspot.dominantEnemyMoveType or "N/A").." NeedsReinforce:"..tostring(targetHotspot.needsReinforcement)..") at " .. string.format("%.0f,%.0f", targetHotspot.x, targetHotspot.z))
          
          groupData.state = "attacking_hotspot" -- Nuovo stato
          groupData.targetPoint = {targetHotspot.x, targetHotspot.y, targetHotspot.z} -- Salva le coordinate target
          groupData.targetHotspotID = targetHotspot.id -- Salva l'ID dell'hotspot bersaglio
          groupData.currentPatrolIndex = nil -- Non sta pattugliando

          -- Comando da dare: CMD.FIGHT (ID 16) è spesso buono per attacco-movimento verso un'area
          local CMD_FIGHT_ID = 16
          Spring.GiveOrderToUnitArray(groupData.units, CMD_FIGHT_ID, groupData.targetPoint, {}) -- No SHIFT, nuovo ordine primario
          
          for _, unitID in ipairs(groupData.units) do
              if data.combatUnits[unitID] then data.combatUnits[unitID].state = "attacking" end 
          end
          groupData.lastOrderFrame = frame
          return -- Compito assegnato (Hotspot)
      end
      -- === FINE PRIORITÀ 1 ===

      -- === PRIORITÀ 2: PATTUGLIAMENTO (Logica Esistente) ===
      -- Se non è stato trovato nessun hotspot adatto, procedi con l'assegnazione del pattugliamento
      Log(teamID, "AssignTaskToGroup: Group " .. groupID .. ": No suitable hotspot found, assigning patrol task.")
      
      if #data.patrolPoints == 0 then
          Log(teamID, "AssignTaskToGroup: Group " .. groupID .. ": No patrol points defined. Remaining idle.")
          groupData.state = "idle"
          return
      end

      local startX, _, startZ = Spring.GetTeamStartPosition(teamID) -- Serve per ordinare
      local patrolPointData = nil
      local assignedPatrolIndex = -1

      -- Logica per scegliere il punto di pattuglia (priorità a punti lontani/non occupati)
      local sortedPatrolPoints = {}
      for i, p in ipairs(data.patrolPoints) do
          if startX and p.x then 
            local dx, dz = p.x - startX, p.z - startZ
            table.insert(sortedPatrolPoints, { index = i, point = p, distSq = dx*dx + dz*dz })
          end
      end
      table.sort(sortedPatrolPoints, function(a,b) return a.distSq > b.distSq end) 

      local activePatrolIndices = {} 
      for otherGroupID, otherGroupData in pairs(data.combatGroups) do
          if otherGroupID ~= groupID and otherGroupData.currentPatrolIndex and
             (otherGroupData.state == "patrolling_area" or otherGroupData.state == "moving_to_patrol" or otherGroupData.state == "engaging_enemy") then 
              activePatrolIndices[otherGroupData.currentPatrolIndex] = true
          end
      end

      local chosenPointReason = "Unknown"
      for _, sortedPInfo in ipairs(sortedPatrolPoints) do
          if not activePatrolIndices[sortedPInfo.index] then
              patrolPointData = sortedPInfo.point
              assignedPatrolIndex = sortedPInfo.index
              chosenPointReason = "Preferred distant/unassigned"
              break
          end
      end

      if not patrolPointData then
          chosenPointReason = "Cyclic fallback"
          local attempts = 0
          local maxAttempts = #data.patrolPoints
          local startIndex = data.nextPatrolPointIndex           
          while attempts < maxAttempts do
              local currentIndex = ((startIndex -1 + attempts) % #data.patrolPoints) + 1 
              if not activePatrolIndices[currentIndex] or #data.patrolPoints <= 2 then 
                  patrolPointData = data.patrolPoints[currentIndex]
                  assignedPatrolIndex = currentIndex
                  data.nextPatrolPointIndex = (currentIndex % #data.patrolPoints) + 1 
                  break
              end
              attempts = attempts + 1
          end
          if not patrolPointData then 
              chosenPointReason = "Cyclic fallback (forced)"
              assignedPatrolIndex = data.nextPatrolPointIndex
              patrolPointData = data.patrolPoints[assignedPatrolIndex]
              data.nextPatrolPointIndex = (data.nextPatrolPointIndex % #data.patrolPoints) + 1
          end
      end
      
      if not patrolPointData or assignedPatrolIndex == -1 then
          Log(teamID, "AssignTaskToGroup: Group " .. groupID .. ": CRITICAL - Could not assign any patrol point after checking hotspots. Idling.")
          groupData.state = "idle"
          return
      end

      Log(teamID, ">>>> AssignTaskToGroup: Group " .. groupID .. " assigned to PATROL point #" .. assignedPatrolIndex .. " ("..(patrolPointData.type or "N/A")..") at " .. string.format("%.0f,%.0f", patrolPointData.x, patrolPointData.z) .. " (Reason: "..chosenPointReason..")")
      groupData.state = "patrolling_area" 
      groupData.targetPoint = {patrolPointData.x, patrolPointData.y, patrolPointData.z}
      groupData.currentPatrolIndex = assignedPatrolIndex
      groupData.targetHotspotID = nil -- Assicura sia nil

      local CMD_PATROL_ID = 15 
      Spring.GiveOrderToUnitArray(groupData.units, CMD_PATROL_ID, groupData.targetPoint, {"SHIFT"}) 
      
      for _, unitID in ipairs(groupData.units) do
          if data.combatUnits[unitID] then data.combatUnits[unitID].state = "patrolling" end 
      end
      groupData.lastOrderFrame = frame
  end
  

 local function ReassignGroupsToUrgentHotspots(teamID, data, frame)
      local urgentHotspots = {}
      -- 1. Trova tutti gli hotspot urgenti
      for id, spot in pairs(data.hotspots) do
          if spot.needsReinforcement then
              spot.id = id -- Assicura che l'ID sia nella tabella spot stessa
              table.insert(urgentHotspots, spot)
          end
      end

      if #urgentHotspots == 0 then return end -- Nessun hotspot urgente

      Log(teamID, "ReassignGroups: Found " .. #urgentHotspots .. " urgent hotspots needing reinforcements.")

      -- Ordina gli hotspot urgenti (opzionale, es. per forza o vicinanza alla base)
      -- table.sort(urgentHotspots, function(a,b) return a.strength > b.strength end) 

      local reassignedGroups = {} -- Tieni traccia dei gruppi già riassegnati in questo ciclo

      -- 2. Itera sugli hotspot urgenti
      for i, urgentSpot in ipairs(urgentHotspots) do 
          local hotspotID = urgentSpot.id 
          Log(teamID, "ReassignGroups: Evaluating urgent hotspot " .. hotspotID .. " at ~"..string.format("%.0f, %.0f", urgentSpot.x, urgentSpot.z))
          
          -- Quanti gruppi stanno GIA' andando verso questo hotspot?
          local groupsAlreadyTargeting = 0
          for gid, gdata in pairs(data.combatGroups) do
             if gdata.state == "attacking_hotspot" and gdata.targetHotspotID == hotspotID then
                groupsAlreadyTargeting = groupsAlreadyTargeting + 1
             end
          end
          
          local desiredReinforcements = 1 -- Quanti gruppi extra vogliamo mandare? (Aggiustabile)
          if groupsAlreadyTargeting >= desiredReinforcements then
              Log(teamID, "ReassignGroups: Hotspot " .. hotspotID .. " already has enough ("..groupsAlreadyTargeting..") reinforcements assigned or en route. Skipping.")
              -- Continua con il prossimo hotspot nel ciclo ipairs
          else
              -- 3. Cerca il miglior gruppo "sacrificabile" per questo hotspot urgente
              local bestGroupToReassign = nil
              local lowestDistSq = math.huge

              for groupID, groupData in pairs(data.combatGroups) do
                  -- Se il gruppo non è già stato riassegnato E è in uno stato sacrificabile...
                  if not reassignedGroups[groupID] and 
                     (groupData.state == "patrolling_area" or groupData.state == "moving_to_patrol" or groupData.state == "idle") -- Considera questi stati
                  then 
                      -- Verifica compatibilità del gruppo
                      local canEngage = false
                      if urgentSpot.hasLandEnemies and groupData.canAttackLand then canEngage = true 
                      elseif urgentSpot.hasAirEnemies and groupData.canAttackAir then canEngage = true 
                      elseif urgentSpot.hasNavalEnemies and groupData.canAttackNaval then canEngage = true 
                      elseif (urgentSpot.dominantEnemyMoveType == "UNKNOWN" or urgentSpot.dominantEnemyMoveType == "MIXED" or not urgentSpot.dominantEnemyMoveType) then
                         if groupData.canAttackLand or groupData.canAttackAir or groupData.canAttackNaval then canEngage = true end
                      end

                      if canEngage then
                          -- Calcola posizione gruppo
                          local groupX, groupY, groupZ, validUnitCount = 0,0,0,0
                          if groupData.units then -- Aggiunto controllo
                             for _, unitID in ipairs(groupData.units) do
                                 local ux, uy, uz = Spring.GetUnitPosition(unitID)
                                 if ux then groupX=groupX+ux; groupZ=groupZ+uz; groupY=groupY+uy; validUnitCount=validUnitCount+1 end -- Aggiunto groupY
                             end
                          end

                          if validUnitCount > 0 then
                             groupX = groupX / validUnitCount; groupZ = groupZ / validUnitCount;
                             local dx, dz = urgentSpot.x - groupX, urgentSpot.z - groupZ
                             local distSq = dx*dx + dz*dz
                             
                             if distSq < lowestDistSq then
                                 lowestDistSq = distSq
                                 bestGroupToReassign = groupData 
                             end
                          end 
                      end 
                  end 
              end -- fine loop ricerca gruppo

              -- 4. Riassegna il gruppo trovato (se ne esiste uno)
              if bestGroupToReassign then
                  local groupToReassignID = bestGroupToReassign.id
                  Log(teamID, ">>>> ReassignGroups: Reassigning Group " .. groupToReassignID .. " (State: "..bestGroupToReassign.state..") to URGENT Hotspot " .. hotspotID)
                  
                  -- Interrompi compito attuale e dai STOP
                  Spring.GiveOrderToUnitArray(bestGroupToReassign.units, CMD.STOP, {}, {}) 
                  
                  -- Assegna nuovo compito
                  bestGroupToReassign.state = "attacking_hotspot" 
                  bestGroupToReassign.targetPoint = {urgentSpot.x, urgentSpot.y, urgentSpot.z} 
                  bestGroupToReassign.targetHotspotID = hotspotID 
                  bestGroupToReassign.currentPatrolIndex = nil 
                  bestGroupToReassign.lastOrderFrame = frame
                  for _, unitID in ipairs(bestGroupToReassign.units) do
                      if data.combatUnits[unitID] then data.combatUnits[unitID].state = "attacking" end 
                  end
                  
                  -- Dai ordine di attacco (FIGHT)
                  local CMD_FIGHT_ID = 16
                  Spring.GiveOrderToUnitArray(bestGroupToReassign.units, CMD_FIGHT_ID, bestGroupToReassign.targetPoint, {}) 

                  reassignedGroups[groupToReassignID] = true -- Marca come riassegnato
                  
                  -- Non serve break, il ciclo ipairs continuerà al prossimo hotspot urgente
              else
                  Log(teamID, "ReassignGroups: No suitable nearby group found to reinforce hotspot " .. hotspotID)
              end -- fine if bestGroupToReassign
              
          end -- fine if groupsAlreadyTargeting < desiredReinforcements
      end -- fine loop hotspot urgenti (ipairs)
  end -- fine funzione ReassignGroupsToUrgentHotspots
 



   local function UpdateEnemyDetectionsAndHotspots(teamID, data, frame)
    local unitsScannedThisFrame = 0
    local hotspotsCreatedOrUpdatedThisFrame = 0
    local combatUnitCount = 0
    for _ in pairs(data.combatUnits) do combatUnitCount=combatUnitCount+1; break end
    if combatUnitCount == 0 then return end

    for unitID, unitData in pairs(data.combatUnits) do
        if Spring.ValidUnitID(unitID) and not Spring.GetUnitIsDead(unitID) then
            local uDefID = Spring.GetUnitDefID(unitID)
            local aiUnitData = GetAiUnitDataByDefID(uDefID) 

            if aiUnitData then 
                local scanRadius = aiUnitData.viewradius or 450 -- Leggi dalla TUA tabella factionUnits
                if type(scanRadius) ~= "number" or scanRadius <= 0 then 
                    Log(teamID, "WARN: Invalid/missing viewradius for "..aiUnitData.name.." in factionUnits, using fallback 450.")
                    scanRadius = 450 
                end 
                
                local ux, uy, uz = Spring.GetUnitPosition(unitID)
                if ux then
                    local allUnitsNearby = Spring.GetUnitsInSphere(ux, uy, uz, scanRadius)
                    local enemiesFoundInScan = {}
                    if allUnitsNearby then
                        for _, otherUnitID in ipairs(allUnitsNearby) do
                            local otherUnitTeam = Spring.GetUnitTeam(otherUnitID)
                            if otherUnitTeam ~= teamID and not Spring.AreTeamsAllied(teamID, otherUnitTeam) then
                                table.insert(enemiesFoundInScan, otherUnitID)
                            end
                        end
                    end

                    if #enemiesFoundInScan > 0 then
                        local firstEnemyID = enemiesFoundInScan[1]
                        local ex, ey, ez = Spring.GetUnitPosition(firstEnemyID)
                        local enemyDefID = Spring.GetUnitDefID(firstEnemyID)

                        if ex then 
                            local hotspotType = "ENEMY_UNIT_SIGHTING"
                            local hotspotStrength = #enemiesFoundInScan 
                            local hotspotRadius = 250 + (#enemiesFoundInScan * 10)
                                                    
                            local createdHotspotID = CreateOrUpdateHotspot(teamID, data, frame, ex, ey, ez, hotspotType, hotspotStrength, hotspotRadius, unitID, enemyDefID)
                            if createdHotspotID then
                                hotspotsCreatedOrUpdatedThisFrame = hotspotsCreatedOrUpdatedThisFrame + 1
                            end
                        end
                    end
                    unitsScannedThisFrame = unitsScannedThisFrame + 1
                end 
             else
                -- Log(teamID, "WARN: UEDAH - Could not find AI Unit Data for DefID: " .. uDefID .. " UnitID: " .. unitID)
             end
        end 
    end 
    if hotspotsCreatedOrUpdatedThisFrame > 0 then
       Log(teamID, "UpdateEnemyDetections: Created/Updated " .. hotspotsCreatedOrUpdatedThisFrame .. " hotspot(s) this frame. Scanned " .. unitsScannedThisFrame .. " units.")
    end
end
 
 
 
 
 
 
  local function ManageMilitary(teamID, frame)
      local data = teamData[teamID]
      if not data or data.techLevel == nil then return end
      local config = aiConfig[data.techLevel]
      if not config then return end

      -- 1. AGGIORNA STATO GRUPPI ESISTENTI E VALUTA PRESSIONE
      UpdateCombatGroupStates(teamID, frame, data)

      -- 2. GESTIONE HOTSPOT (se non fatto altrove - assicurati siano chiamati!)
      -- DecayHotspots(teamID, data, frame) -- Chiamato da GameFrame
      -- UpdateEnemyDetectionsAndHotspots(teamID, data, frame) -- Chiamato sotto con modulo

      -- 3. RIASSEGNA GRUPPI PER RINFORZI URGENTI
      -- Frequenza: ogni ciclo di ManageMilitary o con modulo? Proviamo ogni ciclo per ora.
      ReassignGroupsToUrgentHotspots(teamID, data, frame)
      
      -- 4. RILEVA NEMICI E CREA/AGGIORNA HOTSPOT (se non fatto altrove)
      -- Frequenza: Non troppo spesso
      if frame % 31 == (teamID * 2) % 31 then 
          -- Log(teamID, "DEBUG: Calling UpdateEnemyDetectionsAndHotspots") -- Log opzionale
          UpdateEnemyDetectionsAndHotspots(teamID, data, frame)
      end

      -- 5. FORMA NUOVI GRUPPI CON UNITÀ IDLE
      if config.attackGroup then 
          local allowedMoveTypes = {} 
          if currentMapCategory == "LAND" then allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true } -- Nota: Manca BUILDING qui, era corretto?
          elseif currentMapCategory == "NAVAL_ISLANDS" then allowedMoveTypes = { NAVAL = true, AIR = true } -- Nota: Manca LAND/VEHICLE/BUILDING qui?
          elseif currentMapCategory == "SPACE" then allowedMoveTypes = { AIR = true, SPACE = true } -- Nota: Manca BUILDING?
          elseif currentMapCategory == "NAVAL_PURE" then allowedMoveTypes = { NAVAL = true } -- Nota: Manca BUILDING?
          else allowedMoveTypes = { LAND = true, AIR = true, VEHICLE = true } -- Default conservativo
          end

          local idleUnitsForNewGroup = {}
          local currentIdleCount = 0
          for unitID, unitData in pairs(data.combatUnits) do
              if Spring.ValidUnitID(unitID) and not unitData.groupID and unitData.state == "idle" then
                 -- Verifica se unitData ha moveType prima di indicizzare allowedMoveTypes
                 local moveType = unitData.moveType 
                 if moveType and allowedMoveTypes[moveType] then -- Controlla se moveType esiste E se è permesso
                    local cmds = Spring.GetUnitCommands(unitID)
                    if not cmds or #cmds == 0 then
                        table.insert(idleUnitsForNewGroup, unitID)
                        currentIdleCount = currentIdleCount + 1
                    end
                 -- else Log(teamID,"LOG_DETAILED ManageMilitary: Unit "..unitID.." moveType '"..tostring(moveType).."' not allowed or missing.")
                 end
              end
          end

          if currentIdleCount >= config.attackGroup.min then
              Log(teamID,"ManageMilitary: Have "..currentIdleCount.." idle units. Min for group is "..config.attackGroup.min..". Forming new group.")
              local groupSize = math.min(currentIdleCount, config.attackGroup.max) 
              local newGroupUnits = {}
              for i = 1, groupSize do
                  table.insert(newGroupUnits, table.remove(idleUnitsForNewGroup, 1)) 
              end
              -- Assicurati che CreateNewCombatGroup analizzi le capacità L/A/N
              CreateNewCombatGroup(teamID, data, newGroupUnits, frame) 
          end
      else 
         Log(teamID, "ManageMilitary: No attackGroup config found, cannot form new groups.") 
      end

      -- 6. ASSEGNA TASK AI GRUPPI IDLE
      local groupsProcessedThisFrame = 0
      local maxGroupsToAssignPerFrame = 3 

      for groupID, groupData in pairs(data.combatGroups) do
          -- Solo gruppi VERAMENTE idle (non appena creati, ma che hanno finito un task o sono stati resettati)
          if groupData.state == "idle" then 
              Log(teamID, "ManageMilitary: Group " .. groupID .. " is idle. Assigning new task.")
              AssignTaskToGroup(teamID, data, groupID, frame) -- Questa ora prioritizza hotspot urgenti
              groupsProcessedThisFrame = groupsProcessedThisFrame + 1
              if groupsProcessedThisFrame >= maxGroupsToAssignPerFrame then
                 Log(teamID, "ManageMilitary: Reached group assignment limit for this frame ("..maxGroupsToAssignPerFrame..").") 
                 break 
              end
          end
      end

  end -- Fine ManageMilitary
  
  
  
 
 
 
 

  -- Helper: Trova costruttore idle di tier minimo
  function FindIdleConstructorForTeam(teamData, minTier)
      minTier = minTier or 0
      local foundBuilderID = nil
      for builderID, builderData in pairs(teamData.constructors) do
          if Spring.ValidUnitID(builderID) and builderData.tier >= minTier then
              local commands = Spring.GetUnitCommands(builderID)
              if (not commands or #commands == 0) then
                  foundBuilderID = builderID
                  break
              end
          end
      end
      return foundBuilderID
  end

  -- Helper: Controlla se servono costruttori T[N]
  function TeamNeedsConstructor(teamData, tier)
      local count = 0
      for unitID, builderData in pairs(teamData.constructors) do
          if Spring.ValidUnitID(unitID) and builderData.tier == tier then
              count = count + 1
          end
      end
      local limit = (tier == 0) and 1 or 2
      return count < limit
  end

  -- Helper: Controlla se l'AI può permettersi un'unità (v8 - Bypass T1 Eco Deficit a T0)
  function CanAffordUnit(teamData, unitDefID, frame)
      if not unitDefID then return false end
      local uDef = UnitDefs[unitDefID]
      if not uDef then return false end

      local costMetal = uDef.metalCost or 0
      local costEnergy = uDef.energyCost or 0
      local maintenanceEnergy = uDef.energyUpkeep or 0 -- == energyUse per molti edifici
      local makesEnergy = uDef.energyMake or 0

      local res = teamData.resourceInfo

      if type(res.metal) ~= "number" or type(res.energy) ~= "number" then return false end

      local buffer = 50
      local hasStorage = (res.metal >= costMetal + buffer and
                          res.energy >= costEnergy + buffer)

      if not hasStorage then
          -- Log(teamData.teamID,"Cannot afford "..uDef.humanName..": Storage Low")
          return false
      end

      -- === Bypass per T1 Eco a Tech Level 0 ===
      local isT1EcoBuilding = false
      local t1ExtractorData = GetUnitDataByRole(teamData.faction, 1, "T1_Extractor")
      local t1PowerData = GetUnitDataByRole(teamData.faction, 1, "T1_PowerPlant")
      if (t1ExtractorData and unitDefID == t1ExtractorData.id) or (t1PowerData and unitDefID == t1PowerData.id) then
          isT1EcoBuilding = true
      end

      if teamData.techLevel == 0 and isT1EcoBuilding then
          -- Log(teamData.teamID,"CanAffordUnit: Allowing T1 Eco building at T0 based on storage only.")
          return true -- Permetti costruzione T1 Eco a T0 se c'è storage
      end
      -- ========================================

      -- Per T1+ O unità non-T1-Eco, applica controllo bilancio energetico
      if teamData.techLevel >= 1 or not isT1EcoBuilding then
          local currentEnergyIncome = res.energyIncome or 0
          local currentEnergyUsage = res.energyUsage or 0
          local futureEnergyBalance = currentEnergyIncome - currentEnergyUsage - maintenanceEnergy

          if futureEnergyBalance < 0 then
              if makesEnergy > 0 then -- Ok per centrali
              else
                  local isSurplusNow = currentEnergyIncome > currentEnergyUsage
                  -- Riduciamo la soglia storage richiesta per procedere in deficit
                  local hasEnoughStorageForDeficit = res.energy > costEnergy * 1.5 -- Usa 1.5x invece di 5x

                  if not (isSurplusNow or hasEnoughStorageForDeficit) then
                     -- Log(teamData.teamID,"Cannot afford "..uDef.humanName..": Would cause UNMANAGEABLE energy deficit")
                     return false
                  -- else
                     -- Log(teamData.teamID,"Warning: Building "..uDef.humanName.." might cause manageable energy deficit, proceeding")
                  end
              end
          end
      end

      return true
  end

  --------------------------------------------------------------------------------
  -- GADGET EVENT HANDLERS (SYNCED)
  --------------------------------------------------------------------------------

  function gadget:Initialize()
      Log(nil, gadget:GetInfo().name .. " Initializing...")
      
      -- Assicurati che UnitDefNames sia disponibile
      if not UnitDefNames then
          Log(nil, "ERROR Initialize: UnitDefNames global table is not available! Cannot populate IDs.")
          return
      end

      for factionKey, factionSourceData in pairs(factionUnits) do
          -- Processa solo le tabelle che sono fazioni effettive, 
          -- e non la chiave _unitDefIDs che potrebbe essere a livello radice se si sbaglia struttura.
          if type(factionSourceData) == "table" and factionKey ~= "_unitDefIDs" then
              Log(nil, "Initialize: Starting population for faction: " .. factionKey)
              
              -- Assicurati che la tabella _unitDefIDs esista per questa fazione
              -- e che sia una tabella vuota pronta per essere popolata.
              -- factionSourceData qui è factionUnits[factionKey] (es. factionUnits.ICU)
              if not factionSourceData._unitDefIDs then
                  factionSourceData._unitDefIDs = {}
                  Log(nil, "Initialize: Created _unitDefIDs table for faction: " .. factionKey)
              else
                  -- Svuota se per caso contenesse dati vecchi (opzionale, ma più sicuro)
                  factionSourceData._unitDefIDs = {} 
                  Log(nil, "Initialize: Cleared existing _unitDefIDs table for faction: " .. factionKey)
              end
              
              -- Chiama la funzione passando la tabella DATI della fazione (es. factionUnits.ICU)
              -- e la tabella _unitDefIDs VUOTA di quella fazione dove verranno scritti i risultati.
              PopulateUnitDefIDs(factionSourceData, factionSourceData._unitDefIDs, "factionUnits." .. factionKey)
          else
              Log(nil, "Initialize: Skipping key '"..tostring(factionKey).."' in factionUnits (not a table or is '_unitDefIDs').")
          end
      end
      Log(nil, "UnitDefID population complete.")
  end

  function gadget:GameStart()
      Log(nil, gadget:GetInfo().name .. " Game Starting...")
      local mapNameRaw = Game.mapName
      local mapNameLower = mapNameRaw:lower()
      Log(nil, "Detected Map: '" .. mapNameRaw .. "' (Checking as: '" .. mapNameLower .. "')")
      if mapCategories[mapNameLower] then
          currentMapCategory = mapCategories[mapNameLower]
          Log(nil, "Map Category Assigned: '" .. currentMapCategory .. "' (Found in mapCategories table)")
      else
          Log(nil, "Map Category Assigned: '" .. currentMapCategory .. "' (Map not found in list, using default)")
      end
      local teams = Spring.GetTeamList()
      for _, teamID in ipairs(teams) do
          if Spring.GetTeamLuaAI(teamID) == gadget:GetInfo().name then
              Log(teamID, "Team detected for AI control.")
              local startX, startY, startZ = Spring.GetTeamStartPosition(teamID)
              teamData[teamID] = {

                  teamID = teamID, initialized = true, faction = nil, techLevel = 0,
                  commanderInfo = nil, startPos = { x = startX, y = startY, z = startZ },
                  constructors = {}, factories = {}, combatUnits = {}, buildings = {}, missions = {},
                  resourceInfo = { lastUpdateFrame = -100 },
                  economyObjectives = {}, -- Aggiunto per obiettivi random
                  -- === NUOVE CHIAVI PER GRUPPI E PATTUGLIAMENTO ===
                  combatGroups = {},
                  patrolPoints = {},
                  nextPatrolPointIndex = 1,
                  nextGroupID = 1,
                  regeneratePatrolPoints = true, -- Forza la generazione al primo avvio
                  -- === NUOVE CHIAVI PER HOTSPOT ===
                  hotspots = {},          -- Tabella per gli hotspot (ID hotspot -> dati hotspot)
                  nextHotspotID = 1,    -- Contatore per ID hotspot unici
                  HasFactoryOfTier = TeamHasFactoryOfTier,
                  FindIdleConstructor = FindIdleConstructorForTeam,
                  NeedsConstructor = TeamNeedsConstructor,
                  FindGoodFactoryPos = FindGoodFactoryPosForTeam,
                  CanAfford = CanAffordUnit,
                  FindBestMetalSpot = FindBestMetalSpotForTeam,
                  FindGoodEnergySpot = FindGoodEnergySpotForTeam,
                  NeedsBasicEconomy = function(self)
                        local mexCount=0; local powCount=0
                        local mexData = GetUnitDataByRole(self.faction, 1, "T1_Extractor")
                        local powData = GetUnitDataByRole(self.faction, 1, "T1_PowerPlant")
                        if mexData then mexCount = #Spring.GetTeamUnitsByDefs(self.teamID, mexData.id) end
                        if powData then powCount = #Spring.GetTeamUnitsByDefs(self.teamID, powData.id) end
                        local cfg = aiConfig[self.techLevel]
                        local needsMex = false; local needsPow = false
                        if cfg and cfg.economyTargets then
                           for _,t in ipairs(cfg.economyTargets) do
                              if t.role == "T1_Extractor" then needsMex = (mexCount < t.min); break end
                           end
                           for _,t in ipairs(cfg.economyTargets) do
                              if t.role == "T1_PowerPlant" then needsPow = (powCount < t.min); break end
                           end
                        end
                        return needsMex or needsPow
                  end,
              }
              CheckTeamCommander(teamID)
			  GeneratePatrolPoints(teamID, teamData[teamID]) -- <<< CHIAMATA QUI
          end
      end
      gameStarted = true
      Log(nil, gadget:GetInfo().name .. " Game Started. Final Map Category: " .. currentMapCategory)
  end

  function gadget:GameFrame(frame)
    if not gameStarted then return end
    for teamID, data in pairs(teamData) do
      if data.initialized and data.faction and data.faction ~= "UNKNOWN" then
        if frame % 150 == (teamID * 15) % 150 then
            Log(teamID, "Current State - TechLevel: " .. data.techLevel .. " | Map: " .. currentMapCategory)
        end
        UpdateResourceInfo(teamID, frame)
        if frame % 45 == (teamID * 3) % 45 then ManageTechLevel(teamID, frame) end
        if frame % 61 == (teamID * 5) % 61 then ManageEconomy(teamID, frame) end
        if frame % 91 == (teamID * 7) % 91 then ManageProduction(teamID, frame) end
		-- Dentro gadget:GameFrame, nel ciclo for teamID, data in pairs(teamData) do
		if frame % 151 == (teamID * 11) % 151 then -- Ogni ~5 secondi (151 è un primo per desincronizzare)
			DecayHotspots(teamID, data, frame)
		end
        if frame % 121 == (teamID * 9) % 121 then ManageMilitary(teamID, frame) end
      elseif data.initialized and not data.faction then
          if frame % 30 == 5 then CheckTeamCommander(teamID) end
      end
    end
  end

  function gadget:UnitFinished(unitID, unitDefID, unitTeam)
    if teamData[unitTeam] then
      local data = teamData[unitTeam]
      if not data.faction then return end
      local unitDef = UnitDefs[unitDefID]
      local faction = data.faction
      local foundType = nil; local unitData = nil;
      for tier = 1, 3 do
          local tierKey = "T"..tier
          local tierDefs = factionUnits[faction]._unitDefIDs[tierKey]
          if tierDefs then
              if tierDefs.constructor and unitDefID == tierDefs.constructor.id then unitData=tierDefs.constructor;data.constructors[unitID] = { tier = tier, state = "idle", task = nil, moveType=unitData.moveType }; foundType = "Con "..tierKey; break end
              if tierDefs.factory and unitDefID == tierDefs.factory.id then unitData=tierDefs.factory;data.factories[unitID] = { tier = tier, producing = nil, moveType=unitData.moveType }; foundType = "Fac "..tierKey; break end
              if tierDefs.extractor and unitDefID == tierDefs.extractor.id then unitData=tierDefs.extractor;data.buildings[unitID] = { tier = tier, type = "extractor", moveType=unitData.moveType }; foundType = "Ext "..tierKey; break end
              if tierDefs.powerPlant and unitDefID == tierDefs.powerPlant.id then unitData=tierDefs.powerPlant;data.buildings[unitID] = { tier = tier, type = "power", moveType=unitData.moveType }; foundType = "Pow "..tierKey; break end
              -- === NUOVE CONDIZIONI PER GLI STORAGE IN UNITFINISHED ===
              if tierDefs.estorage and unitDefID == tierDefs.estorage.id then unitData=tierDefs.estorage; data.buildings[unitID] = { tier = tier, type = "estorage", moveType=unitData.moveType }; foundType = "ESto "..tierKey; break end
              if tierDefs.mstorage and unitDefID == tierDefs.mstorage.id then unitData=tierDefs.mstorage; data.buildings[unitID] = { tier = tier, type = "mstorage", moveType=unitData.moveType }; foundType = "MSto "..tierKey; break end
              -- ======================================================			  
              if tierDefs.attackers then for _, d in ipairs(tierDefs.attackers) do if unitDefID == d.id then unitData=d; data.combatUnits[unitID] = { tier = tier, type = "attacker", group = nil, state = "idle", moveType=unitData.moveType }; foundType = "Atk "..tierKey; break end end; if foundType then break end end
              if tierDefs.defenses then for _, d in ipairs(tierDefs.defenses) do if unitDefID == d.id then unitData=d; data.buildings[unitID] = { tier = tier, type = "defense", moveType=unitData.moveType }; foundType = "Def "..tierKey; break end end; if foundType then break end end
          end
      end
      if foundType then Log(unitTeam, "UnitFinished: " .. unitID .. " (" .. (unitDef and unitDef.humanName or "N/A") .. ") - Categorized as: " .. foundType .." (MoveType: ".. (unitData and unitData.moveType or 'N/A') .. ")")
      else Log(unitTeam, "UnitFinished: " .. unitID .. " (" .. (unitDef and unitDef.humanName or "N/A") .. ") - Not categorized.") end
    end
  end

  function gadget:UnitDestroyed(unitID, unitDefID, unitTeam, ...) -- Aggiunto ... per argomenti extra
      if teamData[unitTeam] then
          local data = teamData[unitTeam]
          local uDef = UnitDefs[unitDefID]
          -- Log(unitTeam, "UnitDestroyed: " .. unitID .. " ("..(uDef and uDef.humanName or "Unknown")..")")

          if data.constructors[unitID] then data.constructors[unitID] = nil
          elseif data.factories[unitID] then data.factories[unitID] = nil
          elseif data.combatUnits[unitID] then
              -- Se era in un gruppo, verrà rimosso da UpdateCombatGroupStates.
              -- Qui semplicemente lo togliamo dalla lista generale.
              data.combatUnits[unitID] = nil
          elseif data.buildings[unitID] then data.buildings[unitID] = nil
          end

          -- Rimuovi unità dai gruppi se distrutta (UpdateCombatGroupStates lo fa già,
          -- ma una doppia verifica non fa male o si può fare qui se preferisci)
          -- for groupID, groupData in pairs(data.combatGroups or {}) do
          --     local newUnitsInGroup = {}
          --     local unitWasInThisGroup = false
          --     for _, idInGroup in ipairs(groupData.units) do
          --         if idInGroup ~= unitID then
          --             table.insert(newUnitsInGroup, idInGroup)
          --         else
          --             unitWasInThisGroup = true
          --         end
          --     end
          --     if unitWasInThisGroup then
          --         groupData.units = newUnitsInGroup
          --         Log(unitTeam, "Removed unit "..unitID.." from group "..groupID.." upon destruction.")
          --         if #groupData.units == 0 then
          --             Log(unitTeam, "Group "..groupID.." became empty after unit destruction, removing group.")
          --             data.combatGroups[groupID] = nil
          --         end
          --     end
          -- end
      end
  end

  function gadget:Shutdown()
    Log(nil, gadget:GetInfo().name .. " Shutting down.")
  end

end -- SYNCED CODE END


-- UNSYNCED CODE (Debug Visivo e Comando Console)
if (not gadgetHandler:IsSyncedCode()) then
    local function DrawFactionAndTech(teamID, data)
      local x, y, z = Spring.GetTeamStartPosition(teamID)
      if x and data.faction then
         gl.Text(data.faction .. " (T" .. data.techLevel .. ")", x, y+60, 15, "co")
      end
    end

    function gadget:DrawWorld()
      if SYNCED and SYNCED.WMRTSAI_Debug_Mode and SYNCED.WMRTSAI_Debug_Mode > 0 and type(SYNCED.teamData) == "table" then
        for teamID, data in pairs(SYNCED.teamData) do
           if data and data.initialized then
              DrawFactionAndTech(teamID, data)
           end
        end
        gl.Color(1,1,1,1)
      end
    end

    function gadget:DrawScreen(vsx, vsy)
       if SYNCED and SYNCED.WMRTSAI_Debug_Mode and SYNCED.WMRTSAI_Debug_Mode > 0 and SYNCED.currentMapCategory then
          gl.Text("Map Category: " .. SYNCED.currentMapCategory, vsx * 0.5, vsy - 30, 15, "co")
       end
    end

    local function ToggleDebug(cmd, line, words, player)
      local currentMode = 0
      if SYNCED and SYNCED.WMRTSAI_Debug_Mode then currentMode = SYNCED.WMRTSAI_Debug_Mode end
      local newMode = (currentMode == 0) and 1 or 0
      Spring.SendLuaRulesMsg("WMRTSAI_SetDebug " .. newMode)
      Spring.Echo("WMRTSAI Debug Mode set to: " .. newMode .. " (Command sent)")
      return true
    end

    function gadget:Initialize()
       gadgetHandler:AddChatAction("wmrtsai_debug", ToggleDebug, "Toggle WMRTSAI debug messages/drawing")
    end

    function gadget:RecvLuaMsg(msg, playerID)
      if msg:find("^WMRTSAI_SetDebug") then
          local _, levelStr = msg:match("([^ ]+)%s+(.*)")
          local level = tonumber(levelStr)
          if level ~= nil then
              if SYNCED then SYNCED.WMRTSAI_Debug_Mode = level end
          end
          return true
      end
      return false
    end
end -- FINE UNSYNCED