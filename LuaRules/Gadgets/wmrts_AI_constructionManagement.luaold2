function gadget:GetInfo()
	return {
		name      = "WMRTS Construction Manager",
		desc      = "Gestore costruzioni V1.8 - War Machines RTS",
		author    = "molix & AI",
		date      = "2025",
		license   = "GPL",
		layer     = 90,
		enabled   = true
	}
end

if (not gadgetHandler:IsSyncedCode()) then return end

--------------------------------------------------------------------------------
-- DATABASE CATEGORIE
--------------------------------------------------------------------------------

local CATEGORY_TO_UNIT = {
    ["ICU"] = {
        ["CAT_ENERGY_T1"]      = { "armsolar" },
        ["CAT_CONSTRUCTOR_T1"] = { "icucom", "icuck", "icucv" }, 
        ["CAT_FACTORY_T1"]     = { "armlab", "armvp" },
        ["CAT_LASER_T1"]       = { "armrl" },
        ["CAT_AA_T1"]          = { "armlightad" },
        ["CAT_MEX"]            = { "icumetex" },
    },
    ["AND"] = {
        ["CAT_ENERGY_T1"]      = { "andsolar" },
        ["CAT_CONSTRUCTOR_T1"] = { "andcom", "andcon" },
        ["CAT_FACTORY_T1"]     = { "andlab" },
        ["CAT_LASER_T1"]       = { "andlaser" },
        ["CAT_AA_T1"]          = { "andaa" },
        ["CAT_MEX"]            = { "andmex" },
    }
}

-- LIVELLI: Ricorda che count è il TOTALE di unità di quel tipo che l'AI vuole avere
local AI_BUILD_LEVELS = {
    [0] = {
        simultanea = 1,
        requisiti = {
            {cat = "CAT_CONSTRUCTOR_T1", count = 1}, 
            {cat = "CAT_MEX",            count = 1}, 
            {cat = "CAT_ENERGY_T1",      count = 1},
            {cat = "CAT_FACTORY_T1",     count = 1},
            {cat = "CAT_MEX",            count = 3}, -- Portato a 3 totali
            {cat = "CAT_ENERGY_T1",      count = 3}, -- Portato a 3 totali
        }
    }
}

--------------------------------------------------------------------------------
-- TABELLA MANUALE MAPPE
--------------------------------------------------------------------------------

local MANUAL_MAP_DATA = {
    ["Zoty Outpost"] = {
        {x = 664, z = 2360},
        {x = 2101, z = 2412},
        {x = 1320, z = 2312},		
    },

}
--------------------------------------------------------------------------------
-- SUPPORTO COSTRUZIONE (MIGLIORATO)
--------------------------------------------------------------------------------

local metalSpots = {}
local scanDone = false

local function AnalyzeMetalMap()
    metalSpots = {}
    local mapName = Game.mapName
    if MANUAL_MAP_DATA[mapName] then
        for _, spot in ipairs(MANUAL_MAP_DATA[mapName]) do table.insert(metalSpots, {x = spot.x, z = spot.z}) end
    else
        -- Scansione fallback se non in tabella
        local step = 16
        for z = 8, Game.mapSizeZ, step do
            for x = 8, Game.mapSizeX, step do
                if Spring.GetMetalAmount(x, z) > 0.1 then
                    local foundNear = false
                    for i=1, #metalSpots do
                        local dx, dz = x - metalSpots[i].x, z - metalSpots[i].z
                        if (dx*dx + dz*dz) < 150*150 then foundNear = true; break end
                    end
                    if not foundNear then table.insert(metalSpots, {x = x, z = z}) end
                end
            end
        end
    end
    scanDone = true
end

-- Conta unità FINITE (per il level up)
local function CountFinishedUnits(teamID, category, faction)
    local unitList = CATEGORY_TO_UNIT[faction][category]
    local total = 0
    for _, unitName in ipairs(unitList) do
        local uDef = UnitDefNames[unitName]
        if uDef then total = total + Spring.GetTeamUnitDefCount(teamID, uDef.id) end
    end
    return total
end

-- Conta unità TOTALI (Finite + Ordinate nei costruttori per evitare spam)
local function CountTotalPlannedUnits(teamID, category, faction)
    local unitList = CATEGORY_TO_UNIT[faction][category]
    local total = CountFinishedUnits(teamID, category, faction)
    
    -- Controlliamo i comandi in coda di tutti i costruttori
    local teamUnits = Spring.GetTeamUnits(teamID)
    for _, uID in ipairs(teamUnits) do
        local ud = UnitDefs[Spring.GetUnitDefID(uID)]
        if ud and ud.isBuilder then
            local queue = Spring.GetUnitCommands(uID, 5) -- Controlla i primi 5 ordini
            if queue then
                for _, cmd in ipairs(queue) do
                    for _, unitName in ipairs(unitList) do
                        local buildDefID = UnitDefNames[unitName].id
                        if cmd.id < 0 and (-cmd.id == buildDefID) then
                            total = total + 1
                        end
                    end
                end
            end
        end
    end
    return total
end

local function GetClosestMetalSpot(cx, cz)
    local bestSpot = nil
    local minDist = 4000 * 4000 
    for i = 1, #metalSpots do
        local spot = metalSpots[i]
        local dx, dz = cx - spot.x, cz - spot.z
        local distSq = dx*dx + dz*dz
        if distSq < minDist then
            local units = Spring.GetUnitsInSphere(spot.x, Spring.GetGroundHeight(spot.x, spot.z), spot.z, 64)
            local occupied = false
            for _, uID in ipairs(units) do
                local ud = UnitDefs[Spring.GetUnitDefID(uID)]
                if ud and ud.isExtractor then occupied = true; break end
            end
            if not occupied then minDist = distSq; bestSpot = spot end
        end
    end
    if bestSpot then return bestSpot.x, Spring.GetGroundHeight(bestSpot.x, bestSpot.z), bestSpot.z end
    return nil
end

local function FindGoodBuildSite(unitDefID, cx, cz)
    for _ = 1, 50 do 
        local angle = math.random() * math.pi * 2
        local dist = math.random(80, 350)
        local tx, tz = cx + math.cos(angle) * dist, cz + math.sin(angle) * dist
        if Spring.TestBuildOrder(unitDefID, tx, 0, tz, 0) == 2 then
            local _, ny, _ = Spring.GetGroundNormal(tx, tz)
            if ny > 0.9 then return tx, Spring.GetGroundHeight(tx, tz), tz end
        end
    end
    return nil
end

--------------------------------------------------------------------------------
-- GADGET CORE
--------------------------------------------------------------------------------

local aiTeamIDs = {}
local teamLevels = {}       
local teamFactions = {}     
local teamBasePos = {}      

function gadget:GameFrame(n)
    if n < 35 then return end 
    if not scanDone then AnalyzeMetalMap() end
    if (n % 150 ~= 0) then return end 

    local teamList = Spring.GetTeamList()
    for _, teamID in ipairs(teamList) do
        if not aiTeamIDs[teamID] then
            local aiName = Spring.GetTeamLuaAI(teamID)
            if aiName and string.find(string.lower(aiName), "ai") then
                aiTeamIDs[teamID] = true
                teamLevels[teamID] = 0
                local side = select(5, Spring.GetTeamInfo(teamID))
                teamFactions[teamID] = (side and string.find(string.lower(side), "and")) and "AND" or "ICU"
                if not GG.WMRTS_Levels then GG.WMRTS_Levels = {} end
                GG.WMRTS_Levels[teamID] = 0
            end
        end
    end

    for teamID, _ in pairs(aiTeamIDs) do
        local faction = teamFactions[teamID]
        local currentLvl = teamLevels[teamID]
        local config = AI_BUILD_LEVELS[currentLvl]
        if not config then return end

        if not teamBasePos[teamID] then
            local units = Spring.GetTeamUnits(teamID)
            if units and units[1] then
                local x,_,z = Spring.GetUnitPosition(units[1])
                teamBasePos[teamID] = {x=x, z=z}
            else return end
        end

        -- 1) LOGICA AVANZAMENTO LIVELLO (Solo se le unità sono FINITE)
        local levelComplete = true
        for _, req in ipairs(config.requisiti) do
            if CountFinishedUnits(teamID, req.cat, faction) < req.count then
                levelComplete = false
                break
            end
        end
        if levelComplete and AI_BUILD_LEVELS[currentLvl + 1] then
            teamLevels[teamID] = currentLvl + 1
            GG.WMRTS_Levels[teamID] = currentLvl + 1
            Spring.Echo("WMRTS AI: Team " .. teamID .. " sale al livello " .. teamLevels[teamID])
            return
        end

        -- 2) TROVA COSTRUTTORI LIBERI
        local builders = {}
        local teamUnits = Spring.GetTeamUnits(teamID)
        for _, uID in ipairs(teamUnits) do
            local ud = UnitDefs[Spring.GetUnitDefID(uID)]
            if ud and ud.isBuilder then
                local qSize = Spring.GetCommandQueue(uID, 0)
                -- Se non ha ordini o sta facendo assistenza, è libero per nuove costruzioni
                if qSize == 0 then table.insert(builders, uID) end
            end
        end

        -- 3) ASSEGNAZIONE ORDINI (Usa CountTotalPlannedUnits per evitare spam)
        local started = 0
        for _, req in ipairs(config.requisiti) do
            if started >= config.simultanea then break end
            
            -- Qui controlliamo anche se l'unità è in CODA di costruzione
            local pianificati = CountTotalPlannedUnits(teamID, req.cat, faction)
            
            if pianificati < req.count then
                local unitName = CATEGORY_TO_UNIT[faction][req.cat][1]
                local uDef = UnitDefNames[unitName]
                if uDef and #builders > 0 then
                    local bx, by, bz
                    if req.cat == "CAT_MEX" then
                        bx, by, bz = GetClosestMetalSpot(teamBasePos[teamID].x, teamBasePos[teamID].z)
                    else
                        bx, by, bz = FindGoodBuildSite(uDef.id, teamBasePos[teamID].x, teamBasePos[teamID].z)
                    end
                    if bx then
                        Spring.Echo("WMRTS AI: Team " .. teamID .. " ordina " .. unitName)
                        Spring.GiveOrderToUnit(builders[1], -uDef.id, {bx, by, bz, 0}, {})
                        table.remove(builders, 1)
                        started = started + 1
                        -- Non facciamo break qui, così se simultanea > 1 può dare più ordini
                    end
                end
            end
        end
    end
end