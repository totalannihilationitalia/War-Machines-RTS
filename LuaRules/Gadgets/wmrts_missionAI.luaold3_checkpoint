function gadget:GetInfo()
	return {
		name      = "WM Squad Commander AI (Custom DB Edition)",
		desc      = "AI con database unità personalizzato e targeting selettivo",
		author    = "molix",
		date      = "2025",
		license   = "GPL",
		layer     = 100,
		enabled   = true
	}
end

if (not gadgetHandler:IsSyncedCode()) then
	return false
end

--------------------------------------------------------------------------------
-- DATABASE UNITÀ 
--------------------------------------------------------------------------------
-- Qui puoi aggiungere campi extra in futuro (es. priority, armor_type, ecc.)
local UNIT_DB = {
	-- GROUND
	["icupatroller"]    = { type = "ground" }, -- enemyCat
	["icurock"]         = { type = "ground" },
	["mediumtank"]      = { type = "ground" },
	["artillerybot"]    = { type = "ground" },
	["icucom"]          = { type = "ground" },
	["icuraz"]          = { type = "ground" },	
	
	-- AIR
	["icuinterceptor"]  = { type = "air" },
	["euftransp"]       = { type = "air" },
	["armfig"]          = { type = "air" },
	
	-- NAVAL 
	["armbats"]         = { type = "naval" },
	["destroyer"]       = { type = "naval" },
	["armsy"]           = { type = "naval" },
	
	-- HOVER
	["andniko"]			= { type = "hover" },
}

--------------------------------------------------------------------------------
-- CONFIGURAZIONE SQUADRE (LISTE DI COSTRUZIONE)
--------------------------------------------------------------------------------

local SQUAD_TEMPLATES = {
	["light_patrol"] = {
		units = { "icupatroller", "icupatroller", "icurock", "icurock" },
		type = "ground" -- squadtype 
	},
	["heavy_assault"] = {
		units = { "mediumtank", "mediumtank", "artillerybot" }, 
		type = "ground"
	},
	["air_raid"] = { -- tutti gli aerei destinati ad attaccare tutto (ground, air, hovercraft e naval)
		units = { "armkam", "armthund", "armthund", "armkam", "armkam" },
		type = "air_toground"
	},
	["antiair_raid"] = { -- tutti gli aerei destinati ad attaccare solo aerei
		units = { "armfig", "armfig", "armfig" },
		type = "air_toair"
	},	
	["naval_fleet"] = {
		units = { "corbats", "corbats", "corbats" },
		type = "naval"
	}
}

-- CONFIGURAZIONE FABBRICHE, selezionare gli squad_templates (le liste di costruzione)
local FACTORY_CONFIG = {
	["armlab"] = { "light_patrol" },
	["armap"]  = { "antiair_raid", "air_raid" },
	["armsy"]  = { "naval_fleet" },
}

local TARGET_AI_NAME = "WarMachinesRTSmissionAI" 
local SQUAD_TIMEOUT_SECONDS = 600 -- questo timeout definisce il tempo di attesa per la formazione del gruppo delle unità uscite dalla fabbrica. Oltre questo timeout il gruppo di completa e parte all'attacco o difesa 

--------------------------------------------------------------------------------
-- VARIABILI
--------------------------------------------------------------------------------

local aiTeamIDs = {}      
local factories = {}      
local squads = {}         

--------------------------------------------------------------------------------
-- LOGICA DI TARGETING BASATA SU DATABASE
--------------------------------------------------------------------------------

-- Ottiene la categoria dal NOSTRO database
local function GetUnitCategoryFromDB(unitID)
	local uDefID = Spring.GetUnitDefID(unitID)
	if not uDefID then return "unknown" end
	local unitName = UnitDefs[uDefID].name
	
	if UNIT_DB[unitName] then
		return UNIT_DB[unitName].type
	end
	
	return "unknown" 
end

-- Funzione per trovare il bersaglio secondo le tue regole specifiche
local function GetSmartEnemyTarget(myTeamID, squadType)
	local allUnits = Spring.GetAllUnits()
	
	for i = 1, #allUnits do
		local uID = allUnits[i]
		local uTeam = Spring.GetUnitTeam(uID)
		
		if uTeam ~= Spring.GetGaiaTeamID() and not Spring.AreTeamsAllied(myTeamID, uTeam) then
			local enemyCat = GetUnitCategoryFromDB(uID)
			local x, y, z = Spring.GetUnitPosition(uID)
			
			if x then
				
				-- AEREI: 
				-- La tipologia air_toall Attacca tutto, inclusi gli hovercraft sempre #### IMPLEMENTARE
				if squadType == "air_toall" then
					if enemyCat == "air" or enemyCat == "ground" or enemyCat == "naval" or enemyCat == "hover" then
						return {x=x, y=y, z=z}
					end				
				-- La tipologia air_toground Attacca soltanto le unità in superficie		
				elseif squadType == "air_toground" then
					if enemyCat == "ground" or enemyCat == "naval" or enemyCat == "hover" then
						return {x=x, y=y, z=z}
					end
				-- La tipologia air_toair Attacca soltanto gli aerei
				elseif squadType == "air_toair" then
					if enemyCat == "air" then
						return {x=x, y=y, z=z}
					end
				-- TERRA: Attaccano ground, unknown e hover (solo se su terra)
				elseif squadType == "ground" then
					if enemyCat == "ground" or enemyCat == "unknown" then
						return {x=x, y=y, z=z}
					elseif enemyCat == "hover" and y >= 1 then -- 1 sopra il livello dell'acqua
						return {x=x, y=y, z=z}
					end

				-- NAVALI: Attaccano naval e hover (solo se in acqua)
				elseif squadType == "naval" then
					if enemyCat == "naval" then
						return {x=x, y=y, z=z}
					elseif enemyCat == "hover" and y < -1 then -- sotto il livello del mare
						return {x=x, y=y, z=z}
					end
				end
				----------------------------------------------------------------
			end
		end
	end
	
	return { x = Game.mapSizeX/2, y = 0, z = Game.mapSizeZ/2 }
end

--------------------------------------------------------------------------------
-- GESTIONE ORDINI E GADGET CORE 
--------------------------------------------------------------------------------

local function GiveAttackOrder(unitID, targetPos)
	if not targetPos then return end
	Spring.GiveOrderToUnit(unitID, CMD.STOP, {}, {})
	local tx = targetPos.x + math.random(-250, 250)
	local tz = targetPos.z + math.random(-250, 250)
	local ty = Spring.GetGroundHeight(tx, tz)
	Spring.GiveOrderToUnit(unitID, CMD.FIGHT, {tx, ty, tz}, {})
end

function gadget:Initialize()
	local teamList = Spring.GetTeamList()
	for _, teamID in ipairs(teamList) do
		local assignedAI = Spring.GetTeamLuaAI(teamID)
		if assignedAI and string.find(string.lower(assignedAI), string.lower(TARGET_AI_NAME)) then
			aiTeamIDs[teamID] = true
		end
	end
end

function gadget:UnitFinished(unitID, unitDefID, unitTeam)
	if not aiTeamIDs[unitTeam] then return end
	local unitName = UnitDefs[unitDefID].name

	if FACTORY_CONFIG[unitName] then
		factories[unitID] = { defName = unitName, squadID = nil, teamID = unitTeam }
		return
	end

	local bestFactoryID = nil
	local nearestDist = 3000
	for fID, fData in pairs(factories) do
		if fData.teamID == unitTeam then
			local dist = Spring.GetUnitSeparation(unitID, fID)
			if dist and dist < nearestDist then
				if fData.squadID and squads[fData.squadID] then
					nearestDist = dist
					bestFactoryID = fID
				end
			end
		end
	end

	if bestFactoryID then
		local fData = factories[bestFactoryID]
		local sID = fData.squadID
		local squad = squads[sID]
		table.insert(squad.units, unitID)
		
		if squad.state == "gathering" then
			local fX, _, fZ = Spring.GetUnitPosition(bestFactoryID)
			Spring.GiveOrderToUnit(unitID, CMD.MOVE, {fX + math.random(-300,300), 0, fZ + math.random(300,500)}, {"shift"})
		elseif squad.state == "attacking_monitor" then
			GiveAttackOrder(unitID, squad.attackTarget)
		end
	end
end

function gadget:GameFrame(n)
	if (n % 30 ~= 0) then return end 

	-- GESTIONE FABBRICHE
	for fID, fData in pairs(factories) do
		local qSize = Spring.GetCommandQueue(fID, 0)
		local isBuilding = Spring.GetUnitIsBuilding(fID)
		local isLocked = false
		
		if fData.squadID and squads[fData.squadID] then
			if (qSize > 0) or isBuilding or (squads[fData.squadID].state == "gathering") then
				isLocked = true
			else
				fData.squadID = nil
			end
		end

		if not isLocked and qSize == 0 and not isBuilding then
			local options = FACTORY_CONFIG[fData.defName]
			if options then
				local template = SQUAD_TEMPLATES[options[math.random(1, #options)]]
				if template then
					local newSquadID = n .. "_" .. fID
					squads[newSquadID] = {
						units = {},
						targetSize = #template.units,
						state = "gathering",
						startTime = Spring.GetGameSeconds(),
						myTeam = fData.teamID,
						attackTarget = nil,
						type = template.type 
					}
					fData.squadID = newSquadID
					for _, uName in ipairs(template.units) do
						local uDef = UnitDefNames[uName]
						if uDef then Spring.GiveOrderToUnit(fID, -uDef.id, {}, {}) end
					end
				end
			end
		end
	end

	-- GESTIONE SQUADRE
	for sID, sData in pairs(squads) do
		if sData.state == "gathering" then
			if #sData.units >= sData.targetSize or (Spring.GetGameSeconds() - sData.startTime) > SQUAD_TIMEOUT_SECONDS then
				sData.state = "attacking_monitor"
				sData.attackTarget = GetSmartEnemyTarget(sData.myTeam, sData.type)
				for _, uID in ipairs(sData.units) do
					if Spring.ValidUnitID(uID) then GiveAttackOrder(uID, sData.attackTarget) end
				end
			end
			
		elseif sData.state == "attacking_monitor" then
			if n % 90 == 0 then
				local anyAlive = false
				local anyIdle = false
				for i = #sData.units, 1, -1 do
					local uID = sData.units[i]
					if Spring.ValidUnitID(uID) and not Spring.GetUnitIsDead(uID) then
						anyAlive = true
						if Spring.GetCommandQueue(uID, 0) == 0 then anyIdle = true end
					else
						table.remove(sData.units, i)
					end
				end
				
				if anyAlive and anyIdle then
					sData.attackTarget = GetSmartEnemyTarget(sData.myTeam, sData.type)
					for _, uID in ipairs(sData.units) do
						if Spring.GetCommandQueue(uID, 0) == 0 then
							GiveAttackOrder(uID, sData.attackTarget)
						end
					end
				end
				if not anyAlive then squads[sID] = nil end
			end
		end
	end
end