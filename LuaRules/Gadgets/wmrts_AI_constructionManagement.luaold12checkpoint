	function gadget:GetInfo()
		return {
			name      = "WMRTS Construction Manager AI",
			desc      = "Gestore costruzioni V9 - War Machines RTS",
			author    = "molix & AI",
			date      = "2026",
			license   = "GPL",
			layer     = 90,
			enabled   = true
		}
	end
	-- 19/01/2026 = realizzato questo gadget, molix
	-- 28/01/2026 = implementata la logica introducendo il RESET LIVELLO. In questo modo quando certe strutture scendono sotto il limite, l'AI resetta il livello e parte da capo con le costruzioni, per prevenire lo stallo economico/tecnologico
	-- 29/01/2026 = le costruzioni vengono costruite ad una certa distanza dai giacimenti di metallo e dalle strutture già costruite per evitare sovrapposizioni
	-- 30/01/2026 = VER 8 implementando logica del pathfinding ( prima la distanza con cui sceglieva il giacimento di metallo più vicino era "in linea d'aria", ora stiamo cercando di implementare la lunghezza effettiva del pathfinding, se il giacimento più vicino è quello dall'altra parte del fiume, un mezzo a terra avrà comunque una distanza maggiore reale da percorrere per raggiungerlo.
	-- 02/02/2026 = VER 9 il pathfinding non sempre restituisce il valore reale della lunghezza. A volte il costruttore di terra, fà per attraversare un fiume per andare a costuire l'estrattore sul giacimento di metallo più vicino "in linea d'aria" e rimane comunque bloccato sulla sponda nell'intento di raggiungere l'altra per costurire il giacimento
	--				viene quindi implementato il timeout: se una unità appartenente al gruppo "LIMITED_CONSTRUCTORS" (solitamente costruttori di terra) rimane ferma per x tempo e non sta costruendo niente (come un comandante bloccato sulla sponda nel tentativo di raggiungere l'altra),
	--				a quel team ID viene messo nella blacklist lo spot di metallo irraggiungibile per le unità di terra. In questo modo l'unità riceve il comando STOP e rimane IDLE, cosi il sistema la impiega per altri lavori (o la ricerca di un nuovo spot di metallo)
	-- 02/02/2026 = inserita la funzione antistallo costruttivo: il builder x può costruire l'unità y?  se no -> interroga il builder successivo, se si -> impiegalo per costruirla. Se tutti i builder successivi non hanno la possibilità di costruirla, allora andrà in stallo. Ma basta tenere, per ogni livello, i builder T1 e T2 tra i requisiti.

	-- TO DO
	-- implementare naval e sub
	-- creare la categorizzazione land/air/sea per gli estrattori di metallo (logicamente land e air avranno lo stesso icumetex mentre sea avrà ad esempio undewatermetex). Vedere se fare lo stesso per le floating torrette T1 e T2 ed eventualmente le centrali energia.
	-- creare funzione upgrade estrattori da T1 a T2
	-- creare funzione comando ai costruttori (comandante, costruttori non comandante): Patrol/costruisci. La prima gira attorno alla base aiutando le costruizoni, la seconda per impegnare i costruttori a costruire
	-- ridurre il timeout nel caso i costruttori rimangano fermi per costruire giacimenti di metallo

	if (not gadgetHandler:IsSyncedCode()) then return end

	--------------------------------------------------------------------------------
	-- 1) DATABASE E CONFIGURAZIONE
	--------------------------------------------------------------------------------

	local MAP_PROFILES = {
		["Default"]      = { land = true, air = true, sea = false },		-- configurazione di default per le mappe senza profili mappa
	--    ["Zoty Outpost"] = { land = true, air = true, sea = false },		-- cancello perchè è come default
	}

	-- tabella per monitorare la posizione nel tempo delle unità indicate, serve alla logica per monitorare la posizione dei costruttori e individuare quelli che sono bloccati (perchè non raggiungono una posizione per la costruzione dell'estrattore di metallo)
	local LIMITED_CONSTRUCTORS = {
		-- ICU
		["icucom"] = true, ["icuck"] = true, ["armcv"] = true, ["armcs"] = true, ["kicucom"] = true,
		-- AND
		["andcom"] = true, ["andcon"] = true, ["andcv"] = true, ["andcs"] = true, -- ######################### sistemare la tabella AND
	}

	-- tabella dei comandanti, serve alla logica per capire quali sono i comandanti e controllarne il comportamento in funzione della variabile "combehaviour" in "local AI_BUILD_LEVELS"
	local COMMANDER_TABLE = {
		["ICU"] = { ["icucom"] = true, ["kicucom"] = true },
		["NFA"] = { ["nfacom"] = true, ["knfacom"] = true },
		["AND"] = { ["andcom"] = true }, -- aggiunto ipotetico kandcom
	}
	-- Tabella per la Blacklist degli spot (se una delle unità definite in LIMITED_CONSTRUCTORS rimarra bloccata nel tentativo di costruire un giacimento, metteremo quel giacimento nella blacklist)
	local blacklistedSpots = {} -- [teamID][spotIndex] = true

	-- Tabella per memorizzare la posizione delle unità definite in LIMITED_CONSTRUCTORS
	local builderTracker = {} -- Memorizza {lastX, lastZ, lastFrame, targetSpotIndex}

	-- categorizzazione delle unità
	local CATEGORY_TO_UNIT = {
	--	Puoi randomizzare le costruzioni scrivendo più unità per categoria es.: ["CAT_LASER_T1"] = { "armrl", "armllt", "armteeth" },
	--  Se vuoi che un'unità sia costruita più spesso di un'altra, puoi ripetere il nome nella lista es.: ["CAT_MEX_T1"] = { "mex_normale", "mex_normale", "mex_corazzato" } Qui l'AI avrà il 66% di probabilità di fare quello normale e il 33% di fare quello corazzato.
	--	Aggiungi la categoria che vuoi ["CAT_esempio_robotT3"] = = { "icuraz" }, -- Meglio se la categoria "CAT_esempio_robotT3" sia presente in tutte le fazioni. Usa poi la categoria nella "AI_BUILD_LEVELS"
	----------------------------
	-- ICU
	----------------------------
		["ICU"] = {
	-- categorie per le FUNZIONI - utilizzate nelle funzioni helper o nella logica CORE del gadget. ATTENZIONE, QUANDO SI MODIFICA UNA DI QUESTE CATEGORIE, VERIFICARE SEMPRE DOVE VIENE USATA NELLA LOGICA!!!!
			["CAT_ALL_CONSTRUCTORS"] 		= { "icucom", "icuck", "armcv", "armca", "armcs" }, 	-- categoria con tutti i costruttori (incluso il comandante), la uso al livello 0 per due motivi: 1) in caso di distruzione totale, quando l'AI torna a 0, se uno dei costruttori elencati è sopravvissuto, lo usa per ripartire con le costruzioni dal livello 0. 2) col game start, si parte col comandante, che è incluso nella lista. Soddisfa quindi il requisito del lvl 0.	
			["CAT_ALL_AIR_CONSTRUCTORS"] 	= { "armca", "armaca" }, 								-- categoria con tutti gli aerei costruttori, necessaria ad ignorare le unità indicate nella funzione per il calcolo del pathfinding durante la costruzione dell'estrattore più vicino. Vanno direttamente a costruire in quel punto x,y,z preferendo la "linea d'aria"
	-- categorie per le costruzioni
			["CAT_MEX_T1"]          = { "icumetex" },				-- estrattori T1			
			["CAT_MEX_T2"]          = { "armmoho","advmoho"	},		-- estrattori T2	
			["CAT_ENERGY_T1"]      	= { "armsolar" },				-- energyplant T1
			["CAT_ENERGY_T1_2"]    	= { "icuadvsol" },				-- energyplant T1/2		
			["CAT_ENERGY_T2"]      	= { "aafus", "armfus","armfus","armfus" },					-- energyplant T2, con più possibilità di realizzare armfus
			["CAT_ESTORAGE_T1"]		= { "icuestor" },				-- storage Energy T1
			["CAT_MSTORAGE_T1"]		= { "armmstor" },				-- storage Metal T1		
			["CAT_LASER_T1"]       	= { "iculighlturr" },
			["CAT_LASER_T1_2"]      = { "armhlt" },		
			["CAT_LASER_T2"]      	= { "armanni" },			
			["CAT_AA_T1"]          	= { "armrl" },
			["CAT_AA_T1_2"]         = { "packo" },			
			["CAT_AA_T2"]          	= { "armflak" },		
			["CAT_FACTORY_T1"] = {									-- fabbrica T1 si categorizza per tipologia ( terra, aria o mare), in funzione dei MAP_PROFILES l'AI effettuerà una scelta
				land = { "armlab", "armvp" },						-- randomizza la fabbrica
				air  = { "armap" },
				sea  = { "armsy" },
			},
			["CAT_FACTORY_T2"] = {
				land = { "armalab", "armavp" },
				air  = { "armaap" },
				sea  = { "armasy" },
			},		

			["CAT_CONSTRUCTORS_T1"]		= { "icuck", "armcv", "armca", "armcs" }, 				-- solo costruttori T1
			["CAT_CONSTRUCTORS_T2"] 	= { "icuack", "armacv", "armaca", "armacs" }, 			-- solo costruttori T2	
		},
	----------------------------
	-- AND
	----------------------------
		["AND"] = {
			["CAT_MEX_T1"]      	= { "andmex" },
			["CAT_ENERGY_T1"]     	= { "andsolar" },
			["CAT_LASER_T1"]   		= { "andlaser" },
			["CAT_AA_T1"]          	= { "andaa" },
			["CAT_FACTORY_T1"] = {
				land = { "andlab", "andhp" },
				air  = { "andplat" },
				sea  = { "andplat" },
			},
			["CAT_ALL_CONSTRUCTORS"] = { "andcom", "andcon", "andcv", "andca", "andcs" },
		}
	}

	local AI_BUILD_LEVELS = {
	-- il numero [0] o [1] rappresenta il livello della AI. L'AI parte sempre dal livello 0. Per ogni livello vengono specificate quante unità devono essere costruite. l'AI sale di livello una volta che ha completato tutte le unità di quel livello. Se vengono distrutte le unità, e i requisiti di un livello non vengono rispettati, l'AI scende di livello per "recuperare" i requisiti che lo soddisfano.
	-- REMINDER: ogni volta che si aggiunge o toglie il livello a questo gadget, aggiornare anche i livelli in wmrts_AI_militaryMenagement.lua !!!!!!!
	-- "cat=" rappresenta quali unità  di categoria l'AI deve costruire in quel determinato livello. Le categorie sono definite sopra e si possono aggiungere a piacimento (a patto che sia presente in tutte le fazioni)
	-- "count=" rappresenta la variabile ASSOLUTA di quante unità della categoria corrispondente devono essere attive in quel dato livello
	-- "combehaviour=" è il comportamento del comandante in quello specifico livello. può essere
	--			= constructor, 		ossia si comporta come un costruttore che costruisce delle building, importante ad esempio nei primi livelli
	--			= patrolbase,		ossia esegue un patrol intorno al centro della base, cosi da aiutare le costruzioni.
		[0] = { 												-- livello di partenza. può diventare anche livello di RESET LIVELLO AI quando subisce pesanti attacchi (vedere sotto logica di RESET LIVELLO). E' importante che vi siano, in questo livello, le costruzioni che, in loro assenza/mancato numero (definito dalla logica di "RESET LIVELLO") resettino l'AI, altrimenti si entra in un LOOP infinito di salto livello (0 -> 1 e torna subito a 0)
			simultanea = 1,
			combehaviour = "constructor",
			requisiti = {
				{cat = "CAT_ALL_CONSTRUCTORS", 	count = 1}, 	-- al livello 0 ne deve avere almeno 1 in totale. In fase di start skirmish è il comandante. In caso di restart AI, può essere qualunque costruttore, se presente. Ecco il motivo per cui metto la categoria "CAT_ALL_CONSTRUCTORS"
				{cat = "CAT_ENERGY_T1",         count = 1},		-- importanti per la logica RESET LIVELLO !! estrattori T1, energia T1 e fabbrica T1 devono essere inclusi in questo livello per andare al successivo, altrimenti la logica del core entra in loop
				{cat = "CAT_MEX_T1",            count = 1},		-- importanti per la logica RESET LIVELLO !! estrattori T1, energia T1 e fabbrica T1 devono essere inclusi in questo livello per andare al successivo, altrimenti la logica del core entra in loop
				{cat = "CAT_ENERGY_T1",         count = 2},		-- importanti per la logica RESET LIVELLO !! estrattori T1, energia T1 e fabbrica T1 devono essere inclusi in questo livello per andare al successivo, altrimenti la logica del core entra in loop			
				{cat = "CAT_MEX_T1",            count = 3}, 
				{cat = "CAT_ENERGY_T1",         count = 3},		
				{cat = "CAT_FACTORY_T1",        count = 1}, 	
			} 	-- end requisiti di livello
		},		-- end livello  [n]
		[1] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 2,
			combehaviour = "constructor",		
			requisiti = {
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 1},
				{cat = "CAT_LASER_T1", 			count = 1},		
				{cat = "CAT_AA_T1", 			count = 1},					
				{cat = "CAT_MEX_T1",            count = 4},
				{cat = "CAT_ENERGY_T1",         count = 5},		
			} 	-- end requisiti di livello
		},		-- end livello  [n]
		[2] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 2,
			combehaviour = "constructor",		
			requisiti = {		
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 1},		
				{cat = "CAT_ENERGY_T1",         count = 5},			
				{cat = "CAT_ENERGY_T1_2",       count = 1},
				{cat = "CAT_FACTORY_T1", 		count = 2},
	--            {cat = "CAT_MEX_T1",            count = 4},
				{cat = "CAT_LASER_T1", 			count = 1},		
				{cat = "CAT_AA_T1", 			count = 1},			
			} 	-- end requisiti di livello
		},		-- end livello  [n]	
		[3] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 2,
			combehaviour = "patrolbase",		
			requisiti = {
				{cat = "CAT_ENERGY_T1",         count = 5},		
				{cat = "CAT_MEX_T1",            count = 4},		
				{cat = "CAT_FACTORY_T1", 		count = 2},			
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_ENERGY_T1_2",       count = 2},
				{cat = "CAT_AA_T1_2", 			count = 1},					
				{cat = "CAT_LASER_T1_2", 		count = 1},				
			} 	-- end requisiti di livello
		},		-- end livello  [n]	
		[4] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 2,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_ENERGY_T1",         count = 5},		
				{cat = "CAT_MEX_T1",            count = 5},		
				{cat = "CAT_FACTORY_T1", 		count = 2},			
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_ENERGY_T1_2",       count = 4},
				{cat = "CAT_FACTORY_T2", 		count = 1},		
			} 	-- end requisiti di livello
		},		-- end livello  [n]		
		[5] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 4,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_FACTORY_T2", 		count = 1},		
				{cat = "CAT_FACTORY_T1", 		count = 1},	
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_CONSTRUCTORS_T2", 	count = 2},			
				{cat = "CAT_ENERGY_T1_2",       count = 4},
				{cat = "CAT_MEX_T1",            count = 5},		
				{cat = "CAT_AA_T1_2", 			count = 2},					
				{cat = "CAT_LASER_T1_2", 		count = 2},							
			} 	-- end requisiti di livello
		},		-- end livello  [n]		
		[6] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 4,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_FACTORY_T2", 		count = 2},		
				{cat = "CAT_FACTORY_T1", 		count = 1},	
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_CONSTRUCTORS_T2", 	count = 2},			
				{cat = "CAT_ENERGY_T1_2",       count = 4},
				{cat = "CAT_MEX_T2",            count = 1},					
				{cat = "CAT_MEX_T1",            count = 3},		
			} 	-- end requisiti di livello
		},		-- end livello  [n]			
		[7] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 4,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_FACTORY_T2", 		count = 2},		
				{cat = "CAT_FACTORY_T1", 		count = 1},	
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_CONSTRUCTORS_T2", 	count = 2},			
				{cat = "CAT_ENERGY_T1_2",       count = 4},
				{cat = "CAT_MEX_T2",            count = 2},					
				{cat = "CAT_MEX_T1",            count = 2},		
				{cat = "CAT_ENERGY_T2",         count = 1},		
				{cat = "CAT_AA_T2", 			count = 1},					
				{cat = "CAT_LASER_T2", 			count = 1},							
			} 	-- end requisiti di livello
		},		-- end livello  [n]			
		[8] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 4,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_FACTORY_T2", 		count = 3},		
				{cat = "CAT_FACTORY_T1", 		count = 1},	
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_CONSTRUCTORS_T2", 	count = 2},			
				{cat = "CAT_MEX_T2",            count = 3},					
				{cat = "CAT_ENERGY_T2",         count = 2},				
			} 	-- end requisiti di livello
		},		-- end livello  [n]			
		[9] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 4,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_FACTORY_T2", 		count = 3},		
				{cat = "CAT_FACTORY_T1", 		count = 1},	
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_CONSTRUCTORS_T2", 	count = 2},			
				{cat = "CAT_MEX_T2",            count = 3},					
				{cat = "CAT_ENERGY_T2",         count = 2},				
			} 	-- end requisiti di livello
		},		-- end livello  [n]			
		[10] = {													-- reminder: aggiorna anche le costruzioni di livello corrispondente nel gadget military
			simultanea = 6,
			combehaviour = "patrolbase",			
			requisiti = {
				{cat = "CAT_CONSTRUCTORS_T1", 	count = 2},
				{cat = "CAT_CONSTRUCTORS_T2", 	count = 4},	
				{cat = "CAT_FACTORY_T2", 		count = 4},		
				{cat = "CAT_FACTORY_T1", 		count = 3},	
				{cat = "CAT_MEX_T2",            count = 4},					
				{cat = "CAT_ENERGY_T2",         count = 2},		
				{cat = "CAT_AA_T2", 			count = 3},					
				{cat = "CAT_LASER_T2", 			count = 3},				
			} 	-- end requisiti di livello
		}		-- end livello  [n]			
	}

	-- inserimento manuale degli spot di metallo per ogni mappa, utilizzare widget: WMRTS_Maker_exportMetal.lua (comando /exportmetal in chat)
	local MANUAL_MAP_DATA = {
		["Zoty Outpost"] = { {x = 2241, z = 675}, {x = 492, z = 1206}, {x = 1918, z = 1285}, {x = 844, z = 1942}, {x = 1328, z = 2341}, {x = 661, z = 2387}, {x = 2108, z = 2422} },
		["Eridlon Island"] = { {x = 10566, z = 1226}, {x = 10783, z = 1364}, {x = 5864, z = 1408}, {x = 10578, z = 1468}, {x = 5652, z = 1512}, {x = 5873, z = 1645}, {x = 9751, z = 1707}, {x = 7219, z = 1904}, {x = 6722, z = 2059}, {x = 7144, z = 2117}, {x = 6504, z = 2142}, {x = 3796, z = 2192}, {x = 4015, z = 2328}, {x = 10613, z = 2338}, {x = 3807, z = 2435}, {x = 10818, z = 2442}, {x = 10600, z = 2579}, {x = 6240, z = 2725}, {x = 6250, z = 2962}, {x = 5562, z = 3221}, {x = 5773, z = 3326}, {x = 5554, z = 3462}, {x = 9139, z = 3521}, {x = 9356, z = 3608}, {x = 11109, z = 3666}, {x = 8721, z = 3678}, {x = 9132, z = 3760}, {x = 8495, z = 3825}, {x = 11221, z = 3874}, {x = 8713, z = 3912}, {x = 10988, z = 3911}, {x = 4722, z = 3958}, {x = 3304, z = 3994}, {x = 4505, z = 4043}, {x = 3090, z = 4101}, {x = 8080, z = 4099}, {x = 4733, z = 4192}, {x = 3316, z = 4233}, {x = 7609, z = 4250}, {x = 7840, z = 4264}, {x = 8091, z = 4338}, {x = 4842, z = 4364}, {x = 11111, z = 4396}, {x = 11364, z = 4450}, {x = 5063, z = 4498}, {x = 4856, z = 4602}, {x = 11205, z = 4619}, {x = 10083, z = 4904}, {x = 7923, z = 4952}, {x = 9874, z = 5007}, {x = 7714, z = 5055}, {x = 7936, z = 5192}, {x = 3958, z = 6161}, {x = 3832, z = 6348}, {x = 4051, z = 6453}, {x = 9624, z = 6378}, {x = 4275, z = 6542}, {x = 9493, z = 6568}, {x = 9721, z = 6598}, {x = 4146, z = 6728}, {x = 6680, z = 7228}, {x = 6450, z = 7266}, {x = 10906, z = 7328}, {x = 6614, z = 7446}, {x = 11130, z = 7480}, {x = 10915, z = 7566}, {x = 5872, z = 7726}, {x = 6104, z = 7760}, {x = 9217, z = 8626}, {x = 9120, z = 8720}, {x = 9764, z = 8731}, {x = 9983, z = 8870}, {x = 9775, z = 8979}, {x = 3211, z = 9657}, {x = 3561, z = 9740}, {x = 3535, z = 9950}, {x = 4929, z = 10096}, {x = 5158, z = 10246}, {x = 4941, z = 10333}, {x = 8094, z = 10425}, {x = 9632, z = 10486}, {x = 8301, z = 10521}, {x = 2606, z = 10592}, {x = 9409, z = 10619}, {x = 9622, z = 10724} },
	}

	--------------------------------------------------------------------------------
	-- 2) VARIABILI DI STATO
	--------------------------------------------------------------------------------
	local aiTeamIDs = {}
	local teamLevels = {}       
	local teamFactions = {}     
	local teamBasePos = {}      
	local metalSpots = {}
	local scanDone = false
	local commanderCurrentBehaviour = {} -- comportamento del comandante

	--------------------------------------------------------------------------------
	-- 3) FUNZIONI DI SUPPORTO
	--------------------------------------------------------------------------------
	-- Questa funzione restituisce l'ID del Comandante se è vivo
	local function GetCommanderID(teamID, faction)
		local allowedComs = COMMANDER_TABLE[faction]
		if not allowedComs then return nil end

		local units = Spring.GetTeamUnits(teamID)
		for _, uID in ipairs(units) do
			local udID = Spring.GetUnitDefID(uID)
			local udName = UnitDefs[udID].name
			
			-- Controlla se il nome dell'unità è presente nella lista dei comandanti della fazione
			if allowedComs[udName] then
				return uID
			end
		end
		return nil
	end

	-- Questa funzione serve per costruire le fabbriche. Quando richiamata verifica dove posizionare la fabbrica in un punto lontano da giacimenti di metallo (per non imperdire la costruzione di estrattori) e lontano da "dirupi" per evitare che l'AI costruisca la fabbrica in un punto (come un dirupo, una montagna) da cui poi le unità non escono
	local function GetSafeBuildPosFactory(uDefID, basePos, metalSpots)
		for _ = 1, 50 do -- Più tentativi perché i criteri sono più stringenti
			local angle = math.random() * math.pi * 2
			local dist = math.random(200, 700) 
			local tx = basePos.x + math.cos(angle) * dist
			local tz = basePos.z + math.sin(angle) * dist
			local ty = Spring.GetGroundHeight(tx, tz)

			-- 1. Controllo Pendenza (Dirupi)
			-- Prendiamo la "normale" del terreno. 1.0 = perfettamente piatto.
			local nx, ny, nz = Spring.GetGroundNormal(tx, tz)
			
			-- Se ny < 0.92 il terreno è troppo inclinato per una fabbrica
			if ny > 0.92 then 
				
				-- 2. Controllo Metallo (Raggio generoso 200 per lasciare spazio di manovra)
				local tooCloseToMetal = false
				for _, spot in ipairs(metalSpots) do
					if (math.abs(tx - spot.x) < 200 and math.abs(tz - spot.z) < 200) then 
						tooCloseToMetal = true; break 
					end
				end

				if not tooCloseToMetal then
					-- 3. Controllo Spazio per Unità (Testiamo 4 punti cardinali attorno alla fabbrica)
					-- Serve a capire se le unità prodotte possono uscire o se sono circondate da montagne
					local testDist = 120 
					local points = {
						{tx + testDist, tz}, {tx - testDist, tz},
						{tx, tz + testDist}, {tx, tz - testDist}
					}
					
					local exitClear = true
					for _, p in ipairs(points) do
						-- Testiamo se un'unità generica (es. un tank) può stare in quei punti
						if Spring.TestBuildOrder(UnitDefNames["icuck"].id, p[1], Spring.GetGroundHeight(p[1], p[2]), p[2], 0) <= 0 then
							exitClear = false; break
						end
					end

					if exitClear then
						-- 4. Controllo finale: L'edificio ci sta fisicamente?
						if Spring.TestBuildOrder(uDefID, tx, ty, tz, 0) == 2 then
							return tx, ty, tz
						end
					end
				end
			end
		end
		return nil 
	end
	-- Questa funzione controlla se un'unità "x" può effettivamente costruire un'altra unità "y". Ad esempio verifica se "icucom" può costruire "icuadvsol", cosi che il core vada a chiamare il successivo builder per eseguire di nuovo questa verifica. Restituisce true se può costruire l'unità codi da ingaggiarla, oppure false cosi il core interroga il builder successivo
	local function CanBuilderBuildThis(builderID, unitDefID)
		local ud = UnitDefs[Spring.GetUnitDefID(builderID)]
		if not ud or not ud.buildOptions then return false end
		for _, optID in ipairs(ud.buildOptions) do
			if optID == unitDefID then return true end
		end
		return false
	end

	-- Questa funzione controlla se i costruttori sono bloccati.
	local function CheckStuckBuilders(teamID, frame)
		local units = Spring.GetTeamUnits(teamID)
		for _, uID in ipairs(units) do
			local udID = Spring.GetUnitDefID(uID)
			local udName = UnitDefs[udID].name
			
			if LIMITED_CONSTRUCTORS[udName] then         -- Controlliamo solo se fa parte della lista costruttore monitorato con un ordine di costruzione
				-- 1. Verifichiamo se l'unità sta effettivamente costruendo qualcosa
				-- Spring.GetUnitIsBuilding restituisce l'ID dell'edificio se sta "lavorando"
				local isBuildingSomething = Spring.GetUnitIsBuilding(uID)
				
				local cmd = Spring.GetUnitCommands(uID, 1)  -- Prendi il primo comando
				
				if isBuildingSomething then
					-- Se sta costruendo, NON è bloccata. Resettiamo il tracker e passiamo oltre.
					builderTracker[uID] = nil
				elseif cmd and #cmd > 0 and (cmd[1].id < 0) then -- cmd.id < 0 indica costruzione
					
					local tx, ty, tz = cmd[1].params[1], cmd[1].params[2], cmd[1].params[3]
					local curX, curY, curZ = Spring.GetUnitPosition(uID)
					local distToTarget = math.sqrt((tx-curX)^2 + (tz-curZ)^2) -- Calcola distanza dal target
					
					-- Se è ancora lontano dal target (più di 35 pixel)
					if distToTarget > 35 then
						local data = builderTracker[uID]
						
						if not data then
							builderTracker[uID] = {x = curX, z = curZ, frame = frame} -- Inizia il monitoraggio
						else
							if (frame - data.frame) > 450 then -- Per fare ad esempio 30 secondi -> (30 * 30 frames = 900)  	-- ########################### portato da 30 secondi a 15 secondi 02/02/2026
								local movedDist = math.sqrt((data.x - curX)^2 + (data.z - curZ)^2)
								
								-- Se non si è mosso (meno di 30 pixel) E non sta costruendo (già verificato sopra)
								if movedDist < 30 then
									Spring.Echo("WMRTS_contrMngm_AI: Team "..teamID.." - builder " .. udName .. " bloccato e NON sta costruendo! Blacklisto spot.") -- L'UNITA' E' BLOCCATA!
									
									for i, spot in ipairs(metalSpots) do -- Trova quale spot era (confrontando le coordinate tx, tz)
										if math.abs(spot.x - tx) < 10 and math.abs(spot.z - tz) < 10 then
											if not blacklistedSpots[teamID] then blacklistedSpots[teamID] = {} end
											blacklistedSpots[teamID][i] = true
											break
										end
									end
									
									--Spring.GiveOrderToUnit(uID, 16, {}, {}) 
									Spring.GiveOrderToUnit(uID, CMD.STOP, {}, {}) -- CMD.STOP -- Cancella ordine e resetta tracker
									builderTracker[uID] = nil
								else
									builderTracker[uID] = {x = curX, z = curZ, frame = frame} -- Si è mossa, aggiorna il tracker per il prossimo controllo
								end
							end
						end
					else
						-- È molto vicino al target, probabilmente sta per iniziare o ha finito
						builderTracker[uID] = nil
					end
				else
					-- Non ha ordini di costruzione, puliamo il tracker
					builderTracker[uID] = nil
				end
			end
		end
	end

	-- Misura la distanza reale sommando i segmenti del sentiero calcolato dal motore, dopo aver ricevuto l'ordine di costruzione
	local function GetRealDistAfterOrder(unitID)
		-- Spring.GetUnitEstimatedPath restituisce 2 tabelle, a noi serve la prima (waypoints)
		local waypoints = Spring.GetUnitEstimatedPath(unitID)
		
		if not waypoints or #waypoints == 0 then return -1 end
		
		local totalDist = 0
		local curX, curY, curZ = Spring.GetUnitPosition(unitID)
		
		for i = 1, #waypoints do
			local wp = waypoints[i]
			
			-- Il motore Spring usa indici numerici: [1]=x, [2]=y, [3]=z
			local wx = wp[1] or wp.x
			local wz = wp[3] or wp.z
			
			if wx and wz then
				local dx = wx - curX
				local dz = wz - curZ
				totalDist = totalDist + math.sqrt(dx*dx + dz*dz)
				
				-- Aggiorniamo la posizione corrente per il prossimo segmento
				curX = wx
				curZ = wz
			end
		end
		
		return totalDist
	end

	-- Questa funzione serve a non costruire gli edifici sopra un giacimento di metallo entro un raggio di 150, onde evitare di mandare in stallo l'AI
	local function GetSafeBuildPos(uDefID, basePos, metalSpots)
		for _ = 1, 40 do -- Proviamo 40 posizioni casuali
			local angle = math.random() * math.pi * 2
			local dist = math.random(150, 600)				-- Raggio di costruzione dalla base (min, max)
			local tx = basePos.x + math.cos(angle) * dist
			local tz = basePos.z + math.sin(angle) * dist
			local ty = Spring.GetGroundHeight(tx, tz)

			-- 1. Controllo: Non sopra un giacimento di metallo (Raggio 150)
			local tooCloseToMetal = false
			for _, spot in ipairs(metalSpots) do
				local dx, dz = tx - spot.x, tz - spot.z
				if (dx*dx + dz*dz) < (150*150) then tooCloseToMetal = true; break end
			end

			if not tooCloseToMetal then
				-- 2. Controllo: Spazio libero intorno (evita fabbriche ammassate)
				-- Cerchiamo unità in un raggio di 180 unità
				local blockingUnits = Spring.GetUnitsInSphere(tx, ty, tz, 180)	-- Raggio di costruzione interbuildings
				
				if #blockingUnits == 0 then
					-- 3. Controllo finale: Il terreno è edificabile?
					if Spring.TestBuildOrder(uDefID, tx, ty, tz, 0) == 2 then
						return tx, ty, tz
					end
				end
			end
		end
		return nil -- Nessuna posizione sicura trovata
	end

	-- Questa funzione serve a capire dove si trovano le risorse.
	--	•	Controlla se esistono coordinate predefinite per la mappa corrente in MANUAL_MAP_DATA.
	--	•	Se non ci sono, scansiona l'intera mappa con un salto di 32 pixel cercando punti dove il valore del metallo è superiore a 0.1.
	--	•	Salva le coordinate in una tabella metalSpots per usi futuri.
	local function AnalyzeMetalMap()
		metalSpots = {}
		local mapName = Game.mapName
		if MANUAL_MAP_DATA[mapName] then
			for _, spot in ipairs(MANUAL_MAP_DATA[mapName]) do table.insert(metalSpots, {x = spot.x, z = spot.z}) end
		else
			local step = 32
			for z = 16, Game.mapSizeZ, step do
				for x = 16, Game.mapSizeX, step do
					if Spring.GetMetalAmount(x, z) > 0.1 then
						table.insert(metalSpots, {x = x, z = z})
					end
				end
			end
		end
		scanDone = true
		Spring.Echo("WMRTS_contrMngm_AI: Metal scan complete (" .. #metalSpots .. " spots)")
	end

	-- funzione per rilevare il metalspot più vicino via pathfinding (se l'unità è di terra) o diretta, se l'unità è un aereo DICHIARATO NELLA CATEGORIA "CAT_ALL_AIR_CONSTRUCTORS" di ogni fazione
	local function GetClosestMetalSpot(cx, cz, builderID, faction, teamID)
		local bestSpot = nil
		local minDist = 1000000 * 1000000 
		
		local udID = Spring.GetUnitDefID(builderID)
		if not udID then return nil end
		local ud = UnitDefs[udID]
		local udName = ud.name 
		local isLimited = LIMITED_CONSTRUCTORS[udName] -- Determina se il builder è limitato

		-- Variabili per il Log
		local occupiedCount = 0
		local unreachableCount = 0
		local reachableCount = 0

		-- Controllo se l'unità appartiene alla categoria AIR della sua fazione
		local isAirConstructor = false
		local airList = CATEGORY_TO_UNIT[faction]["CAT_ALL_AIR_CONSTRUCTORS"]
		if airList then
			for _, name in ipairs(airList) do
				if name == udName then 
					isAirConstructor = true 
					break 
				end
			end
		end

		for i = 1, #metalSpots do
		
		-- CONTROLLO BLACKLIST: se l'unità è terra/mare e lo spot è blacklistato, saltalo
			if isLimited and blacklistedSpots[teamID] and blacklistedSpots[teamID][i] then
				-- Salta questo spot
			else
		
			local spot = metalSpots[i]
			local sx, sz = spot.x, spot.z
			local sy = Spring.GetGroundHeight(sx, sz)

			-- 1. Verifica occupazione
			local units = Spring.GetUnitsInSphere(sx, sy, sz, 64)
			local occupied = false
			for _, uID in ipairs(units) do
				local sud = UnitDefs[Spring.GetUnitDefID(uID)]
				if sud and sud.isExtractor then occupied = true; break end
			end

			if occupied then
				occupiedCount = occupiedCount + 1
			else
				local isReachable = false
				
				if isAirConstructor then
					-- Se è nella tua lista AIR, salta il pathfinding
					isReachable = true 
				else
					-- Altrimenti usa il pathfinding standard
					isReachable = Spring.TestMoveOrder(udID, cx, Spring.GetGroundHeight(cx, cz), cz, sx, sy, sz )
				end

				if isReachable then
					reachableCount = reachableCount + 1
					local dx, dz = cx - sx, cz - sz
					local distSq = dx*dx + dz*dz
					if distSq < minDist then
						minDist = distSq
						bestSpot = spot
					end
				else
					unreachableCount = unreachableCount + 1
				end
			end
		end
		end
		
		------ LOG DI ISPEZIONE ---
		local logType = isAirConstructor and "ARIA (Ignora Path)" or "TERRA/MARE (Pathfinding)"
		if bestSpot then
			local dLin = math.sqrt(minDist)
			Spring.Echo(string.format("WMRTS_contrMngm_AI: [%s] Team %d - %s: Spot TROVATO! x:%.0f z:%.0f | Dist. Linea Aria: %.0f", udName, teamID, logType, bestSpot.x, bestSpot.z, dLin))
		else
			Spring.Echo(string.format("WMRTS_contrMngm_AI: [%s] Team %d - %s: NESSUN SPOT DISPONIBILE!", udName, teamID, logType))
		end
		---------------------------
		if bestSpot then 
			return bestSpot.x, Spring.GetGroundHeight(bestSpot.x, bestSpot.z), bestSpot.z 
		end
		return nil
	end

	-- È il "contabile" dell'AI.
	--	•	Riceve la categoria (es. "CAT_MEX_T1") e la fazione.
	--	•	Usa Spring.GetTeamUnitDefCount per contare quante unità di quel tipo il team possiede già sulla mappa.
	--	•	Gestisce anche le categorie multi-tipo (es. le fabbriche che possono essere Land, Air o Sea).
	local function CountUnitsInCategory(teamID, category, faction)
		local entry = CATEGORY_TO_UNIT[faction][category]
		if not entry then return 0 end
		local total = 0
		local function c(list)
			for _, name in ipairs(list) do
				local ud = UnitDefNames[name]
				if ud then total = total + Spring.GetTeamUnitDefCount(teamID, ud.id) end
			end
		end
		if entry.land or entry.air or entry.sea then
			if entry.land then c(entry.land) end
			if entry.air then c(entry.air) end
			if entry.sea then c(entry.sea) end
		else c(entry) end
		return total
	end

	-- Sceglie quale unità specifica costruire all'interno di una categoria.
	--	•	Utilizza i MAP_PROFILES per decidere se la mappa permette unità di terra, aria o mare.
	--	•	Restituisce un nome di unità casuale tra quelle valide per quel profilo (es. se la mappa è solo terra, non sceglierà una fabbrica navale).
	local function GetRandomUnitFromCat(faction, category)
		local entry = CATEGORY_TO_UNIT[faction][category]
		if not entry then return nil end
		local profile = MAP_PROFILES[Game.mapName] or MAP_PROFILES["Default"]
		local valid = {}
		
		if entry.land or entry.air or entry.sea then
			if profile.land and entry.land then for _,u in ipairs(entry.land) do table.insert(valid,u) end end
			if profile.air and entry.air then for _,u in ipairs(entry.air) do table.insert(valid,u) end end
			if profile.sea and entry.sea then for _,u in ipairs(entry.sea) do table.insert(valid,u) end end
			if #valid > 0 then return valid[math.random(#valid)] end
		else
			return entry[math.random(#entry)]
		end
		return nil
	end

	-- Funzione per contare quante unità di quella categoria sono "in arrivo" nelle code delle fabbriche 
	local function CountUnitsInQueues(teamID, category, faction)
		local entry = CATEGORY_TO_UNIT[faction][category]
		if not entry then return 0 end
		
		-- Trasformiamo i nomi in ID per un confronto veloce
		local validIDs = {}
		local function fillIDs(list)
			for _, name in ipairs(list) do
				local ud = UnitDefNames[name]
				if ud then validIDs[ud.id] = true end
			end
		end

		if entry.land or entry.air or entry.sea then
			if entry.land then fillIDs(entry.land) end
			if entry.air then fillIDs(entry.air) end
			if entry.sea then fillIDs(entry.sea) end
		else fillIDs(entry) end

		local totalInQueue = 0
		local teamUnits = Spring.GetTeamUnits(teamID)
		for _, uID in ipairs(teamUnits) do
			local ud = UnitDefs[Spring.GetUnitDefID(uID)]
			if ud and ud.isFactory then
				local queue = Spring.GetFullBuildQueue(uID)
				if queue then
					for _, buildItem in ipairs(queue) do
						-- buildItem è { [unitDefID] = count }
						for uDefID, count in pairs(buildItem) do
							if validIDs[uDefID] then
								totalInQueue = totalInQueue + count
							end
						end
					end
				end
			end
		end
		return totalInQueue
	end

	--------------------------------------------------------------------------------
	-- 4) GADGET CORE
	--------------------------------------------------------------------------------

	function gadget:GameFrame(n)
		if n < 35 then return end 
		if not scanDone then AnalyzeMetalMap() end
		if (n % 150 ~= 0) then return end 

		local teamList = Spring.GetTeamList()
		for _, teamID in ipairs(teamList) do
			if not aiTeamIDs[teamID] then
				local aiName = Spring.GetTeamLuaAI(teamID)
				if aiName and aiName ~= "" then
					aiTeamIDs[teamID] = true
					teamLevels[teamID] = 0
					local side = select(5, Spring.GetTeamInfo(teamID))
					teamFactions[teamID] = (side and string.find(string.lower(side), "and")) and "AND" or "ICU"
					Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " detected (" .. teamFactions[teamID] .. ")")
				end
			end
		end

		for teamID, _ in pairs(aiTeamIDs) do
			local faction = teamFactions[teamID]
	 
			CheckStuckBuilders(teamID, n) -- Chiama la funzione di controllo costruttori bloccati

			if not teamBasePos[teamID] then
				local units = Spring.GetTeamUnits(teamID)
				if units and #units > 0 then
					local x,y,z = Spring.GetUnitPosition(units[1])
					teamBasePos[teamID] = {x=x, y=y, z=z}
				else return end
			end

			local currentLvl = teamLevels[teamID]
		
			------------------------------------------------------------------------
			-- LOGICA DI RESET LIVELLO di tipo B: Ritorno al Livello 0 se:  le fabbriche sono distrutte oppure abbiamo meno di x estrattori oppure abbiamo meno di y fabbriche di energia
			------------------------------------------------------------------------
			if currentLvl > 0 then
				-- Contiamo tutti i tipi di fabbriche, Mex e Energia 
				local nFabbriche = CountUnitsInCategory(teamID, "CAT_FACTORY_T1", faction) 															-- per ora ho messo solo le fabbriche T1
				local nMex = CountUnitsInCategory(teamID, "CAT_MEX_T1", faction)+CountUnitsInCategory(teamID, "CAT_MEX_T2", faction) 				-- sommo gli estrattori delle categorie T1 e T2
				local nEnergia = CountUnitsInCategory(teamID, "CAT_ENERGY_T1", faction) + CountUnitsInCategory(teamID, "CAT_ENERGY_T2", faction) 	-- sommo le fabbriche di energia delle categorie T1 e T2
				
				-- Condizioni di fallimento critico:
				local fallimentoFabbriche = (nFabbriche == 0)		-- Se le fabbriche T0 sono totalmente distrutte
				local fallimentoMetallo   = (nMex < 2)       		-- Se scende sotto i 2 estrattori di metallo
				local fallimentoEnergia   = (nEnergia < 2)   		-- Se scende sotto i 2 powerplant

				if fallimentoFabbriche or fallimentoMetallo or fallimentoEnergia then
					teamLevels[teamID] = 0
					if commanderCurrentBehaviour[teamID] ~= "constructor" then
						local comID = GetCommanderID(teamID, faction)	
						if comID then Spring.GiveOrderToUnit(comID, CMD.STOP, {}, {}) end
					end
				commanderCurrentBehaviour[teamID] = "constructor" -- Forza il ritorno a costruttore
					
					if GG.WMRTS_Levels then GG.WMRTS_Levels[teamID] = 0 end
					
					local motivo = fallimentoFabbriche and "No Factories" or (fallimentoMetallo and "Low Metal" or "Low Energy")
					Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " Critical Failure (" .. motivo .. ")! Reverting to Level 0.")
					
					currentLvl = 0 
				end
			end
			------------------------------------------------------------------------		
			
			
			local config = AI_BUILD_LEVELS[currentLvl]
			if not config then return end

	------------------------------------------------------------------------
			-- LOGICA COMPORTAMENTO COMANDANTE (combehaviour)
			------------------------------------------------------------------------
			local targetBehaviour = config.combehaviour or "constructor" 				-- constructor come comportamento di default
			
			-- Eseguiamo il comando solo se il comportamento è cambiato
			if commanderCurrentBehaviour[teamID] ~= targetBehaviour then
				local comID = GetCommanderID(teamID, faction)
				
				if comID then
					if targetBehaviour == "patrolbase" then								-- se il livello richiede patrolbase, gli dai un ordine di PATROL....
						Spring.GiveOrderToUnit(comID, CMD.STOP, {}, {})					-- ... prima "stoppa" qualunque funzione stesse facendo)
						local bp = teamBasePos[teamID]									-- preleva la posizione della base
						-- Creiamo un triangolo di pattuglia attorno alla base
						Spring.GiveOrderToUnit(comID, CMD.PATROL, {bp.x + 150, bp.y, bp.z + 150}, {"shift"})
						Spring.GiveOrderToUnit(comID, CMD.PATROL, {bp.x - 150, bp.y, bp.z - 150}, {"shift"})
						Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " Comandante (" .. UnitDefs[Spring.GetUnitDefID(comID)].name .. ") in PATROL MODE")
					
					elseif targetBehaviour == "constructor" then						-- se il livello richiede constructor...
						Spring.GiveOrderToUnit(comID, CMD.STOP, {}, {})					-- ... dai al comandante un ordine di stop, lui rimarrà idle, il resto della logica lo vedrà fermo e lo impiegherà come costruttore.
						Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " Comandante in BUILDER MODE")
					end
					
					commanderCurrentBehaviour[teamID] = targetBehaviour
				end
			end

			-- Logica Avanzamento Livello
			local levelBroken = false
			for _, req in ipairs(config.requisiti) do
				if CountUnitsInCategory(teamID, req.cat, faction) < req.count then
					levelBroken = true; break
				end
			end
			if not levelBroken and AI_BUILD_LEVELS[currentLvl + 1] then
				teamLevels[teamID] = currentLvl + 1
				if not GG.WMRTS_Levels then GG.WMRTS_Levels = {} end
				GG.WMRTS_Levels[teamID] = teamLevels[teamID]
				Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " Level Up -> " .. teamLevels[teamID])
				return
			end

			-- Identificazione Costruttori e Fabbriche
			local builders = {}
			local factories = {}
			local teamUnits = Spring.GetTeamUnits(teamID)
			for _, uID in ipairs(teamUnits) do
				local ud = UnitDefs[Spring.GetUnitDefID(uID)]
				if ud then
					if ud.canBuild or ud.isBuilder then
						if Spring.GetCommandQueue(uID, 0) == 0 and not Spring.GetUnitIsBuilding(uID) then -- Se il costruttore non ha ordini in coda (GetCommandQueue == 0) ...
							table.insert(builders, uID) --...allora consideralo libero e dagli un ordine
						end
					end
					if ud.isFactory then table.insert(factories, uID) end
				end
			end

			-- Esecuzione Requisiti
			local started = 0
			for _, req in ipairs(config.requisiti) do
				if started >= config.simultanea then break end
				
				local totalPresent = CountUnitsInCategory(teamID, req.cat, faction)
				local totalPending = CountUnitsInQueues(teamID, req.cat, faction)

				if (totalPresent + totalPending) < req.count then
					local unitName = GetRandomUnitFromCat(faction, req.cat)
					local uDef = UnitDefNames[unitName]
					
					if uDef then
						-- CASO A: È una STRUTTURA (Richiede un Builder)		
						if uDef.isBuilding or uDef.isStructure then
							local assigned = false
							local totalFree = #builders
							local capableFound = false

							if totalFree > 0 then
							-- cerchiamo tra tutti i builders disponibili
								for i = #builders, 1, -1 do -- Ciclo inverso per poter rimuovere l'elemento
									local bID = builders[i]
									if CanBuilderBuildThis(bID, uDef.id) then
										capableFound = true
										local bx, by, bz
										if req.cat == "CAT_MEX_T1" or req.cat == "CAT_MEX_T2" then -- #################to do, aggiungere qui l'upgrade in T2 degli estrattori T1!!
											local bx_curr, by_curr, bz_curr = Spring.GetUnitPosition(bID)
												-- Chiama la funzione corretta passandogli l'ID del costruttore per trovare lo spot più vicino
											bx, by, bz = GetClosestMetalSpot(bx_curr, bz_curr, bID, faction, teamID)
												if bx == nil then -- se non trova alcun giacimento di metallo...
												Spring.Echo("WMRTS_contrMngm_AI: Nessun metallo raggiungibile per " .. UnitDefs[Spring.GetUnitDefID(bID)].name) 	-- ...indicalo nel log
												end		
										elseif req.cat == "CAT_FACTORY_T1" or req.cat == "CAT_FACTORY_T2" then														-- se l'AI deve costruire una fabbrica...
												bx, by, bz = GetSafeBuildPosFactory(uDef.id, teamBasePos[teamID], metalSpots)                                		-- Chiama la funzione specifica per le fabbriche
										else			-- altrimenti per tutto il resto...
											bx, by, bz = GetSafeBuildPos(uDef.id, teamBasePos[teamID], metalSpots) 													-- ...Usa la funzione sicura per centrali e fabbriche       
										end
										
										if bx then
											Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " builder " .. bID .. " (" .. UnitDefs[Spring.GetUnitDefID(bID)].name .. ") builds " .. unitName)
											Spring.GiveOrderToUnit(bID, -uDef.id, {bx, by, bz, 0}, {})
											-- --- LOG DISTANZA REALE PATHFINDER ---
											local bName = UnitDefs[Spring.GetUnitDefID(bID)].name
											local pDist = GetRealDistAfterOrder(bID)
											if pDist > 0 then
												  Spring.Echo(string.format("   -> DEBUG PATH Team %d: L'unita '%s' ID=%d percorrera %.0f unita reali per arrivare.", teamID, bName, bID, pDist))
											else
												  Spring.Echo(string.format("   -> DEBUG PATH Team %d: L'unita '%s' ID=%d ha un percorso istantaneo o non ancora calcolato.", teamID, bName, bID))
											end
											--------
														-- Rimuovi il builder dalla lista perché ora è occupato										
											table.remove(builders, i)
											started = started + 1
											assigned = true
											break -- Esci dal ciclo dei builder, abbiamo trovato chi lo fa
										end
									end
								end
							end
							
							-- LOG DI DEBUG AVANZATO
							if not assigned and (n % 450 == 0) then -- Notifica ogni 15 secondi per non intasare
								if totalFree == 0 then
									Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " - STALLO: Nessun costruttore LIBERO per costruire " .. unitName)
								elseif not capableFound then
									Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " - ERRORE COSTRUTTORE: " .. totalFree .. " costruttori liberi, ma NESSUNO sa costruire " .. unitName)
								else
									Spring.Echo("WMRTS_contrMngm_AI: Team " .. teamID .. " - SPAZIO PIENO: Costruttori pronti, ma non trovo una posizione valida (SafePos) per " .. unitName)
								end
							end
						-- CASO B: È un ROBOT/UNITA' MOBILE (Richiede una Fabbrica)
						else
							for _, fID in ipairs(factories) do
								local fud = UnitDefs[Spring.GetUnitDefID(fID)]
								local canProduce = false
								for _, optID in ipairs(fud.buildOptions) do
									if optID == uDef.id then canProduce = true; break end
								end
								
								if canProduce then
									-- Evita di spammare se la fabbrica ha già l'unità in coda
									local alreadyBuilding = false
									local q = Spring.GetFullBuildQueue(fID)
									if q then
										for _, item in ipairs(q) do
											if item[uDef.id] then alreadyBuilding = true; break end
										end
									end

									if not alreadyBuilding then
										Spring.Echo("WMRTS_contrMngm_AI: Factory " .. fID .. " priority production: " .. unitName)
										Spring.GiveOrderToUnit(fID, -uDef.id, {}, {"alt"})
										started = started + 1
										break 
									end
								end
							end
						end -- Fine distinzione edificio/mobile
					end
				end
			end -- Fine ciclo requisiti
		end -- Fine ciclo team
	end