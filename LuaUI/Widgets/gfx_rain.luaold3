function widget:GetInfo()
  return {
    name      = "Rain (Finalized - Focused)",
    desc      = "Pioggia e Splash centrati sul bersaglio della telecamera.",
    author    = "Floris (Modificato)",
    date      = "2024",
    license   = "GNU GPL, v2 or later",
    layer     = -24,
    enabled   = true
  }
end

--------------------------------------------------------------------------------
-- CONFIGURAZIONE
--------------------------------------------------------------------------------

local splashTex = LUAUI_DIRNAME.."Images/weather/rain_splash.png"
local rainKeywords = {'rain', 'tropical', 'swamp', 'wet', 'jungle', 'water', 'river', 'delta', 'marsh', 'island', 'crater', 'lake'}

local intensityMin     = 0.1
local intensityMax     = 1.0
local cycleSpeed       = 0.0005

local particleMultiplier = 0.035 
local rainLineLength     = 75.0
local rainLineWidth      = 1.3
local rainColor          = {0.7, 0.7, 0.9, 0.35}

local showSplashes     = true
local splashSize       = 15.0   
local splashOpacity    = 0.45   
local splashDensity    = 0.1    -- Aumentata densitÃ  per coprire meglio l'area di focus

--------------------------------------------------------------------------------
-- VARIABILI
--------------------------------------------------------------------------------

local particleSteps = 15
local particleLists = {}; local splashLists = {}
local particleStep = 1
local enabled = false
local currentIntensity = 0.5
local shader; local splashShader
local startTimer = Spring.GetTimer()
local currentMapname = Game.mapName:lower()

-- Uniform locations
local uRainTime, uRainCam, uRainScale, uRainWind, uRainLen
local uSplashTime, uSplashTarget, uSplashScale, uSplashSize, uSplashGroundY

--------------------------------------------------------------------------------
-- SHADERS
--------------------------------------------------------------------------------

local vertexRain = [[
	uniform float time;
	uniform float scale;
	uniform float lineLength;
	uniform vec3 wind;
	uniform vec3 camPos;
	void main(void) {
		vec3 basePos = gl_Vertex.xyz * scale;
		basePos.y -= time * 700.0;
		// La pioggia cade sempre intorno alla telecamera (camPos)
		vec3 wrappedPos = mod(basePos - camPos, scale) - (scale * 0.5) + camPos;
		vec3 finalPos = wrappedPos;
		if (gl_Vertex.w > 0.5) {
			finalPos.y += lineLength;
			finalPos.xz -= wind.xz * 0.2;
		}
		gl_FrontColor = gl_Color;
		gl_Position = gl_ModelViewProjectionMatrix * vec4(finalPos, 1.0);
	}
]]

local vertexSplash = [[
	uniform float time;
	uniform float scale;
	uniform float sSize;
	uniform float groundY;
	uniform vec3 targetPos; // Centrato su dove guardiamo
	void main(void) {
		float phase = mod(time * 2.5 + (gl_Vertex.x * 20.0), 1.0);
		float currentSize = phase * sSize;
		vec3 basePos = gl_Vertex.xyz * scale;
		
		// FIX: Il wrapping ora avviene intorno al TARGET, non alla camera
		vec3 wrappedPos = mod(basePos - targetPos, scale) - (scale * 0.5) + targetPos;
		
		vec2 offset = (gl_MultiTexCoord0.xy - 0.5) * currentSize;
		vec3 finalPos = wrappedPos;
		finalPos.x += offset.x;
		finalPos.z += offset.y;
		finalPos.y = groundY + 3.0; 

		gl_TexCoord[0] = gl_MultiTexCoord0;
		gl_FrontColor = vec4(gl_Color.rgb, gl_Color.a * (1.0 - phase));
		gl_Position = gl_ModelViewProjectionMatrix * vec4(finalPos, 1.0);
	}
]]

--------------------------------------------------------------------------------
-- FUNZIONI
--------------------------------------------------------------------------------

function init()
	if not gl.CreateShader then return end
	shader = gl.CreateShader({ vertex = vertexRain })
	splashShader = gl.CreateShader({ vertex = vertexSplash })
	if not shader or not splashShader then return end

	uRainTime = gl.GetUniformLocation(shader, 'time')
	uRainCam = gl.GetUniformLocation(shader, 'camPos')
	uRainScale = gl.GetUniformLocation(shader, 'scale')
	uRainWind = gl.GetUniformLocation(shader, 'wind')
	uRainLen = gl.GetUniformLocation(shader, 'lineLength')
	
	uSplashTime = gl.GetUniformLocation(splashShader, 'time')
	uSplashTarget = gl.GetUniformLocation(splashShader, 'targetPos')
	uSplashScale = gl.GetUniformLocation(splashShader, 'scale')
	uSplashSize = gl.GetUniformLocation(splashShader, 'sSize')
	uSplashGroundY = gl.GetUniformLocation(splashShader, 'groundY')

	local vsx, vsy = gl.GetViewSizes()
	local countMax = math.floor((vsx * vsy) * particleMultiplier)
	for step=1, particleSteps do
		local count = math.floor((countMax / particleSteps) * step)
		particleLists[step] = gl.CreateList(function()
			gl.BeginEnd(GL.LINES, function()
				for i = 1, count do
					local x, y, z = math.random(), math.random(), math.random()
					gl.Vertex(x, y, z, 0); gl.Vertex(x, y, z, 1)
				end
			end)
		end)
		splashLists[step] = gl.CreateList(function()
			gl.BeginEnd(GL.QUADS, function()
				for i = 1, math.floor(count * splashDensity) do
					local x, z = math.random(), math.random()
					local s = math.random()
					gl.TexCoord(0,0); gl.Vertex(s, 0, z, 0)
					gl.TexCoord(1,0); gl.Vertex(s, 0, z, 0)
					gl.TexCoord(1,1); gl.Vertex(s, 0, z, 0)
					gl.TexCoord(0,1); gl.Vertex(s, 0, z, 0)
				end
			end)
		end)
	end
end

function widget:Initialize()
	local found = false
	for _, keyword in pairs(rainKeywords) do
		if string.find(currentMapname, keyword) then found = true; break end
	end
	if found then enabled = true; init() end
end

function widget:Update()
	if not enabled then return end
	local frame = Spring.GetGameFrame()
	local timeFactor = (math.sin(frame * cycleSpeed) + 1) / 2
	currentIntensity = intensityMin + (intensityMax - intensityMin) * timeFactor
	particleStep = math.max(1, math.min(particleSteps, math.floor(particleSteps * currentIntensity)))
end

function widget:DrawWorld()
	if not enabled or not shader or not particleLists[particleStep] then return end
	
	-- Otteniamo le dimensioni attuali della visuale
	local vsx, vsy = gl.GetViewSizes()
	local camX, camY, camZ = Spring.GetCameraPosition()
	
	-- TROVIAMO IL BERSAGLIO USANDO IL RAGGIO (TraceScreenRay)
	-- Spariamo un raggio dal centro dello schermo (vsx/2, vsy/2)
	local type, pos = Spring.TraceScreenRay(vsx / 2, vsy / 2, true)
	
	local tx, ty, tz
	if type == "ground" and pos then
		-- Se tocca il terreno, usiamo quel punto
		tx, ty, tz = pos[1], pos[2], pos[3]
	else
		-- Se guardi il cielo o il raggio fallisce, 
		-- proiettiamo un punto davanti alla camera per non far sparire la pioggia
		local dx, dy, dz = Spring.GetCameraDirection()
		tx = camX + (dx * 1000)
		ty = camY + (dy * 1000)
		tz = camZ + (dz * 1000)
	end
	
	-- Altezza terreno nel punto del bersaglio
	local groundY = Spring.GetGroundHeight(tx, tz) or 0
	
	local diffTime = Spring.DiffTimers(Spring.GetTimer(), startTimer)
	local wX, _, wZ = Spring.GetWind()

	gl.DepthTest(true)
	gl.Blending(GL.SRC_ALPHA, GL.ONE)
	
	-- 1. DISEGNO PIOGGIA (Centrata sulla camera)
	gl.UseShader(shader)
	gl.LineWidth(rainLineWidth)
	gl.Uniform(uRainTime, diffTime)
	gl.Uniform(uRainCam, camX, camY, camZ)
	gl.Uniform(uRainScale, 4500.0)
	gl.Uniform(uRainWind, wX, 0, wZ)
	gl.Uniform(uRainLen, rainLineLength)
	gl.Color(rainColor)
	gl.CallList(particleLists[particleStep])
	gl.UseShader(0)
	
	-- 2. DISEGNO SPRUZZI (Centrati sul bersaglio del raggio)
	if showSplashes then
		gl.Texture(splashTex)
		gl.UseShader(splashShader)
		gl.Uniform(uSplashTime, diffTime)
		gl.Uniform(uSplashTarget, tx, ty, tz)
		gl.Uniform(uSplashScale, 2800.0)
		gl.Uniform(uSplashSize, splashSize)
		gl.Uniform(uSplashGroundY, groundY)
		gl.Color(rainColor[1], rainColor[2], rainColor[3], splashOpacity)
		gl.CallList(splashLists[particleStep])
		gl.Texture(false)
		gl.UseShader(0)
	end

	gl.ResetState()
end

function widget:Shutdown()
	if shader then gl.DeleteShader(shader) end
	if splashShader then gl.DeleteShader(splashShader) end
	for i=1, #particleLists do gl.DeleteList(particleLists[i]) end
	for i=1, #splashLists do gl.DeleteList(splashLists[i]) end
end

function widget:TextCommand(command)
    if (string.find(command, "rain") == 1) then 
		enabled = not enabled
		if enabled and not shader then init() end
		Spring.Echo("Rain: " .. (enabled and "ON" or "OFF"))
	end
end