#define TA			// This is a TA script

#include "sfxtype.h"
#include "exptype.h"

piece  base, asta, origine, bandiera1, bandiera2, bandiera3;
static-var  statechg_DesiredState, statechg_StateChanging, attivo, Rnd_Angle, Rnd_Speed, Rnd_Delay;
#define RAND_RANGE(min,max) ( ( (max) - (min) ) + (min) )
Go()
{
while( TRUE )
	

	while( TRUE )
	{	
		// 1. Genera valori casuali per questo ciclo di animazione
		get-rand Rnd_Angle, 21; // Genera un numero da 0 a 20
		Rnd_Angle = Rnd_Angle + 25; // Ora l'angolo sarà tra 25 e 45 gradi

		get-rand Rnd_Speed, 101; // Genera un numero da 0 a 100
		Rnd_Speed = Rnd_Speed + 150; // Ora la velocità base sarà tra 150 e 250
		
		// ONDA IN AVANTI
		turn bandiera1 to y-axis <1*Rnd_Angle> speed <1.0*Rnd_Speed>;
		// Il pezzo centrale ha un'ampiezza leggermente maggiore e una velocità superiore
		turn bandiera2 to y-axis <-1.2*Rnd_Angle> speed <1.2*Rnd_Speed>;
		// La punta ha l'ampiezza e la velocità maggiori
		turn bandiera3 to y-axis <1.4*Rnd_Angle> speed <1.4*Rnd_Speed>;

		// Aspetta che la base finisca
		wait-for-turn bandiera1 around y-axis;
		
		// Aggiungi una piccola pausa casuale, come una folata di vento che si attenua
		get-rand Rnd_Delay, 101; // Pausa casuale tra 0 e 100 millisecondi
		sleep Rnd_Delay;
		
		// 2. Genera nuovi valori casuali per il ritorno
		get-rand Rnd_Angle, 21;
		Rnd_Angle = Rnd_Angle + 25;
		
		get-rand Rnd_Speed, 101;
		Rnd_Speed = Rnd_Speed + 150;
		
		// ONDA ALL'INDIETRO
		turn bandiera1 to y-axis <-1*Rnd_Angle> speed <1.0*Rnd_Speed>;
		turn bandiera2 to y-axis <1.2*Rnd_Angle> speed <1.2*Rnd_Speed>;
		turn bandiera3 to y-axis <-1.4*Rnd_Angle> speed <1.4*Rnd_Speed>;
		
		wait-for-turn bandiera1 around y-axis;
		
		get-rand Rnd_Delay, 101;
		sleep Rnd_Delay;
	}

/*
soluzione originale
	{	
		// ONDA IN AVANTI
		// Le velocità diverse creano un'onda. La base (bandiera1) è più lenta, la punta (bandiera3) più veloce.
		turn bandiera1 to y-axis <30.0> speed <150.0>;
		turn bandiera2 to y-axis <-30.0> speed <200.0>;
		turn bandiera3 to y-axis <30.0> speed <250.0>;

		// Aspettiamo solo che la base finisca il suo movimento prima di invertire la direzione.
		// Le altre parti continueranno il loro movimento in modo fluido.
		wait-for-turn bandiera1 around y-axis;

		// ONDA ALL'INDIETRO
		turn bandiera1 to y-axis <-30.0> speed <150.0>;
		turn bandiera2 to y-axis <30.0> speed <200.0>;
		turn bandiera3 to y-axis <-30.0> speed <250.0>;
		
		wait-for-turn bandiera1 around y-axis;	
	}
*/	
}

Stop()
{
}

InitState()
{
	statechg_DesiredState = TRUE;
	statechg_StateChanging = FALSE;
}

RequestState(requestedstate, currentstate)
{
	if( statechg_StateChanging )
	{
		statechg_DesiredState = requestedstate;
		return (0);
	}
	statechg_StateChanging = TRUE;
	currentstate = statechg_DesiredState;
	statechg_DesiredState = requestedstate;
	while( statechg_DesiredState != currentstate )
	{
		if( statechg_DesiredState == 0 )
		{
			call-script Go();
			currentstate = 0;
		}
		if( statechg_DesiredState == 1 )
		{
			call-script Stop();
			currentstate = 1;
		}
	}
	statechg_StateChanging = FALSE;
}

Create()
{
attivo = 1;
//	dont-cache torregirevole;
//	dont-shade torregirevole;
	call-script InitState();
//	start-script SmokeUnit();
}

Activate()
{
	start-script RequestState(0);
	attivo = 1;
	
	
		
}

Deactivate()
{
	start-script RequestState(1);
}